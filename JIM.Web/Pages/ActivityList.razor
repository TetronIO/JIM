@page "/activity"
@page "/activity/mine"
@attribute [Authorize(Roles = "User")]
@implements IDisposable
@using JIM.Application
@using JIM.Models.Activities
@using JIM.Models.Staging
@using JIM.Models.Utility;
@using JIM.Utilities;
@using JIM.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IUserPreferenceService PreferenceService

<PageTitle>@_pageTitle</PageTitle>
<MudText Typo="Typo.h4">@_pageTitle</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>

<MudText Typo="Typo.subtitle1" Class="mud-text-secondary mt-2 mb-2">
    @_pageDescription
</MudText>

@if (_preferencesLoaded)
{
<MudTable @ref="_table" T="Activity" ServerData="ServerReload" @bind-CurrentPage="_currentPage" RowsPerPage="@_rowsPerPage" RowsPerPageChanged="OnRowsPerPageChanged" Hover="true" Dense="true" Breakpoint="Breakpoint.Sm"
    Class="mt-5" Outlined="true" Elevation="0" OnRowClick="HandleRowClick" RowClass="cursor-pointer" Loading="@_loading"
    LoadingProgressColor="Color.Primary">
    <ToolBarContent>
        <MudSpacer />
        <MudTextField T="string" ValueChanged="@(s => OnSearch(s))" Placeholder="Search type or target"
            Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium"
            Class="mt-0" />
    </ToolBarContent>
    <HeaderContent>
        <MudTh>
            <MudTableSortLabel SortLabel="operation" T="Activity">
                <MudText Typo="Typo.button">Operation</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="target" T="Activity">
                <MudText Typo="Typo.button">Target</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudText Typo="Typo.button">Stats</MudText>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="type" T="Activity">
                <MudText Typo="Typo.button">Type</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="created" T="Activity" InitialDirection="SortDirection.Descending">
                <MudText Typo="Typo.button">Created</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="initiatedby" T="Activity">
                <MudText Typo="Typo.button">Initiated By</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="status" T="Activity">
                <MudText Typo="Typo.button">Status</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudTableSortLabel SortLabel="executiontime" T="Activity">
                <MudText Typo="Typo.button">Execution Time</MudText>
            </MudTableSortLabel>
        </MudTh>
    </HeaderContent>
    <RowTemplate Context="context">
        <MudTd DataLabel="Operation">
            <MudChip T="string" Variant="Variant.Text"
                Color="Helpers.GetActivityMudBlazorColorForOperation(context.TargetOperationType)">
                @context.TargetOperationType.ToString().SplitOnCapitalLetters()
            </MudChip>
        </MudTd>
        <MudTd DataLabel="Target">
            @if (!string.IsNullOrEmpty(context.TargetContext))
            {
                <span><strong>@context.TargetContext</strong> â†’ @(!string.IsNullOrEmpty(context.TargetName) ? context.TargetName : "(no name)")</span>
            }
            else
            {
                @(!string.IsNullOrEmpty(context.TargetName) ? context.TargetName : "(no name)")
            }
        </MudTd>
        <MudTd DataLabel="Stats">
            @if (context.TargetType == ActivityTargetType.ConnectedSystemRunProfile
                 && context.TargetOperationType == ActivityTargetOperationType.Execute
                 && context.Status != ActivityStatus.InProgress)
            {
                @* Run profile execution stats *@
                @if (context.TotalObjectCreates > 0 || context.TotalObjectUpdates > 0 || context.TotalObjectFlows > 0 || context.TotalObjectDeletes > 0 || context.TotalObjectErrors > 0)
                {
                    <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                        @if (context.TotalObjectCreates > 0)
                        {
                            <MudTooltip Text="@GetCreatesTooltip(context.ConnectedSystemRunType, context.TargetName)" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Text"
                                         Icon="@GetCreatesIcon(context.ConnectedSystemRunType, context.TargetName)" Class="px-2">
                                    @context.TotalObjectCreates
                                </MudChip>
                            </MudTooltip>
                        }
                        @if (context.TotalObjectUpdates > 0)
                        {
                            <MudTooltip Text="@GetUpdatesTooltip(context.ConnectedSystemRunType, context.TargetName)" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Text"
                                         Icon="@GetUpdatesIcon(context.ConnectedSystemRunType, context.TargetName)" Class="px-2">
                                    @context.TotalObjectUpdates
                                </MudChip>
                            </MudTooltip>
                        }
                        @if (context.TotalObjectFlows > 0)
                        {
                            <MudTooltip Text="Attribute Flow" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Size="Size.Small" Color="Color.Info" Variant="Variant.Text"
                                         Icon="@Icons.Material.Filled.SwapHoriz" Class="px-2">
                                    @context.TotalObjectFlows
                                </MudChip>
                            </MudTooltip>
                        }
                        @if (context.TotalObjectDeletes > 0)
                        {
                            <MudTooltip Text="@GetDeletesTooltip(context.ConnectedSystemRunType, context.TargetName)" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Size="Size.Small" Color="Color.Error" Variant="Variant.Text"
                                         Icon="@GetDeletesIcon(context.ConnectedSystemRunType, context.TargetName)" Class="px-2">
                                    @context.TotalObjectDeletes
                                </MudChip>
                            </MudTooltip>
                        }
                        @if (context.TotalObjectErrors > 0)
                        {
                            <MudTooltip Text="Errors" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Size="Size.Small" Color="Color.Error" Variant="Variant.Filled"
                                         Icon="@Icons.Material.Filled.Error" Class="px-2">
                                    @context.TotalObjectErrors
                                </MudChip>
                            </MudTooltip>
                        }
                    </MudStack>
                }
                else
                {
                    @* Run profile execution completed with no changes *@
                    <MudTooltip Text="No changes" Arrow="true" Placement="Placement.Top">
                        <MudChip T="string" Size="Size.Small" Color="Color.Default" Variant="Variant.Text"
                                 Icon="@Icons.Material.Outlined.CheckCircle" Class="px-2">
                            0
                        </MudChip>
                    </MudTooltip>
                }
            }
            else if (context.TargetType == ActivityTargetType.DataGenerationTemplate
                     && context.TargetOperationType == ActivityTargetOperationType.Execute
                     && context.Status != ActivityStatus.InProgress)
            {
                @* Data generation stats - only shows creates *@
                <MudTooltip Text="Objects Generated" Arrow="true" Placement="Placement.Top">
                    <MudChip T="string" Size="Size.Small" Color="Color.Success" Variant="Variant.Text"
                             Icon="@Icons.Material.Filled.Add" Class="px-2">
                        @context.TotalObjectCreates
                    </MudChip>
                </MudTooltip>
            }
            else
            {
                @* Stats not applicable for this activity type *@
                <MudText Typo="Typo.body2" Class="mud-text-disabled" Style="display: flex; align-items: center; justify-content: center; height: 100%; width: 100%;">-</MudText>
            }
        </MudTd>
        <MudTd DataLabel="Type">@context.TargetType.ToString().SplitOnCapitalLetters()</MudTd>
        <MudTd DataLabel="Created">
            <MudTooltip Text="@context.Created.ToLocalTime().ToFriendlyDate()" Arrow="true" Placement="Placement.Top">
                @context.Created.ToLocalTime().ToRelativeTime()
            </MudTooltip>
        </MudTd>
        <MudTd DataLabel="Initiated By">
            @{
                if (context.InitiatedByType == ActivityInitiatorType.User && context.InitiatedByMetaverseObject != null)
                {
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                    <span>@Utilities.GetMetaverseObjectHrefText(context.InitiatedByMetaverseObject)</span>
                }
                else if (context.InitiatedByType == ActivityInitiatorType.ApiKey)
                {
                    <MudIcon Icon="@Icons.Material.Filled.Key" Size="Size.Small" Class="mr-1" Style="vertical-align: middle;" />
                    <span>@context.InitiatedByName</span>
                }
                else if (!string.IsNullOrEmpty(context.InitiatedByName))
                {
                    <span>@context.InitiatedByName</span>
                }
            }
        </MudTd>
        <MudTd DataLabel="Status">
            <MudChip T="string" Variant="Variant.Text"
                Color="Helpers.GetActivityMudBlazorColorForStatus(context.Status)">
                @context.Status.ToString().SplitOnCapitalLetters()
            </MudChip>
        </MudTd>
        <MudTd DataLabel="Execution Time">@(context.ExecutionTime?.ToCasualString() ?? "-")</MudTd>
    </RowTemplate>
    <NoRecordsContent>
        There is no activity to show yet.
    </NoRecordsContent>
    <PagerContent>
        <MudTablePager />
    </PagerContent>
</MudTable>
}

@code {
    private MudTable<Activity>? _table;
    private string _searchString = "";
    private bool _loading;
    private bool _isMyActivity;
    private Guid? _currentUserId;
    private string _pageTitle = "Activity";
    private string _pageDescription = "Monitor all activity across the system. View operations initiated by users or automated processes, including synchronisations, configuration changes, and system events.";
    private List<BreadcrumbItem> _breadcrumbs = new();
    private string _currentPath = "";
    private int _currentPage;
    private int _rowsPerPage = 10;
    private bool _preferencesLoaded;

    protected override async Task OnInitializedAsync()
    {
        NavManager.LocationChanged += OnLocationChanged;
        _currentPath = GetPathWithoutQuery(NavManager.Uri);
        _currentPage = GetPageFromUrl() - 1; // MudTable uses 0-indexed pages
        await UpdatePageStateAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_preferencesLoaded)
        {
            try
            {
                var preferredSize = await PreferenceService.GetRowsPerPageAsync();
                _rowsPerPage = preferredSize;
                _preferencesLoaded = true;
                StateHasChanged(); // Re-render to show the table now that preference is loaded
            }
            catch
            {
                // JS interop not yet available, will retry on next render
            }
        }
    }

    private async Task OnRowsPerPageChanged(int newSize)
    {
        _rowsPerPage = newSize;
        await PreferenceService.SetRowsPerPageAsync(newSize);
    }

    private int GetPageFromUrl()
    {
        var uri = NavManager.ToAbsoluteUri(NavManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        var pageStr = query["p"];
        if (int.TryParse(pageStr, out var page) && page > 0)
            return page;
        return 1; // Default to page 1
    }

    private async void OnLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        var newPath = GetPathWithoutQuery(e.Location);

        // Check if this is just a query string change (e.g., pagination update)
        // If so, don't reload the table as it's already being handled by ServerReload
        if (newPath == _currentPath)
            return;

        // Check if we're navigating away from the activity list pages entirely
        // If so, don't do any work - the component is being disposed
        var isActivityListPage = newPath.EndsWith("/activity", StringComparison.OrdinalIgnoreCase) ||
                                 newPath.EndsWith("/activity/mine", StringComparison.OrdinalIgnoreCase);
        if (!isActivityListPage)
            return;

        _currentPath = newPath;
        await UpdatePageStateAsync();
        await InvokeAsync(StateHasChanged);

        // Reload the table data when the actual path changes (e.g., /activity to /activity/mine)
        if (_table != null)
            await _table.ReloadServerData();
    }

    private static string GetPathWithoutQuery(string uri)
    {
        var questionMarkIndex = uri.IndexOf('?');
        return questionMarkIndex >= 0 ? uri[..questionMarkIndex] : uri;
    }

    private async Task UpdatePageStateAsync()
    {
        _isMyActivity = NavManager.Uri.EndsWith("/activity/mine", StringComparison.OrdinalIgnoreCase);

        if (_isMyActivity)
        {
            _pageTitle = "My Activity";
            _pageDescription = "View operations you have initiated, including synchronisations, configuration changes, and other actions.";

            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            _currentUserId = IdentityUtilities.GetUserId(authState.User);
        }
        else
        {
            _pageTitle = "Activity";
            _pageDescription = "Monitor all activity across the system. View operations initiated by users or automated processes, including synchronisations, configuration changes, and system events.";
            _currentUserId = null;
        }

        _breadcrumbs = new List<BreadcrumbItem>
        {
            new("Home", href: "/", icon: Icons.Material.Filled.Home),
            new(_pageTitle, href: null, disabled: true),
        };
    }

    public void Dispose()
    {
        NavManager.LocationChanged -= OnLocationChanged;
    }

    private async Task<TableData<Activity>> ServerReload(TableState state, CancellationToken token)
    {
        _loading = true;
        StateHasChanged();

        try
        {
            // Convert MudBlazor's 0-indexed page to our 1-indexed page
            var page = state.Page + 1;
            var sortDescending = state.SortDirection == SortDirection.Descending;

            // Update URL with current page (without triggering navigation/reload)
            UpdateUrlWithPage(page);

            var result = await Jim.Activities.GetActivitiesAsync(
                page,
                state.PageSize,
                string.IsNullOrWhiteSpace(_searchString) ? null : _searchString,
                state.SortLabel,
                sortDescending,
                _currentUserId);

            return new TableData<Activity>
            {
                TotalItems = result.TotalResults,
                Items = result.Results
            };
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void UpdateUrlWithPage(int page)
    {
        var uri = NavManager.ToAbsoluteUri(NavManager.Uri);
        var baseUrl = uri.GetLeftPart(UriPartial.Path);

        // Only add ?p= if not on page 1
        var newUrl = page > 1 ? $"{baseUrl}?p={page}" : baseUrl;

        // Update URL without navigation (replace current history entry)
        NavManager.NavigateTo(newUrl, replace: true);
    }

    private void OnSearch(string text)
    {
        _searchString = text;
        _table?.ReloadServerData();
    }

    private void HandleRowClick(TableRowClickEventArgs<Activity> args)
    {
        // Prevent navigation while data is loading to avoid concurrent EF operations
        if (_loading || args.Item == null)
            return;

        // Navigate using absolute path to ensure no query params are carried over
        var uri = NavManager.ToAbsoluteUri($"/activity/{args.Item.Id}");
        NavManager.NavigateTo(uri.AbsolutePath);
    }

    /// <summary>
    /// Gets run-type-aware tooltip for creates stat.
    /// Falls back to checking target name if run type is NotSet.
    /// </summary>
    private static string GetCreatesTooltip(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Import" => "Added",
            "Sync" => "Projected",
            "Export" => "Provisioned",
            _ => "Created"
        };
    }

    /// <summary>
    /// Gets run-type-aware icon for creates stat.
    /// Sync uses Commit (committing projections to metaverse), others use Add.
    /// </summary>
    private static string GetCreatesIcon(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Sync" => Icons.Material.Filled.Commit,
            _ => Icons.Material.Filled.Add
        };
    }

    /// <summary>
    /// Gets run-type-aware tooltip for updates stat.
    /// Falls back to checking target name if run type is NotSet.
    /// </summary>
    private static string GetUpdatesTooltip(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Import" => "Updated",
            "Sync" => "Joined",
            "Export" => "Exported",
            _ => "Updated"
        };
    }

    /// <summary>
    /// Gets run-type-aware tooltip for deletes stat.
    /// Falls back to checking target name if run type is NotSet.
    /// </summary>
    private static string GetDeletesTooltip(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Import" => "Deleted",
            "Sync" => "Disconnected",
            "Export" => "Deprovisioned",
            _ => "Deleted"
        };
    }

    /// <summary>
    /// Gets run-type-aware icon for updates stat.
    /// Sync uses Link (joining/flowing - opposite of LinkOff), others use Sync (circular arrows).
    /// </summary>
    private static string GetUpdatesIcon(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Sync" => Icons.Material.Filled.Link,
            _ => Icons.Material.Filled.Sync
        };
    }

    /// <summary>
    /// Gets run-type-aware icon for deletes stat.
    /// Sync uses LinkOff (disconnection), others use Delete (trash).
    /// </summary>
    private static string GetDeletesIcon(ConnectedSystemRunType? runType, string? targetName)
    {
        var effectiveRunType = GetEffectiveRunType(runType, targetName);
        return effectiveRunType switch
        {
            "Sync" => Icons.Material.Filled.LinkOff,
            _ => Icons.Material.Filled.Delete
        };
    }

    /// <summary>
    /// Determines the effective run type category from the enum or target name fallback.
    /// </summary>
    private static string GetEffectiveRunType(ConnectedSystemRunType? runType, string? targetName)
    {
        // Check enum first
        if (runType is ConnectedSystemRunType.FullImport or ConnectedSystemRunType.DeltaImport)
            return "Import";
        if (runType is ConnectedSystemRunType.FullSynchronisation or ConnectedSystemRunType.DeltaSynchronisation)
            return "Sync";
        if (runType is ConnectedSystemRunType.Export)
            return "Export";

        // Fallback to target name if run type is NotSet or null
        if (!string.IsNullOrEmpty(targetName))
        {
            if (targetName.Contains("Import", StringComparison.OrdinalIgnoreCase))
                return "Import";
            if (targetName.Contains("Sync", StringComparison.OrdinalIgnoreCase))
                return "Sync";
            if (targetName.Contains("Export", StringComparison.OrdinalIgnoreCase))
                return "Export";
        }

        return "Unknown";
    }
}
