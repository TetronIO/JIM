@page "/admin/sync-rules/new"
@page "/admin/sync-rules/{Id:int}"
@attribute [Authorize(Roles = "Administrator")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Logic
@using JIM.Models.Search
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Models.Utility
@using JIM.Utilities
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject IDialogService DialogService
@inject ISnackbar Snackbar
@inject IJSRuntime JS

<PageTitle>Synchronisation Rule: @_syncRuleNameOrCreate</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-primary-text">Synchronisation Rule:</span> @_syncRuleNameOrCreate</MudText>
<div class="d-flex justify-space-between align-center">
    <MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>
    @if (_syncRule is { Id: > 0 })
    {
        <AuditInfo Entity="@_syncRule" />
    }
</div>

@if (_isLoading)
{
    <div class="d-flex flex-column align-center justify-center mt-16">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        <MudText Typo="Typo.body2" Class="mt-4 mud-text-secondary">Loading synchronisation rule...</MudText>
    </div>
}
else if (_syncRule != null)
{
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="false" PanelClass="pt-5" Class="mt-2" Outlined="true">
        <MudTabPanel Text="Details">
            <MudPaper Class="pa-4" Outlined="true">
                <MudForm @bind-IsValid="@_isDetailsFormValid" @bind-Errors="@_detailsFormErrors">
            <MudTextField Label="Name" Required="true" RequiredError="A name is required" @bind-Value="_syncRule.Name"
                Variant="Variant.Outlined" />

            @if (_syncRule.Id > 0 && _syncRule.ConnectedSystem != null)
            {
                <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-4" Spacing="3">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudIcon Icon="@Icons.Material.Filled.Power" Class="mud-text-secondary" />
                        <MudText Typo="Typo.body1" Class="mud-text-secondary">Connected System:</MudText>
                        <MudLink Href="@($"/admin/connected-systems/{_syncRule.ConnectedSystemId}")" Typo="Typo.body1">
                            @_syncRule.ConnectedSystem.Name
                        </MudLink>
                    </MudStack>
                    <MudDivider Vertical="true" FlexItem="true" />
                    <MudChip T="string" Variant="Variant.Text"
                             Color="@(_syncRule.Direction == SyncRuleDirection.Import ? Color.Info : Color.Warning)">
                        @(_syncRule.Direction == SyncRuleDirection.Import ? "Inbound" : "Outbound")
                    </MudChip>
                    <MudDivider Vertical="true" FlexItem="true" />
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText Typo="Typo.body1" Class="mud-text-secondary">Object Types:</MudText>
                        <MudChip T="string">
                            <AvatarContent>
                                <MudAvatar Color="Color.Primary">MV</MudAvatar>
                            </AvatarContent>
                            <ChildContent>@_syncRule.MetaverseObjectType?.Name</ChildContent>
                        </MudChip>
                        <MudText Class="mud-text-secondary">→</MudText>
                        <MudChip T="string">
                            <AvatarContent>
                                <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                            </AvatarContent>
                            <ChildContent>@_syncRule.ConnectedSystemObjectType?.Name</ChildContent>
                        </MudChip>
                    </MudStack>
                </MudStack>
            }

            @if (_syncRule.Id == 0)
            {
                @if (_connectedSystemHeaders != null)
                {
                    <MudSelect T="string" Label="Connected System" Placeholder="Please select a Connected System..." Required="true"
                        ValueChanged="HandleConnectedSystemSelectedAsync" AdornmentIcon="@Icons.Material.Filled.Power"
                        Adornment="Adornment.Start" Variant="Variant.Outlined" Class="mt-5">
                        @foreach (var header in _connectedSystemHeaders)
                        {
                            <MudSelectItem Value="@header.Id.ToString()">@header.Name</MudSelectItem>
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null)
                {
                    <MudSelect T="string" Label="Direction" Placeholder="Please select an attribute flow direction..."
                        Required="true" ValueChanged="HandleSyncRuleDirectionSelection" Variant="Variant.Outlined" Class="mt-5">
                        @foreach (SyncRuleDirection direction in Enum.GetValues(typeof(SyncRuleDirection)))
                        {
                            if (direction != SyncRuleDirection.NotSet)
                            {
                                // does the connector definition support this direction?
                                var directionSupported = false;
                                if (direction == SyncRuleDirection.Export)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsExport;
                                }
                                else if (direction == SyncRuleDirection.Import)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsDeltaImport ||
                                    _syncRule.ConnectedSystem.ConnectorDefinition.SupportsFullImport;
                                }

                                <MudSelectItem Disabled="!directionSupported" Value="@direction.ToString()">@direction@(directionSupported ?
                                                    "" : " (not supported by Connector)")</MudSelectItem>
                            }
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null && _syncRule.Direction != SyncRuleDirection.NotSet &&
                        _metaverseObjectTypes != null && _syncRule.ConnectedSystem is { ObjectTypes: not null })
                {
                    <MudGrid>
                        <MudItem xs="5">
                            <MudSelect T="MetaverseObjectType" Label="Metaverse Object Type"
                                @bind-Value="@_syncRule.MetaverseObjectType" Required="true" Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var mvObjectType in _metaverseObjectTypes)
                                {
                                    <MudSelectItem Value="@mvObjectType">@mvObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="2">
                            <MudPaper Outlined="false" Elevation="0"
                                Class="d-flex flex-column align-center justify-center mud-width-full py-10">
                                <MudIcon Size="Size.Medium"
                                    Icon="@(_syncRule.Direction == SyncRuleDirection.Export ? Icons.Material.Filled.KeyboardDoubleArrowRight : Icons.Material.Filled.KeyboardDoubleArrowLeft)">
                                </MudIcon>
                            </MudPaper>
                        </MudItem>
                        <MudItem xs="5">
                            <MudSelect T="ConnectedSystemObjectType" Label="Connected System Object Type"
                                @bind-Value="@_syncRule.ConnectedSystemObjectType" Required="true" Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var csObjectType in _syncRule.ConnectedSystem.ObjectTypes.Where(ot => ot.Selected))
                                {
                                    <MudSelectItem Value="@csObjectType">@csObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                    </MudGrid>
                }

            }
        </MudForm>
        @if (_syncRule.Direction == SyncRuleDirection.Import)
        {
            <MudSwitch Class="mt-5" @bind-Value="@_syncRule.ProjectToMetaverse" Color="Color.Primary"
                Label="Create imported objects in the Metaverse?" />
            <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Outlined">By default, objects imported from this
                Connected System matched in this synchronisation rule will not result in a Metaverse object being created.
                Enabling this option causes the object to be projected to the Metaverse, allowing it to be managed within
                JIM and synchronised to other Connected Systems. You would typically enable this for a source system, i.e. a
                HR system.</MudAlert>
        }

        @if (_syncRule.Direction == SyncRuleDirection.Export)
        {
            <MudSwitch Class="mt-5" @bind-Value="@_syncRule.ProvisionToConnectedSystem" Color="Color.Primary"
                Label="@($"Provision {(_syncRule.ConnectedSystemObjectType?.Name ?? "objects").Pluralise()} to the Connected System?")" />
            <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Outlined">By default, Metaverse objects matched
                in this synchronisation rule will not be created (provisioned) in the Connected Systems. Enabling this
                option will cause the Metaverse object to be created in the Connected System. You would typically enable
                this option for a destination system, i.e. when trying to implement a HR to Active Directory flow.
            </MudAlert>
        }
        <MudTooltip Text="Synchronisation Rules will not be evaluated when disabled. This allows to either prepare a rule in advance of it being needed, or to temporarily stop a sync rule from being evaluated."
                    Arrow="true" Placement="Placement.Top">
            <MudSwitch Class="mt-5" @bind-Value="@_syncRule.Enabled" Color="Color.Primary" Label="Enabled?" />
        </MudTooltip>
    </MudPaper>

    @* Advanced Options - Only show for Export rules *@
    @if (_syncRule.Direction == SyncRuleDirection.Export)
    {
        <MudExpansionPanels Elevation="0" Class="mt-5 jim-expansion-panel">
            <MudExpansionPanel Text="Advanced Options">
                <TitleContent>
                    <div class="d-flex align-center">
                        <MudIcon Icon="@Icons.Material.Filled.Settings" Class="me-2" />
                        <MudText Typo="Typo.subtitle1">Advanced Options</MudText>
                    </div>
                </TitleContent>
                <ChildContent>
                    <MudStack Spacing="4" Class="pa-2">
                        <MudTooltip Text="When enabled, changes made directly in the target system (drift) will be automatically corrected during the next sync run. Disable this only if you need to allow emergency manual changes in the target system."
                                    Arrow="true" Placement="Placement.Right">
                            <MudSwitch @bind-Value="@_syncRule.EnforceState" Color="Color.Primary"
                                       Label="Enforce State (Auto-correct drift)" />
                        </MudTooltip>
                        <MudAlert Severity="Severity.Normal" Variant="Variant.Text" Dense="true">
                            <strong>Enforce State</strong> enables drift detection and automatic correction. When a target system
                            attribute differs from what this export rule dictates, JIM will create a corrective pending export
                            to restore the authoritative value. Disable this option only for scenarios where you need to allow
                            temporary manual overrides in the target system (e.g., emergency access scenarios).
                        </MudAlert>
                    </MudStack>
                </ChildContent>
            </MudExpansionPanel>
        </MudExpansionPanels>
    }

    @if (_syncRule.Direction != SyncRuleDirection.NotSet)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <div class="d-flex justify-space-between align-center">
                <MudText Typo="Typo.h5">Matching Rules</MudText>
                @if (_syncRule.ConnectedSystem?.ObjectMatchingRuleMode == ObjectMatchingRuleMode.SyncRule)
                {
                    <MudTooltip Text="Matching rules are specific to this sync rule." Arrow="true" Placement="Placement.Top">
                        <MudChip T="string" Variant="Variant.Text" Text="Advanced Mode" Color="Color.Info" />
                    </MudTooltip>
                }
            </div>

            @if (_syncRule.ConnectedSystem?.ObjectMatchingRuleMode == ObjectMatchingRuleMode.ConnectedSystem)
            {
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Class="mt-3" Icon="@Icons.Material.Outlined.Info">
                    This Connected System uses <strong>Simple Mode</strong> for object matching.
                    <MudLink Href="@($"/admin/connected-systems/{_syncRule.ConnectedSystemId}")" Underline="Underline.Always" Class="ms-1">
                        <MudIcon Icon="@Icons.Material.Filled.OpenInNew" Class="me-1" Style="vertical-align: middle;" />Configure Matching Rules
                    </MudLink>
                </MudAlert>
            }
            else
            {
                @* Advanced Mode - matching rules are managed per sync rule *@
                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudText Class="mt-3">
                        Define rules to match Connected System Objects to Metaverse objects. Use immutable attributes (e.g., employeeID, objectGUID).
                        Multiple rules can be ordered; the first match wins. Objects are Joined when matched, Disconnected when not.
                    </MudText>
                }
                else if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    <MudText Class="mt-3">
                        Define rules to match Metaverse objects to Connected System Objects. Use immutable attributes (e.g., employeeID, objectGUID).
                        Multiple rules can be ordered; the first match wins.
                    </MudText>
                }

                <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
                    OnClick="HandleOpenAddMatchingRuleMappingDialog" Color="Color.Default" Class="mt-5" DropShadow="false"
                    Disabled="@(_syncRule.MetaverseObjectType == null || _syncRule.ConnectedSystemObjectType == null)">Add Matching
                    Rule</MudButton>

                @foreach (var objectMatchingRule in _syncRule.ObjectMatchingRules.OrderBy(omr => omr.Order))
                {
                    var sourceType = objectMatchingRule.GetSourceType();
                    <MudPaper Class="pa-4 mt-5" Outlined="true">
                        @if (sourceType == SyncRuleMappingSourcesType.AttributeMapping && objectMatchingRule.TargetMetaverseAttribute !=
                                null)
                        {
                            var source = objectMatchingRule.Sources[0];
                            if (source.ConnectedSystemAttribute != null)
                            {
                                <MudGrid Spacing="0">
                                    <MudItem xs="6">
                                        <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span>
                                            @objectMatchingRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                                    </MudItem>
                                    <MudItem xs="6" Class="d-flex align-center justify-end">
                                        <MudText Typo="Typo.overline">POSITION: @(objectMatchingRule.Order + 1)</MudText>
                                    </MudItem>
                                    <MudItem xs="12" Class="d-flex align-center">
                                        <MudChip T="string">
                                            <AvatarContent>
                                                <MudTooltip Text="Connected System Attribute" Arrow="true" Placement="Placement.Top">
                                                    <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                                                </MudTooltip>
                                            </AvatarContent>
                                            <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                                        </MudChip>
                                        <MudChip T="string">
                                            <MudIcon Icon="@Icons.Material.Filled.DragHandle"></MudIcon>
                                        </MudChip>
                                        <MudChip T="string">
                                            <AvatarContent>
                                                <MudTooltip Text="Metaverse Attribute" Arrow="true" Placement="Placement.Top">
                                                    <MudAvatar Color="Color.Primary">MV</MudAvatar>
                                                </MudTooltip>
                                            </AvatarContent>
                                            <ChildContent>@objectMatchingRule.TargetMetaverseAttribute.Name</ChildContent>
                                        </MudChip>
                                        <MudSwitch T="bool" Value="@objectMatchingRule.CaseSensitive"
                                            ValueChanged="@(value => HandleToggleMatchingRuleCaseSensitive(objectMatchingRule, value))"
                                            Label="Case Sensitive" Color="Color.Primary" Class="ms-4" />
                                        <MudSpacer />
                                        <MudIconButton Icon="@Icons.Material.Outlined.ArrowUpward" Variant="Variant.Outlined" Color="Color.Default"
                                            Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "up"))"
                                            Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "up")" />
                                        <MudIconButton Icon="@Icons.Material.Outlined.ArrowDownward" Variant="Variant.Outlined" Color="Color.Default"
                                            Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "down"))"
                                            Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "down")" />
                                        <MudIconButton Icon="@Icons.Material.Outlined.Delete" Variant="Variant.Outlined" Color="Color.Error"
                                            aria-label="delete" OnClick="@(() => HandleObjectMatchingRuleDeleteClickAsync(objectMatchingRule))">
                                        </MudIconButton>
                                    </MudItem>
                                </MudGrid>
                            }
                        }
                    </MudPaper>
                }
            }
        </MudPaper>

        <MudDialog @bind-Visible="_addMatchingRuleDialogVisible" Options="_dialogOptions">
            <TitleContent>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Matching Rule
                </MudText>
            </TitleContent>
            <DialogContent>

                <MudSelect T="string" Label="Source Type" Placeholder="Please select the type of source for this matching rule"
                    Required="true" ValueChanged="HandleAddMatchingRuleMappingTypeValueChange" Variant="Variant.Outlined">
                    <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                    <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
                </MudSelect>

                @if (_matchingRuleMapping != null && _matchingRuleMappingSource != null)
                {
                    @switch (_matchingRuleMappingSourceType)
                    {
                        case "Attribute":
                            {
                                <MudSelect T="MetaverseAttribute" @bind-Value="_matchingRuleMapping.TargetMetaverseAttribute"
                                    Label="Metaverse Attribute" Placeholder="Please select a Metaverse attribute" Required="true" Class="mt-5"
                                    Variant="Variant.Outlined">
                                    @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(a => a.AttributePlurality
                                                == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                    {
                                        <MudSelectItem Value="@metaverseAttribute">
                                            @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                                @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                        </MudSelectItem>
                                    }
                                </MudSelect>

                                if (_matchingRuleMapping.TargetMetaverseAttribute != null)
                                {
                                    <MudSelect T="ConnectedSystemObjectTypeAttribute"
                                        @bind-Value="_matchingRuleMappingSource.ConnectedSystemAttribute" Label="Connected System Attribute"
                                        Placeholder="Please select the Connected System attribute" Required="true" Class="mt-5"
                                        Variant="Variant.Outlined">
                                        @foreach (var connectedSystemObjectTypeAttribute in _syncRule.ConnectedSystemObjectType.Attributes.Where(a
                                                    => a.AttributePlurality == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                        {
                                            <MudSelectItem Value="@connectedSystemObjectTypeAttribute"
                                                Disabled="@(connectedSystemObjectTypeAttribute.Type != _matchingRuleMapping.TargetMetaverseAttribute.Type)">
                                                @connectedSystemObjectTypeAttribute.Name <span
                                                    style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemObjectTypeAttribute.Type :
                                                    @connectedSystemObjectTypeAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                            </MudSelectItem>
                                        }
                                    </MudSelect>

                                    <MudCheckBox T="bool" @bind-Value="_matchingRuleMapping.CaseSensitive" Label="Case Sensitive" Class="mt-5" />
                                }
                                break;
                            }
                        case "Expression":
                            <MudText Class="mt-5">Sorry, expressions are not yet supported.</MudText>
                            break;
                    }
                }
            </DialogContent>
            <DialogActions>
                <MudButton DropShadow="false" Variant="Variant.Filled" Color="Color.Default"
                    OnClick="@(() => _addMatchingRuleDialogVisible = false)" Class="me-2">Cancel</MudButton>
                <MudButton Disabled="DisableAddMappingButton()" DropShadow="false" Variant="Variant.Filled"
                    Color="Color.Primary" OnClick="HandleAddMappingButtonClick">Add Matching Rule</MudButton>
            </DialogActions>
        </MudDialog>
    }

    @* Scoping criteria for Import and Export sync rules *@
    @if (_syncRule.Id > 0 && _syncRule.MetaverseObjectType != null && _syncRule.ConnectedSystemObjectType != null)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            @if (_syncRule.Direction == SyncRuleDirection.Export)
            {
                <MudText Typo="Typo.h5">Metaverse Object Scope</MudText>
                <MudText Class="mt-5">
                    By default, all Metaverse objects of type '@_syncRule.MetaverseObjectType.Name' will be in scope of this
                    Synchronisation Rule, though to have it apply to a subset of those objects, use a filter. i.e. you might
                    only want this rule to apply to Staff, not Contractors.
                </MudText>
            }
            else
            {
                <MudText Typo="Typo.h5">Connected System Object Scope</MudText>
                <MudText Class="mt-5">
                    By default, all Connected System objects of type '@_syncRule.ConnectedSystemObjectType.Name' will be in scope
                    of this Synchronisation Rule. Use a filter to import only specific objects, e.g. only Active users, not Disabled.
                </MudText>
            }

            <MudRadioGroup @bind-Value="_syncRuleScopingFiltered" Class="mt-5">
                <MudRadio Value="false">All Objects</MudRadio>
                <MudRadio Value="true">Filtered</MudRadio>
            </MudRadioGroup>

            @if (_syncRuleScopingFiltered)
            {
                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudSelect T="InboundOutOfScopeAction" @bind-Value="_syncRule.InboundOutOfScopeAction"
                               Label="When objects fall out of scope" Variant="Variant.Outlined" Class="mt-5">
                        <MudSelectItem Value="InboundOutOfScopeAction.Disconnect">
                            Disconnect from Metaverse
                        </MudSelectItem>
                        <MudSelectItem Value="InboundOutOfScopeAction.RemainJoined">
                            Remain joined (stop attribute flow)
                        </MudSelectItem>
                    </MudSelect>
                    <MudAlert Severity="Severity.Info" Class="mt-3" Variant="Variant.Outlined" Dense="true">
                        @if (_syncRule.InboundOutOfScopeAction == InboundOutOfScopeAction.Disconnect)
                        {
                            <text>Objects that fall out of scope will be disconnected from their Metaverse object. This may trigger
                            attribute removal and MVO deletion rules if it was the last connector.</text>
                        }
                        else
                        {
                            <text>Objects that fall out of scope will remain joined but attribute flow will stop. Use this for
                            "once managed, always managed" scenarios.</text>
                        }
                    </MudAlert>
                }

                @if (_syncRule.ObjectScopingCriteriaGroups.Count == 0)
                {
                    <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
                        OnClick="HandleOpenAddScopingCriteriaGroupDialog" Class="mt-5" DropShadow="false">Add Criteria Group</MudButton>
                }

                <MudDialog @bind-Visible="_addScopingCriteriaGroupDialogVisible" Options="_dialogOptions">
                    <TitleContent>
                        <MudText Typo="Typo.h6">
                            <MudIcon Icon="@Icons.Material.Filled.AccountTree" Class="mr-3" /> Add Criteria Group
                        </MudText>
                    </TitleContent>
                    <DialogContent>
                        <MudSelect T="string" Label="Please choose a group type" Required="true" Variant="Variant.Outlined"
                            @bind-Value="_criteriaGroupTypeText">
                            @foreach (var type in Enum.GetValues(typeof(SearchGroupType)))
                            {
                                <MudSelectItem Value="@type.ToString()" />
                            }
                        </MudSelect>
                    </DialogContent>
                    <DialogActions>
                        <MudButton DropShadow="false" Variant="Variant.Filled" Color="Color.Default"
                            OnClick="@(() => _addScopingCriteriaGroupDialogVisible = false)" Class="me-2">Cancel</MudButton>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="HandleAddCriteriaGroupButtonClick"
                            Disabled="DisableAddScopingCriteriaGroupFormButton()" DropShadow="false">Add Group
                        </MudButton>
                    </DialogActions>
                </MudDialog>
            }
        </MudPaper>

        @foreach (var rootCriteriaGroup in _syncRule.ObjectScopingCriteriaGroups)
        {
            <SyncRuleDetailScopingCriteriaGroup SyncRule="_syncRule" SyncRuleScopingCriteriaGroup="rootCriteriaGroup"
                SyncRuleChanged="HandleStateHasChanged" SyncRuleScopingCriteriaGroupChanged="HandleStateHasChanged" />
        }
    }

    <MudText Typo="Typo.h5" Class="mt-5">Attribute Flow</MudText>
    <div class="d-flex align-center justify-space-between mt-5">
        <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
            OnClick="HandleOpenAddAttributeFlowRuleDialog" Color="Color.Default"
            Disabled="DisableAddAttributeFlowButton()" DropShadow="false">Add Attribute Flow</MudButton>
        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
            <MudTooltip Text="Table view" Arrow="true" Placement="Placement.Top">
                <MudIconButton Icon="@Icons.Material.Filled.TableRows"
                               Color="@(_attributeFlowTableView ? Color.Primary : Color.Default)"
                               OnClick="@(() => ToggleAttributeFlowViewAsync(true))" />
            </MudTooltip>
            <MudTooltip Text="Card view" Arrow="true" Placement="Placement.Top">
                <MudIconButton Icon="@Icons.Material.Filled.GridView"
                               Color="@(!_attributeFlowTableView ? Color.Primary : Color.Default)"
                               OnClick="@(() => ToggleAttributeFlowViewAsync(false))" />
            </MudTooltip>
        </MudStack>
    </div>

    @if (_attributeFlowTableView)
    {
        <MudTable Items="@_syncRule.AttributeFlowRules" Hover="true" Outlined="true" Elevation="0"
                  Dense="true" Breakpoint="Breakpoint.Sm" Class="mt-2 mb-5">
            <HeaderContent>
                <MudTh><MudText Typo="Typo.button">Type</MudText></MudTh>
                <MudTh><MudText Typo="Typo.button">Source</MudText></MudTh>
                <MudTh></MudTh>
                <MudTh><MudText Typo="Typo.button">Target</MudText></MudTh>
                <MudTh></MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Type">
                    <MudChip T="string" Variant="Variant.Text" Color="@Helpers.GetMappingTypeChipColour(context.GetSourceType())">
                        @context.GetSourceType().ToString().SplitOnCapitalLetters()
                    </MudChip>
                </MudTd>
                <MudTd DataLabel="Source">
                    @foreach (var source in context.Sources.OrderBy(q => q.Order))
                    {
                        if (_syncRule.Direction == SyncRuleDirection.Import && source.ConnectedSystemAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Connected System Attribute" Arrow="true" Placement="Placement.Top">
                                        <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (_syncRule.Direction == SyncRuleDirection.Export && source.MetaverseAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Metaverse Attribute" Arrow="true" Placement="Placement.Top">
                                        <MudAvatar Color="Color.Primary">MV</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.MetaverseAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (!string.IsNullOrWhiteSpace(source.Expression))
                        {
                            <MudTooltip Text="@source.Expression" Arrow="true" Placement="Placement.Top">
                                <MudChip T="string" Class="jim-expr-chip">
                                    <AvatarContent>
                                        <MudAvatar Color="Color.Secondary">Ex</MudAvatar>
                                    </AvatarContent>
                                    <ChildContent><span class="jim-expr-syntax">@((MarkupString)Helpers.HighlightExpression(source.Expression!))</span></ChildContent>
                                </MudChip>
                            </MudTooltip>
                        }
                    }
                </MudTd>
                <MudTd><MudText Class="mud-text-secondary">→</MudText></MudTd>
                <MudTd DataLabel="Target">
                    @if (_syncRule.Direction == SyncRuleDirection.Import && context.TargetMetaverseAttribute != null)
                    {
                        <MudChip T="string">
                            <AvatarContent>
                                <MudTooltip Text="Metaverse Attribute" Arrow="true" Placement="Placement.Top">
                                    <MudAvatar Color="Color.Primary">MV</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@context.TargetMetaverseAttribute.Name</ChildContent>
                        </MudChip>
                    }
                    else if (_syncRule.Direction == SyncRuleDirection.Export && context.TargetConnectedSystemAttribute != null)
                    {
                        <MudChip T="string">
                            <AvatarContent>
                                <MudTooltip Text="Connected System Attribute" Arrow="true" Placement="Placement.Top">
                                    <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@context.TargetConnectedSystemAttribute.Name</ChildContent>
                        </MudChip>
                    }
                </MudTd>
                <MudTd>
                    <MudIconButton Icon="@Icons.Material.Outlined.Delete" Variant="Variant.Filled" Color="Color.Error"
                        Size="Size.Small" aria-label="delete"
                        OnClick="@(() => HandleAttributeFlowRuleDeleteClick(context))" />
                </MudTd>
            </RowTemplate>
            <NoRecordsContent>
                No attribute flow rules defined yet.
            </NoRecordsContent>
        </MudTable>
    }

    <MudDialog @bind-Visible="_addAttributeFlowRuleDialogVisible" Options="_dialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Attribute Flow
            </MudText>
        </TitleContent>
        <DialogContent>
            <MudSelect T="string" Label="Source Type" Placeholder="Please select the type of source for this attribute flow"
                Required="true" @bind-Value="_attributeFlowMappingSourceType" Variant="Variant.Outlined">
                <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                <MudSelectItem Value="@("Function")">Function</MudSelectItem>
                <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
            </MudSelect>

            @if (_attributeFlowMapping != null && _attributeFlowMappingSource != null && _syncRule.MetaverseObjectType !=
                    null)
            {
                @switch (_attributeFlowMappingSourceType)
                {
                    case "Attribute":
                        {
                            if (_syncRule.Direction == SyncRuleDirection.Import)
                            {
                                <MudSelect T="ConnectedSystemObjectTypeAttribute"
                                    @bind-Value="_attributeFlowMappingSource.ConnectedSystemAttribute" Label="Connected System Attribute"
                                    Placeholder="Please select the source Connected System attribute" Required="true" Class="mt-5"
                                    Variant="Variant.Outlined">
                                    @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType!.Attributes)
                                    {
                                        <MudSelectItem Value="@connectedSystemAttribute">@connectedSystemAttribute.Name <span
                                                style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type :
                                                @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                        </MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            else if (_syncRule.Direction == SyncRuleDirection.Export)
                            {
                                <MudSelect T="MetaverseAttribute" @bind-Value="_attributeFlowMappingSource.MetaverseAttribute"
                                    Label="Metaverse Attribute" Placeholder="Please select the source Metaverse attribute" Required="true"
                                    Class="mt-5" Variant="Variant.Outlined">
                                    @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes)
                                    {
                                        <MudSelectItem Value="@metaverseAttribute">@metaverseAttribute.Name <span
                                                style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                                @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span></MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            break;
                        }
                    case "Function":
                        <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Class="mt-5">Sorry, functions are no yet supported.</MudAlert>
                        break;
                    case "Expression":
                        <MudAlert Severity="Severity.Error" Variant="Variant.Outlined" Class="mt-5">Sorry, expressions are no yet supported.</MudAlert>
                        break;
                }

                // user must have chosen the source attribute before being shown the target attribute controls
                if (_attributeFlowMappingSource.ConnectedSystemAttribute != null ||
                _attributeFlowMappingSource.MetaverseAttribute != null)
                {
                    <MudText Class="mt-5">Will flow to:</MudText>
                    if (_syncRule.Direction == SyncRuleDirection.Import)
                    {
                        <MudSelect T="MetaverseAttribute" @bind-Value="_attributeFlowMapping.TargetMetaverseAttribute"
                            Label="Metaverse Attribute" Placeholder="Please select the target Metaverse attribute" Required="true"
                            Class="mt-5" Variant="Variant.Outlined">
                            @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(q =>
                                        !_syncRule.AttributeFlowRules.Any(afr => afr.TargetMetaverseAttribute != null &&
                                        afr.TargetMetaverseAttribute.Id == q.Id)))
                            {
                                <MudSelectItem Disabled="IsAttributeFlowTargetDisabled(metaverseAttribute)" Value="@metaverseAttribute">
                                    @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                        @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                    else if (_syncRule.Direction == SyncRuleDirection.Export)
                    {
                        <MudSelect T="ConnectedSystemObjectTypeAttribute"
                            @bind-Value="_attributeFlowMapping.TargetConnectedSystemAttribute" Label="Connected System Attribute"
                            Placeholder="Please select the target Connected System attribute" Required="true" Class="mt-5"
                            Variant="Variant.Outlined">
                            @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType!.Attributes)
                            {
                                <MudSelectItem Disabled="IsAttributeFlowTargetDisabled(connectedSystemAttribute)"
                                    Value="@connectedSystemAttribute">
                                    @connectedSystemAttribute.Name <span
                                        style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type :
                                        @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                }
            }
        </DialogContent>
        <DialogActions>
            <MudButton DropShadow="false" Variant="Variant.Filled" Color="Color.Default"
                OnClick="@(() => _addAttributeFlowRuleDialogVisible = false)" Class="me-2">Cancel</MudButton>
            <MudButton Disabled="DisableAddAttributeFlowMappingButton()" DropShadow="false" Variant="Variant.Filled"
                Color="Color.Primary" OnClick="HandleAddAttributeFlowMappingButtonClick">Add Attribute Flow</MudButton>
        </DialogActions>
    </MudDialog>

    @if (!_attributeFlowTableView)
    {
    <MudStack Row="true" Wrap="Wrap.Wrap" Spacing="3" Class="mt-5">
        @foreach (var attributeFlowRule in _syncRule.AttributeFlowRules)
        {
            <MudPaper Class="pa-3" Elevation="0" Outlined="true" Style="min-width: 200px;">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start">
                    <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span>
                        @attributeFlowRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                    <MudIconButton Icon="@Icons.Material.Outlined.Delete" Variant="Variant.Filled" Color="Color.Error"
                        Size="Size.Small" Style="flex-shrink: 0;" aria-label="delete"
                        OnClick="@(() => HandleAttributeFlowRuleDeleteClick(attributeFlowRule))">
                    </MudIconButton>
                </MudStack>

                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <div class="d-flex align-center flex-wrap">
                        <MudChip T="string">
                            <AvatarContent>
                                <MudTooltip Text="Metaverse Attribute" Arrow="true" Placement="Placement.Top">
                                    <MudAvatar Color="Color.Primary">MV</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@attributeFlowRule.TargetMetaverseAttribute?.Name</ChildContent>
                        </MudChip>

                        <MudText Class="mud-text-secondary mx-1">→</MudText>

                        @foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                        {
                            if (source.ConnectedSystemAttribute != null)
                            {
                                <MudChip T="string">
                                    <AvatarContent>
                                        <MudTooltip Text="Connected System Attribute" Arrow="true" Placement="Placement.Top">
                                            <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                                        </MudTooltip>
                                    </AvatarContent>
                                    <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                                </MudChip>
                            }
                            else if (!string.IsNullOrWhiteSpace(source.Expression))
                            {
                                <MudChip T="string">
                                    <AvatarContent>
                                        <MudTooltip Text="Expression" Arrow="true" Placement="Placement.Top">
                                            <MudAvatar Color="Color.Secondary">Ex</MudAvatar>
                                        </MudTooltip>
                                    </AvatarContent>
                                    <ChildContent><span class="jim-expr-syntax">@((MarkupString)Helpers.HighlightExpression(source.Expression!))</span></ChildContent>
                                </MudChip>
                            }

                            <!-- some thought needs to be given to how we handle specifying constant values -->
                        }
                    </div>
                }
                else if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    <div class="d-flex align-center flex-wrap">
                        @foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                        {
                            if (source.MetaverseAttribute != null)
                            {
                                <MudChip T="string">
                                    <AvatarContent>
                                        <MudTooltip Text="Metaverse Attribute" Arrow="true" Placement="Placement.Top">
                                            <MudAvatar Color="Color.Primary">MV</MudAvatar>
                                        </MudTooltip>
                                    </AvatarContent>
                                    <ChildContent>@source.MetaverseAttribute.Name</ChildContent>
                                </MudChip>
                            }
                            else if (!string.IsNullOrWhiteSpace(source.Expression))
                            {
                                <MudChip T="string">
                                    <AvatarContent>
                                        <MudTooltip Text="Expression" Arrow="true" Placement="Placement.Top">
                                            <MudAvatar Color="Color.Secondary">Ex</MudAvatar>
                                        </MudTooltip>
                                    </AvatarContent>
                                    <ChildContent><span class="jim-expr-syntax">@((MarkupString)Helpers.HighlightExpression(source.Expression!))</span></ChildContent>
                                </MudChip>
                            }

                            <!-- some thought needs to be given to how we handle specifying constant values -->
                        }

                        <MudText Class="mud-text-secondary mx-1">→</MudText>

                        <MudChip T="string">
                            <AvatarContent>
                                <MudTooltip Text="Connected System Attribute" Arrow="true" Placement="Placement.Top">
                                    <MudAvatar Color="Color.Tertiary">CS</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@attributeFlowRule.TargetConnectedSystemAttribute?.Name</ChildContent>
                        </MudChip>
                    </div>
                }
            </MudPaper>
        }
    </MudStack>
    }

    @if (_syncRule.Validate().Count > 0)
    {
        <MudAlert Severity="Severity.Normal" Variant="Variant.Outlined" Class="mt-5">
            <MudText Class="mb-3">There are issues:</MudText>
            @foreach (var item in _syncRule.Validate())
            {
                <div class="d-flex align-center mb-2">
                    <MudIcon Class="mr-2" Color="@(item.Level == ValidityStatusItemLevel.Warning ? Color.Warning : Color.Error)"
                        Icon="@(item.Level == ValidityStatusItemLevel.Warning ? @Icons.Material.Filled.Warning : @Icons.Material.Filled.Error)" />
                    <MudText>@item.Message</MudText>
                </div>
            }
        </MudAlert>
    }

            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-5" OnClick="HandleCreateOrUpdateSyncRuleAsync"
                Disabled="!_syncRule.IsValid()" DropShadow="false">@(_syncRule.Id == 0 ? "Create" : "Update") Sync Rule
            </MudButton>
        </MudTabPanel>

        @if (_syncRule.Id > 0)
        {
            <MudTabPanel Text="Danger Zone" Icon="@Icons.Material.Filled.Warning" BadgeColor="Color.Error" ID="@("danger-zone")">
                <MudPaper Class="pa-4 jim-paper-danger-zone" Outlined="false">
                    <MudText Typo="Typo.h5" Class="mb-3">Danger Zone</MudText>
                    <MudText Class="mud-text-secondary mb-4">
                        Deleting this synchronisation rule is permanent and cannot be undone. All configuration and attribute flow
                        mappings will be lost.
                    </MudText>
                    <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Delete" OnClick="HandleDeleteSyncRuleAsync"
                        DropShadow="false" Color="Color.Error">Delete Sync Rule</MudButton>
                </MudPaper>
            </MudTabPanel>
        }
    </MudTabs>
}

@code {
    [Parameter]
    public int? Id { get; set; }

    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private string _syncRuleNameOrCreate = "New";
    private List<BreadcrumbItem> _breadcrumbs = null!;
    private SyncRule? _syncRule;
    private bool _isLoading = true;
    private bool _isDetailsFormValid;
    private string[] _detailsFormErrors = { };
    private List<ConnectedSystemHeader>? _connectedSystemHeaders;
    private List<MetaverseObjectType>? _metaverseObjectTypes;

    private bool _addMatchingRuleDialogVisible;
    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private ObjectMatchingRule? _matchingRuleMapping;
    private ObjectMatchingRuleSource? _matchingRuleMappingSource;
    private string? _matchingRuleMappingSourceType;

    private bool _syncRuleScopingFiltered;
    private bool _addScopingCriteriaGroupDialogVisible;
    private string? _criteriaGroupTypeText;
    private SyncRuleScopingCriteriaGroup? _syncRuleScopingCriteriaGroup;

    private bool _addAttributeFlowRuleDialogVisible;
    private SyncRuleMapping? _attributeFlowMapping;
    private SyncRuleMappingSource? _attributeFlowMappingSource;
    private string? _attributeFlowMappingSourceType;
    private bool _attributeFlowTableView = true;

    protected override async Task OnInitializedAsync()
    {
        _breadcrumbs =
        [
        new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
new BreadcrumbItem("Synchronisation Rules", href: "/admin/sync-rules/")
        ];

        if (Id != null)
        {
            // edit an existing sync rule
            _syncRule = await Jim.ConnectedSystems.GetSyncRuleAsync(Id.Value);
            if (_syncRule == null)
            {
                // sync rule not found, redirect to index page
                _isLoading = false;
                NavManager.NavigateTo("../");
                return;
            }

            _syncRuleNameOrCreate = _syncRule.Name;
            _breadcrumbs.Add(new BreadcrumbItem(_syncRule.Name, href: null, disabled: true));

            // initialise scoping filter state based on existing criteria
            _syncRuleScopingFiltered = _syncRule.ObjectScopingCriteriaGroups.Count > 0;
        }
        else
        {
            // create a new sync rule
            _syncRule = new SyncRule();
            _breadcrumbs.Add(new BreadcrumbItem("New", href: null, disabled: true));
            _connectedSystemHeaders = await Jim.ConnectedSystems.GetConnectedSystemHeadersAsync();
            _metaverseObjectTypes = await Jim.Metaverse.GetMetaverseObjectTypesAsync(true);
        }

        var storedView = await JS.InvokeAsync<string?>("localStorage.getItem", "attributeFlowView");
        _attributeFlowTableView = storedView != "cards";

        _isLoading = false;
    }

    private async Task ToggleAttributeFlowViewAsync(bool tableView)
    {
        _attributeFlowTableView = tableView;
        await JS.InvokeVoidAsync("localStorage.setItem", "attributeFlowView", tableView ? "table" : "cards");
    }

    private async Task HandleConnectedSystemSelectedAsync(string connectedSystemId)
    {
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;

        // convert to int and assign to SR
        var connectedSystemIdInt = int.Parse(connectedSystemId);
        var connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(connectedSystemIdInt);
        if (connectedSystem == null)
            return;

        _syncRule.ConnectedSystem = connectedSystem;
        Console.WriteLine($"HandleConnectedSystemSelectedAsync: Assigned ConnectedSystem: {_syncRule.ConnectedSystem}");
    }

    private void HandleSyncRuleDirectionSelection(string syncRuleDirection)
    {
        // convert to enum and assign to sr
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;

        var syncRuleDirectionEnum = (SyncRuleDirection)Enum.Parse(typeof(SyncRuleDirection), syncRuleDirection);
        _syncRule.Direction = syncRuleDirectionEnum;
        Console.WriteLine($"HandleSyncRuleDirectionSelection: Assigned SyncRuleDirection: {_syncRule.Direction}");

        // reset provision/project choices
        _syncRule.ProvisionToConnectedSystem = false;
        _syncRule.ProjectToMetaverse = false;
    }

    private void HandleOpenAddMatchingRuleMappingDialog()
    {
        if (_syncRule == null)
            return;

        if (_matchingRuleMapping == null)
        {
            _matchingRuleMapping = new ObjectMatchingRule
            {
                Order = _syncRule.ObjectMatchingRules.Count == 0 ? 0 : _syncRule.ObjectMatchingRules.Select(q => q.Order).Max() + 1
            };
            _matchingRuleMappingSource = new ObjectMatchingRuleSource();
        }
        else
        {
            if (_matchingRuleMappingSource == null)
                return;
        }

        _matchingRuleMapping.Sources.Add(_matchingRuleMappingSource);
        _addMatchingRuleDialogVisible = true;
    }

    private void HandleAddMatchingRuleMappingTypeValueChange(string mappingType)
    {
        _matchingRuleMappingSource ??= new ObjectMatchingRuleSource();
        _matchingRuleMappingSourceType = mappingType;
    }

    private bool DisableAddMappingButton()
    {
        if (_matchingRuleMapping == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping NULL");
            return true;
        }

        if (_matchingRuleMappingSource == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMappingSource NULL");
            return true;
        }

        if (_matchingRuleMapping.TargetMetaverseAttribute == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.TargetMetaverseAttribute NULL");
            return true;
        }

        // the rest depends on what type of source has been chosen by the user
        // Must have either a connected system attribute or an expression
        if (_matchingRuleMappingSource.ConnectedSystemAttribute == null &&
        string.IsNullOrWhiteSpace(_matchingRuleMappingSource.Expression))
        {
            Console.WriteLine("DisableAddMappingButton: attrib/expression missing");
            return true;
        }

        return false;
    }

    private void HandleAddMappingButtonClick()
    {
        if (_syncRule == null || _matchingRuleMapping == null)
            return;

        // add the mapping to the rule
        _syncRule.ObjectMatchingRules.Add(_matchingRuleMapping);

        // close the add mapping dialog
        _addMatchingRuleDialogVisible = false;

        // re-initialise the mapping rule and source, ready for the next use
        _matchingRuleMapping = null;
        _matchingRuleMappingSource = null;
    }

    private async Task HandleObjectMatchingRuleDeleteClickAsync(ObjectMatchingRule objectMatchingRule)
    {
        if (_syncRule == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to remove this Matching Rule?", yesText: "Remove!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            _syncRule.ObjectMatchingRules.Remove(objectMatchingRule);

            // re-order the items
            var orderedItems = _syncRule.ObjectMatchingRules.OrderBy(q => q.Order).ToList();
            for (var i = 0; i < orderedItems.Count; i++)
                orderedItems[i].Order = i;
        }
    }

    private void HandleToggleMatchingRuleCaseSensitive(ObjectMatchingRule rule, bool caseSensitive)
    {
        if (_syncRule == null)
            return;

        // Update the local value - changes will be saved when user saves the sync rule
        rule.CaseSensitive = caseSensitive;
        Snackbar.Add($"Matching rule is now {(caseSensitive ? "case-sensitive" : "case-insensitive")}. Remember to save the sync rule.", Severity.Info);
        StateHasChanged();
    }

    private void HandleObjectMatchingRuleChangeOrder(ObjectMatchingRule objectMatchingRule, string direction)
    {
        // invalid scenarios
        if (_syncRule == null || _syncRule.ObjectMatchingRules.Count == 1)
            return;

        if (direction == "up")
        {
            // cannot promote the first item
            if (objectMatchingRule.Order == 0)
                return;

            var precedingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order - 1));
            precedingItem.Order++;
            objectMatchingRule.Order--;
        }
        else
        {
            // cannot demote the last item
            if (objectMatchingRule.Order == (_syncRule.ObjectMatchingRules.Count - 1))
                return;

            var followingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order + 1));
            followingItem.Order--;
            objectMatchingRule.Order++;
        }
    }

    private bool DisableObjectMatchingMappingRuleOrderButton(ObjectMatchingRule objectMatchingRule, string direction)
    {
        if (_syncRule == null)
            return true;

        switch (direction)
        {
            case "up" when objectMatchingRule.Order == 0:
            case "down" when objectMatchingRule.Order == _syncRule.ObjectMatchingRules.Max(q => q.Order):
                return true;
            default:
                return false;
        }
    }

    private void HandleOpenAddScopingCriteriaGroupDialog()
    {
        Console.WriteLine("HandleOpenAddScopingCriteriaGroupDialog: Called");
        _syncRuleScopingCriteriaGroup = new SyncRuleScopingCriteriaGroup();
        _addScopingCriteriaGroupDialogVisible = true;
    }

    private bool DisableAddScopingCriteriaGroupFormButton()
    {
        Console.WriteLine($"DisableAddScopingCriteriaGroupFormButton: '{_criteriaGroupTypeText}'");
        return string.IsNullOrEmpty(_criteriaGroupTypeText);
    }

    private void HandleAddCriteriaGroupButtonClick()
    {
        if (_syncRule == null || _syncRuleScopingCriteriaGroup == null || _criteriaGroupTypeText == null)
            return;

        _syncRuleScopingCriteriaGroup.Type = (SearchGroupType)Enum.Parse(typeof(SearchGroupType), _criteriaGroupTypeText);

        if (_syncRuleScopingCriteriaGroup.ParentGroup == null)
        {
            // root-level criteria group
            _syncRule.ObjectScopingCriteriaGroups.Add(_syncRuleScopingCriteriaGroup);
        }
        else
        {
            // add the criteria group to the parent's children, i.e. make sure the relationship is established on both the parent
            // and the new criteria group
            _syncRuleScopingCriteriaGroup.ParentGroup.ChildGroups.Add(_syncRuleScopingCriteriaGroup);
        }

        // all done, reset
        _addScopingCriteriaGroupDialogVisible = false;
        _syncRuleScopingCriteriaGroup = null;
    }

    private void HandleStateHasChanged()
    {
        // yes, this is necessary.
        StateHasChanged();
    }

    private async Task HandleCreateOrUpdateSyncRuleAsync()
    {
        if (_syncRule == null)
            return;

        // are we transitioning from new to existing?
        var isSyncRuleNew = _syncRule.Id == 0;

        // attribute the operation to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        var wasSuccessful = await Jim.ConnectedSystems.CreateOrUpdateSyncRuleAsync(_syncRule, user);
        switch (wasSuccessful)
        {
            // send the user to the existing-sync-rule view.
            // this helps ensure links are good to be shared/bookmarked, etc.
            case true when isSyncRuleNew:
                NavManager.NavigateTo($"/admin/sync-rules/{_syncRule.Id}");
                break;
            case true:
                Snackbar.Add("Changes saved.", Severity.Success);
                break;
            case false:
                Snackbar.Add("There was a problem saving your changes. Please check the details and try again.", Severity.Error);
                break;
        }
    }

    private bool DisableAddAttributeFlowButton()
    {
        if (_syncRule?.MetaverseObjectType == null)
            return true;

        if (_syncRule?.ConnectedSystemObjectType == null)
            return true;

        return false;
    }

    private void HandleOpenAddAttributeFlowRuleDialog()
    {
        if (_syncRule == null)
            return;

        _attributeFlowMapping = new SyncRuleMapping();
        _attributeFlowMappingSource = new SyncRuleMappingSource();
        _attributeFlowMapping.Sources.Add(_attributeFlowMappingSource);
        _addAttributeFlowRuleDialogVisible = true;
    }

    private bool DisableAddAttributeFlowMappingButton()
    {
        if (_attributeFlowMapping == null)
            return true;

        if (_attributeFlowMappingSource == null)
            return true;

        if (_attributeFlowMappingSourceType == null)
            return true;

        return false;
    }

    // import rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(MetaverseAttribute targetMetaverseAttribute)
    {
        if (_attributeFlowMappingSource?.ConnectedSystemAttribute == null)
            return true;

        if (targetMetaverseAttribute.Type != _attributeFlowMappingSource.ConnectedSystemAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetMetaverseAttribute.AttributePlurality == AttributePlurality.SingleValued &&
        _attributeFlowMappingSource.ConnectedSystemAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;

        return false;
    }

    // export rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(ConnectedSystemObjectTypeAttribute targetConnectedSystemObjectTypeAttribute)
    {
        if (_attributeFlowMappingSource?.MetaverseAttribute == null)
            return true;

        // read-only attributes cannot be targeted by export attribute flows
        if (targetConnectedSystemObjectTypeAttribute.Writability == AttributeWritability.ReadOnly)
            return true;

        if (targetConnectedSystemObjectTypeAttribute.Type != _attributeFlowMappingSource.MetaverseAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetConnectedSystemObjectTypeAttribute.AttributePlurality == AttributePlurality.SingleValued &&
        _attributeFlowMappingSource.MetaverseAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;

        return false;
    }

    private void HandleAddAttributeFlowMappingButtonClick()
    {
        if (_syncRule == null || _attributeFlowMapping == null)
            return;

        // add the mapping to the rule
        _syncRule.AttributeFlowRules.Add(_attributeFlowMapping);

        // close the add attribute flow dialog
        _addAttributeFlowRuleDialogVisible = false;

        // re-initialise the attribute flow rule and source, ready for the next use
        _attributeFlowMapping = null;
        _attributeFlowMappingSource = null;
    }

    private void HandleAttributeFlowRuleDeleteClick(SyncRuleMapping attributeFlowRule)
    {
        _syncRule?.AttributeFlowRules.Remove(attributeFlowRule);
    }

    private async Task HandleDeleteSyncRuleAsync()
    {
        if (_syncRule == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to delete this Synchronisation Rule?", yesText: "Delete!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            // attribute the operation to the signed-in user
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
            await Jim.ConnectedSystems.DeleteSyncRuleAsync(_syncRule, user);
            NavManager.NavigateTo("/admin/sync-rules");
        }
    }
}
