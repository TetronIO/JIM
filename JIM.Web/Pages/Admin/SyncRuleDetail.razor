@page "/admin/connected-systems/sync-rules/new"
@page "/admin/connected-systems/sync-rules/{Id:int}"
@attribute [Authorize(Roles = "Administrators")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Logic
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Utilities
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject IDialogService DialogService

<PageTitle>Synchronisation Rule: @syncRuleNameOrCreate</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Synchronisation Rule:</span> @syncRuleNameOrCreate</MudText>
<MudBreadcrumbs Items="breadcrumbs" Class="ps-0"></MudBreadcrumbs>

@if (syncRule != null)
{
    <MudPaper Class="pa-4 mt-5" Outlined="true">
        <MudForm @bind-IsValid="@isDetailsFormValid" @bind-Errors="@detailsFormErrors">
            <MudTextField Label="Name" Required="true" RequiredError="A name is required" @bind-Value="syncRule.Name" Variant="Variant.Outlined" />

            @if (syncRule.Id == 0)
            {
                @if (connectedSystemHeaders != null)
                {
                    <MudSelect 
                        T="string"
                        Label="Connected System"
                        Placeholder="Please select a Connected System..."
                        Required="true"
                        ValueChanged="HandleConnectedSystemSelectedAsync"
                        AdornmentIcon="@Icons.Material.Filled.Power"
                        Adornment="Adornment.Start"
                        Variant="Variant.Outlined"
                        Class="mt-5">
                        @foreach (var header in connectedSystemHeaders)
                        {
                            <MudSelectItem Value="@header.Id.ToString()">@header.Name</MudSelectItem>
                        }
                    </MudSelect>
                }

                <MudSelect T="string"
                           Label="Direction"
                           Placeholder="Please select an attribute flow direction..."
                           Required="true"
                           ValueChanged="HandleSyncRuleDirectionSelection"
                           Variant="Variant.Outlined"
                           Class="mt-5">
                    @foreach (SyncRuleDirection item in Enum.GetValues(typeof(SyncRuleDirection)))
                    {
                        if (item != SyncRuleDirection.NotSet)
                        {
                            <MudSelectItem Value="@item.ToString()">@item</MudSelectItem>
                        }
                    }
                </MudSelect>

                @if (syncRule.ConnectedSystem != null && syncRule.Direction != SyncRuleDirection.NotSet && metaverseObjectTypes != null && syncRule.ConnectedSystem != null && syncRule.ConnectedSystem.ObjectTypes != null)
                {
                    <MudGrid>
                        <MudItem xs="5">
                            <MudSelect T="MetaverseObjectType"
                                       Label="Metaverse Object Type"
                                       @bind-Value="@syncRule.MetaverseObjectType"
                                       Required="true"
                                       Class="mt-5"
                                       Variant="Variant.Outlined">
                                @foreach (var mvObjectType in metaverseObjectTypes)
                                {
                                    <MudSelectItem Value="@mvObjectType">@mvObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="2">
                            <MudPaper Outlined="false" Elevation="0" Class="d-flex flex-column align-center justify-center mud-width-full py-10">
                                <MudIcon Size="Size.Medium" Icon="@(syncRule.Direction == SyncRuleDirection.Export ? Icons.Material.Filled.KeyboardDoubleArrowRight : Icons.Material.Filled.KeyboardDoubleArrowLeft)"></MudIcon>
                            </MudPaper>
                        </MudItem>
                        <MudItem xs="5">
                            <MudSelect T="ConnectedSystemObjectType"
                                       Label="Connected System Object Type"
                                       @bind-Value="@syncRule.ConnectedSystemObjectType"
                                       Required="true"
                                       Class="mt-5"
                                       Variant="Variant.Outlined">
                                @foreach (var csObjectType in syncRule.ConnectedSystem.ObjectTypes.Where(ot => ot.Selected))
                                {
                                    <MudSelectItem Value="@csObjectType">@csObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                    </MudGrid>
                }

                @if (syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudSwitch @bind-Value="@syncRule.ProjectToMetaverse" Color="Color.Primary" Label="Create imported objects in the Metaverse?" />
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, objects imported from this Connected System matched in this synchronisation rule will not result in a Metaverse object being created. Enabling this option causes the object to be projected to the Metaverse, allowing it to be managed within JIM and synchronised to other Connected Systems. You would typically enable this for a source system, i.e. a HR system.</MudAlert>
                }
                @if (syncRule.Direction == SyncRuleDirection.Export)
                {
                    <MudSwitch @bind-Value="@syncRule.ProvisionToConnectedSystem" Color="Color.Primary" Label="Create objects in the Connected System?" />
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, Metaverse objects matched in this synchronisation rule will not be created (provisioned) in the Connected Systems. Enabling this option will cause the Metaverse object to be created (provisioned) in the Connected System. You would typically enable this option for a destination system, i.e. when trying to implement a HR to Active Directory flow.</MudAlert>
                }

                <MudSwitch Class="mt-5" @bind-Value="@syncRule.Enabled" Color="Color.Primary" Label="Enabled?" />
                <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">Synchronisation Rules will not be evaluated when disabled, enabling you to either prepare a rule in advance of it being needed, or to temporarily stop evaluating a sync rule..</MudAlert>
            }
        </MudForm>
    </MudPaper>

    @if (syncRule.Direction == SyncRuleDirection.Import)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <MudText Typo="Typo.h4">Matching Rules</MudText>
            <MudText Class="mt-5">
                At lest one matching rule is needed to ensure JIM can associate a Connected System Object from this sync rule with a matching Metaverse object.
                It's strongly recommended that you choose an immutable attribute on both sides, i.e. one that won't change for the life of the object.
                You can define multiple rules, and order them. The first to match will be used. Common examples might include: employeeID = employeeID, or ActiveDirectoryObjectGuid = objectGUID.
                A Connected System Object is considered Joined when a matching Metaverse object is found, and Disconnected when not.
            </MudText>

            <MudButton StartIcon="@Icons.Material.Filled.Add"
                       Variant="Variant.Filled"
                       OnClick="HandleOpenAddMappingDialog"
                       Color="Color.Default"
                       Class="mt-5"
                       Disabled="@(syncRule.MetaverseObjectType == null || syncRule.ConnectedSystemObjectType == null)"
                       DisableElevation="true">Add Matching Rule</MudButton>

        </MudPaper>

        <MudDialog @bind-IsVisible="addMatchingRuleDialogVisible" Options="addMatchingRuleDialogOptions">
            <TitleContent>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Matching Rule
                </MudText>
            </TitleContent>
            <DialogContent>

                <MudSelect 
                    T="string"
                    Label="Source Type"
                    Placeholder="Please the type of source for this matching rule"
                    Required="true"
                    ValueChanged="HandleAddMappingTypeValueChange"
                    Variant="Variant.Outlined">
                    <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                    <MudSelectItem Value="@("Function")">Function</MudSelectItem>
                    <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
                </MudSelect>

                @if (syncRuleMapping != null && syncRuleMappingSource != null)
                {
                    @if (syncRuleMappingSourceType == "Attribute")
                    {
                        <MudSelect T="MetaverseAttribute"
                                   @bind-Value="syncRuleMapping.TargetMetaverseAttribute"
                                   Label="Metaverse Attribute"
                                   Placeholder="Please select a Metaverse attribute"
                                   Required="true"
                                   Class="mt-5"
                                   Variant="Variant.Outlined">
                            @foreach (var metaverseAttribute in syncRule.MetaverseObjectType.Attributes.Where(a => a.AttributePlurality == AttributePlurality.SingleValued))
                            {
                                <MudSelectItem Value="@metaverseAttribute">@(metaverseAttribute.Name)</MudSelectItem>
                            }
                        </MudSelect>

                        if (syncRuleMapping.TargetMetaverseAttribute != null)
                        {
                            var selectableConnectedSystemAttributes = syncRule.ConnectedSystemObjectType.Attributes.Where(a => a.AttributePlurality == AttributePlurality.SingleValued && a.Type == syncRuleMapping.TargetMetaverseAttribute.Type).ToList();
                            if (selectableConnectedSystemAttributes.Count > 0)
                            {
                                <MudSelect T="ConnectedSystemObjectTypeAttribute"
                                           @bind-Value="syncRuleMappingSource.ConnectedSystemAttribute"
                                           Label="Connected System Attribute"
                                           Placeholder="Please select the Connected System attribute"
                                           Required="true"
                                           Class="mt-5"
                                           Variant="Variant.Outlined">
                                    @foreach (var connectedSystemObjectTypeAttribute in selectableConnectedSystemAttributes)
                                    {
                                        <MudSelectItem Value="@connectedSystemObjectTypeAttribute">@(connectedSystemObjectTypeAttribute.Name)</MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            else
                            {
                                <MudAlert class="mt-5" Severity="Severity.Error">There are no attributes of type @syncRuleMapping.TargetMetaverseAttribute.Type on the Connected System type @syncRule.ConnectedSystemObjectType.Name to use for mapping. Select another type of attribute.</MudAlert>
                            }
                        }
                    }
                    else if (syncRuleMappingSourceType == "Function")
                    {
                        <MudText Class="mt-5">Sorry, functions are no yet supported.</MudText>
                    }
                    else if (syncRuleMappingSourceType == "Expression")
                    {
                        <MudText Class="mt-5">Sorry, expressions are no yet supported.</MudText>
                    }
                }
            </DialogContent>
            <DialogActions>
                <MudButton Disabled="DisableAddMappingButton()" Variant="Variant.Filled" Color="Color.Primary" OnClick="HandleAddMappingButtonClick" Class="ma-4">Add Matching Rule</MudButton>
            </DialogActions>
        </MudDialog>

        @foreach (var objectMatchingRule in syncRule.ObjectMatchingRules.OrderBy(omr => omr.Order))
        {
            var sourceType = objectMatchingRule.GetSourceType();
            <MudPaper Class="pa-4 mt-5" Outlined="true">

                @if (sourceType == SyncRuleMappingSourcesType.AttributeMapping)
                {
                    <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span> @objectMatchingRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                    <div>
                        <MudChip>
                            <AvatarContent>
                                <MudTooltip Text="Metaverse Attribute">
                                    <MudAvatar>MV</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@objectMatchingRule.TargetMetaverseAttribute.Name</ChildContent>
                        </MudChip>
                        <MudChip><MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.KeyboardDoubleArrowLeft"></MudIcon></MudChip>
                        <MudChip>
                            <AvatarContent>
                                <MudTooltip Text="Connected System Attribute">
                                    <MudAvatar>CS</MudAvatar>
                                </MudTooltip>
                            </AvatarContent>
                            <ChildContent>@objectMatchingRule.Sources[0].ConnectedSystemAttribute.Name</ChildContent>
                        </MudChip>
                    </div>
                }

            </MudPaper>
        }
    }
}

@code {
    [Parameter]
    public int? Id { get; set; }

    private string syncRuleNameOrCreate = "New";
    private List<BreadcrumbItem> breadcrumbs = null!;
    private SyncRule? syncRule;
    private bool isDetailsFormValid;
    private string[] detailsFormErrors = { };
    private List<ConnectedSystemHeader> connectedSystemHeaders = null!;
    private List<MetaverseObjectType> metaverseObjectTypes = null!;
    private List<ConnectedSystemObjectType> connectedSystemObjectTypes = null!;

    private bool addMatchingRuleDialogVisible;
    private DialogOptions addMatchingRuleDialogOptions = new() { FullWidth = true };
    private SyncRuleMapping? syncRuleMapping;
    private SyncRuleMappingSource? syncRuleMappingSource;
    private string? syncRuleMappingSourceType;

    protected override async Task OnInitializedAsync()
    {
        breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
            new BreadcrumbItem("Synchronisation Rules", href: "/admin/connected-systems/sync-rules/")
        };

        if (Id != null)
        {
            // edit an existing sync rule
            syncRule = await Jim.ConnectedSystems.GetSyncRuleAsync(Id.Value);
            if (syncRule == null)
            {
                // sync rule not found, redirect to index page
                NavManager.NavigateTo("../");
                return;
            }

            breadcrumbs.Add(new BreadcrumbItem(syncRule.Name, href: null, disabled: true));
        }
        else
        {
            // create a new sync rule
            syncRule = new SyncRule();
            breadcrumbs.Add(new BreadcrumbItem("New", href: null, disabled: true));
            connectedSystemHeaders = await Jim.ConnectedSystems.GetConnectedSystemHeadersAsync();
            metaverseObjectTypes = await Jim.Metaverse.GetMetaverseObjectTypesAsync(true);
        }
    }

    private async Task HandleConnectedSystemSelectedAsync(string connectedSystemId)
    {
        // should never happen, but performing for linting reasons
        if (syncRule == null)
            return;

        // convert to int and assign to SR
        int connectedSystemIdInt = int.Parse(connectedSystemId);
        var connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(connectedSystemIdInt);
        if (connectedSystem == null)
            return;

        syncRule.ConnectedSystem = connectedSystem;
        Console.WriteLine($"HandleConnectedSystemSelectedAsync: Assigned ConnectedSystem: {syncRule.ConnectedSystem}");
    }

    private void HandleSyncRuleDirectionSelection(string syncRuleDirection)
    {
        // convert to enum and assign to sr
        // should never happen, but performing for linting reasons
        if (syncRule == null)
            return;

        var syncRuleDirectionEnum = (SyncRuleDirection)Enum.Parse(typeof(SyncRuleDirection), syncRuleDirection);
        syncRule.Direction = syncRuleDirectionEnum;
        Console.WriteLine($"HandleSyncRuleDirectionSelection: Assigned SyncRuleDirection: {syncRule.Direction}");

        // reset provision/project choices
        syncRule.ProvisionToConnectedSystem = false;
        syncRule.ProjectToMetaverse = false;
    }

    private void HandleOpenAddMappingDialog()
    {
        if (syncRule == null)
            return;

        if (syncRuleMapping == null)
        {
            syncRuleMapping = new SyncRuleMapping {
                    Type = SyncRuleMappingType.ObjectMatching,
                    Order = syncRule.ObjectMatchingRules.Count == 0 ? 0 : syncRule.ObjectMatchingRules.Select(q => q.Order).Max() + 1
            };
            syncRuleMappingSource = new SyncRuleMappingSource();
        }

        syncRuleMapping.Sources.Add(syncRuleMappingSource);
        addMatchingRuleDialogVisible = true;
    }

    private void HandleAddMappingTypeValueChange(string mappingType)
    {
        if (syncRuleMappingSource == null)
            syncRuleMappingSource = new SyncRuleMappingSource();

        syncRuleMappingSourceType = mappingType;
    }

    private bool DisableAddMappingButton()
    {
        if (syncRuleMapping == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping NULL");
            return true;
        }

        if (syncRuleMappingSource == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMappingSource NULL");
            return true;
        }

        if (syncRuleMapping.TargetMetaverseAttribute == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.TargetMetaverseAttribute NULL");
            return true;
        }

        if (syncRuleMapping.Type != SyncRuleMappingType.ObjectMatching)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.Type != SyncRuleMappingType.ObjectMatching");
            return true;
        }

        // the rest depends on what type of source has been chosen by the user
        if (syncRuleMappingSource.ConnectedSystemAttribute == null && (syncRuleMappingSource.Function == null || (syncRuleMappingSource.Function != null && (syncRuleMappingSource.ParameterValues == null || syncRuleMappingSource.ParameterValues.Count == 0))))
        {
            Console.WriteLine("DisableAddMappingButton: attrib/function/params missing");
            return true;
        }

        return false;
    }

    private void HandleAddMappingButtonClick()
    {
        if (syncRule == null || syncRuleMapping == null)
            return;

        // add the mapping to the rule
        syncRule.ObjectMatchingRules.Add(syncRuleMapping);

        // close the add mapping dialog
        addMatchingRuleDialogVisible = false;

        // re-initialise the mapping rule and source, ready for the next use
        syncRuleMapping = null;
        syncRuleMappingSource = null;
    }
}