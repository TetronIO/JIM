@page "/admin/connected-systems/{Id:int}"
@attribute [Authorize(Roles = "Administrators")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Utilities
@using Serilog
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<PageTitle>Connected System: @_connectedSystem?.Name</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Connected System:</span> @_connectedSystem?.Name</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>
<MudText Typo="Typo.subtitle1" Class="mud-text-secondary">Some aspects of a Connected System can only be configured once basic details and setting values have been provided.</MudText>

@if (_connectedSystem != null)
{
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="false" PanelClass="pt-5" Class="mt-5" Outlined="true">

        <MudTabPanel Text="Details">
            <MudPaper Class="pa-4" Outlined="true">
                <MudForm @bind-IsValid="@IsDetailsFormValid" @bind-Errors="@DetailsFormErrors">
                    <MudTextField T="string" Label="Connector" @bind-Value="_connectedSystem.ConnectorDefinition.Name" Disabled="true" Variant="Variant.Outlined" />
                    <MudTextField T="string" Label="Name" @bind-Value="_connectedSystem.Name" Required="true" RequiredError="A name is required" Variant="Variant.Outlined" Class="mt-5" />
                    <MudTextField T="string" Label="Description" Required="false" @bind-Value="_connectedSystem.Description" Lines="5" Variant="Variant.Outlined" Class="mt-5" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsDetailsFormValid)" Class="mt-5" OnClick="HandleValidDetailsSubmitAsync" DropShadow="false">Save Changes</MudButton>
                </MudForm>
            </MudPaper>
        </MudTabPanel>

        <MudTabPanel Text="Settings">
            <MudText>Configure the connector for your environment by supplying values for the settings below.</MudText>
            <MudForm @bind-IsValid="@IsSettingsFormValid" @bind-Errors="@SettingsFormErrors" Class="mt-5">
                @if (_settingCategories != null)
                {
                    @for (var i = 0; i < _settingCategories.Count; i++)
                    {
                        var settingCategory = _settingCategories[i];
                        <MudText Typo="Typo.h5" Class="mt-5">@settingCategory.ToString()</MudText>
                        <MudPaper Class="pa-4 mt-5" Outlined="true">
                            @foreach (var settingValue in _connectedSystem.SettingValues
                                .Where(sv => sv.Setting.Category == settingCategory)
                                .OrderByDescending(sv => sv.Setting.Required)
                                .ThenBy(sv => sv.Setting.Id))
                            {
                                if (settingValue.Setting.Type == ConnectedSystemSettingType.Heading)
                                {
                                    <MudText Typo="Typo.h6" Class="mb-5">@settingValue.Setting.Name</MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Divider)
                                {
                                    <hr />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.String)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.StringEncrypted)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringEncryptedValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Password"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Integer)
                                {
                                    <MudTextField T="int?"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.IntValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Number"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.CheckBox)
                                {
                                    <div class="mb-5">
                                        <MudSwitch @bind-Value="settingValue.CheckboxValue" Color="Color.Primary" Label="@settingValue.Setting.Name" />
                                        @if (!string.IsNullOrEmpty(settingValue.Setting.Description))
                                        {
                                            <MudText Typo="Typo.caption" Class="mud-text-secondary ml-12">@settingValue.Setting.Description</MudText>
                                        }
                                    </div>
                                }
                                else if (settingValue.Setting is { Type: ConnectedSystemSettingType.DropDown, DropDownValues: not null })
                                {
                                    <MudSelect @bind-Value="settingValue.StringValue"
                                               HelperText="@settingValue.Setting.Description"
                                               Label="@settingValue.Setting.Name"
                                               Variant="Variant.Outlined"
                                               Class="mb-5"
                                               Required="@settingValue.Setting.Required"
                                               RequiredError="@($"A {settingValue.Setting.Name} is required")">
                                        @foreach (var dropDownValue in settingValue.Setting.DropDownValues)
                                        {
                                            <MudSelectItem T="string" Value="@dropDownValue">@dropDownValue</MudSelectItem>
                                        }
                                    </MudSelect>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Label)
                                {
                                    <MudText Class="mb-5">
                                        @settingValue.Setting.Description
                                    </MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.File)
                                {
                                    <MudText Class="mt-b">Files not yet supported for settings.</MudText>
                                }
                                else
                                {
                                    <MudText Class="mt-b">Oops. Unknown setting type!</MudText>
                                }
                            }
                        </MudPaper>
                    }
                }

                @if (SettingsFormCustomErrors.Count > 0)
                {
                    <MudAlert Severity="Severity.Error" Class="mt-5">
                        <MudText>There are issues with the settings:</MudText>
                        <ul class="mt-5">
                            @foreach (var error in SettingsFormCustomErrors)
                            {
                                <li>@error.Key: @error.Value</li>
                            }
                        </ul>
                    </MudAlert>
                }

                <MudButton Variant="Variant.Filled" Color="@(IsSettingsFormValid || !_settingsBeingSaved ? Color.Primary : Color.Default)" Disabled="@(!IsSettingsFormValid || _settingsBeingSaved)" Class="mt-5" DropShadow="false" OnClick="HandleValidSettingsSubmitAsync">
                    @if (_settingsBeingSaved)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Processing</MudText>
                    }
                    else
                    {
                        <MudText>Save Settings</MudText>
                    }
                </MudButton>
            </MudForm>
        </MudTabPanel>

        <MudTabPanel Text="Schema" Disabled="@AreSettingDependentTabsDisabled()">

            <MudAlert Severity="_connectedSystem.ObjectTypes is { Count: > 0 } ? Severity.Warning : Severity.Info">
                @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                {
                    <MudText>Retrieve the schema from the connected system, to be able to select which object types and attributes you want to manage with JIM.</MudText>
                }
                else
                {
                    <MudText>
                        <strong>Refreshing the schema can result in data-loss</strong>. If object types or attributes are discovered to have been removed at the connected system, then this 
                        will result in all references to them being removed from within JIM, i.e. synchronisation rules, attribute flow, attributes values and even entire objects will be 
                        deleted if object types are removed. Refresh with caution. Ensure the Connected System identity has the right permissions needed to retrieve the schema, and consider 
                        a database backup before proceeding.
                    </MudText>
                }
                <MudButton 
                    Color="_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0 ? Color.Info : Color.Warning"
                    Disabled="@(_schemaBeingRetrieved)"
                    Variant="Variant.Filled"
                    Size="Size.Small"
                    OnClick="HandleImportSchemaAsync"
                    Class="mt-5"
                    DropShadow="false">
                    @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Retrieving Schema</MudText>
                        }
                        else
                        {
                            <text>Retrieve Schema</text>
                        }
                    }
                    else
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Refreshing Schema</MudText>
                        }
                        else
                        {
                            <text>Refresh Schema</text>
                        }
                    }
                </MudButton>
            </MudAlert>

            <MudDialog @bind-Visible="_editSchemaAttributeDialogVisible" Options="_dialogOptions">
                <TitleContent>
                    <MudText Typo="Typo.h6">
                        <MudIcon Icon="@Icons.Material.Filled.Edit" Class="mr-3" /> Edit Schema Attribute: @_objectTypeAttributeBeingEdited?.Name
                    </MudText>
                </TitleContent>
                <DialogContent>
                    @if (!_objectTypeAttributeBeingEditedIsEditable)
                    {
                        <MudAlert Severity="Severity.Error">
                            This Connected System attribute cannot be edited as it is being referenced by either a synchronisation rule, or has values already populated.
                        </MudAlert>
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Info">
                            This Connector supports changing the data type of a Connected System attribute. This might be because the data type
                            was detected automatically, and might need adjusting if not right.
                        </MudAlert>
                    }
                    
                    <MudSelect
                        T="string"
                        Label="Please choose a data type"
                        Required="true"
                        Variant="Variant.Outlined"
                        Class="mt-5"
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable"
                        @bind-Value="_objectTypeAttributeBeingEditedText">
                        @foreach (AttributeDataType type in Enum.GetValues(typeof(AttributeDataType)))
                        {
                            if (type != AttributeDataType.NotSet)
                            {
                                <MudSelectItem Value="@type.ToString()"/>
                            }
                        }
                    </MudSelect>

                </DialogContent>
                <DialogActions>
                    <MudButton 
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable" 
                        DropShadow="false" 
                        Variant="Variant.Filled" 
                        Color="Color.Primary" 
                        OnClick="HandleEditAttributeDataTypeButtonClick" 
                        Class="ma-4">Confirm Change</MudButton>
                </DialogActions>
            </MudDialog>

            @if (_connectedSystem.ObjectTypes is { Count: > 0 })
            {
                if (_connectedSystem.ObjectTypes.Count > 1 || (_connectedSystem.ObjectTypes.Count == 1 && !_connectedSystem.ObjectTypes[0].Selected))
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText Class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            Select which object types you would like to manage with JIM.
                        </MudText>
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            @foreach (var objectType in _connectedSystem.ObjectTypes)
                            {
                                <MudCheckBox T="bool" Value="@objectType.Selected" Color="Color.Primary" Label="@objectType.Name" ValueChanged="((e) => HandleSelectedObjectTypeClick(objectType, e))" />
                            }
                        </div>
                    </MudPaper>
                }

                @if (_connectedSystem.ObjectTypes.Count(q => q.Selected) > 1)
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            <MudButtonGroup Color="Color.Default" Class="mb-5" DropShadow="false" Variant="Variant.Outlined">
                                @foreach (var objectType in _connectedSystem.ObjectTypes.Where(q => q.Selected))
                                {
                                    <MudButton 
                                        OnClick="@((_) => HandleActiveObjectTypeClick(objectType))"
                                        Disabled="DisableSelectedSchemaObjectType(objectType)"
                                        DropShadow="false">@objectType.Name</MudButton>
                                }
                            </MudButtonGroup>
                        </div>
                    </MudPaper>
                }

                @if (_selectedObjectType != null)
                {
                    <MudText Typo="Typo.h6" Class="mt-5">@_selectedObjectType.Name</MudText>
                    @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedExternalId)
                    {
                        <MudPaper Outlined="true" Class="pa-4 mt-5">
                            <MudText>This connector requires you to select the attribute that is used as the External ID. Please select one below.</MudText>
                            <MudSelect 
                                T="ConnectedSystemObjectTypeAttribute" 
                                Label="External ID Attribute"
                                Variant="Variant.Outlined"
                                Class="mt-5"
                                Required="true"
                                RequiredError="You must select an attribute as the External ID."
                                Value="_selectedObjectType.Attributes.SingleOrDefault(q => q.IsExternalId)"
                                ValueChanged="HandleMakeExternalId">
                                @foreach (var objectTypeAttribute in _selectedObjectType.Attributes.Where(q => q.AttributePlurality == AttributePlurality.SingleValued))
                                {
                                    <MudSelectItem Value="@objectTypeAttribute">@(objectTypeAttribute.Name)</MudSelectItem>
                                }
                            </MudSelect>
                        </MudPaper>
                    }

                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText Typo="Typo.subtitle1" Class="mb-3">Object Type Settings</MudText>
                        <MudSwitch
                            @bind-Value="@_selectedObjectType.RemoveContributedAttributesOnObsoletion"
                            Color="@Color.Primary"
                            Label="Remove contributed attributes when objects are obsoleted" />
                        <MudText Typo="Typo.caption" Class="mud-text-secondary">
                            When enabled, attribute values contributed by objects of this type will be removed from the Metaverse when the source object is deleted or no longer present in the connected system.
                        </MudText>
                    </MudPaper>

                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText>
                            Select which attributes you would like to manage for this object type. To maximise performance, only select those you need.
                        </MudText>

                        <MudGrid Class="mt-3 mb-3">
                            <MudItem xs="@(_selectedObjectTypeHasClasses ? 6 : 12)">
                                <MudTextField 
                                    T="string"
                                    @bind-Value="_schemaSearchString"
                                    Label="Filter by name"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Search"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined"
                                    HelperText="Show only attributes where the name containers a specific value"
                                    autocomplete="schema_search_string" />
                            </MudItem>

                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudItem xs="6">
                                    <MudSelect 
                                        T="string"
                                        Label="Filter by class"
                                        MultiSelection="true"
                                        @bind-SelectedValues="AttributeClassFilterSelectedValues"
                                        Variant="Variant.Outlined"
                                        HelperText="Show only attributes with a particular class"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.FilterAlt"
                                        IconSize="Size.Small">
                                        @foreach (var className in _selectedObjectType.Attributes.Select(a => a.ClassName).Distinct().OrderBy(a => a))
                                        {
                                            <MudSelectItem T="string" Value="@className">@className</MudSelectItem>
                                        }
                                    </MudSelect>
                                </MudItem>
                            }

                            <MudItem xs="10">
                                <MudTextField 
                                    T="string"
                                    Label="Select attributes via CSV"
                                    @bind-Value="_attributeSelectionCsv"
                                    HelperText="You can also quick-select attributes by entering them in a comma-separated list, i.e. DisplayName,sAMAccountName"
                                    InputType="InputType.Text"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Input"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined" />
                            </MudItem>
                            <MudItem xs="2">
                                <MudButton 
                                    Variant="Variant.Filled"
                                    DropShadow="false"
                                    Class="mt-4"
                                    Color="Color.Default"
                                    OnClick="HandleAttributeCsvSubmit">Select Attributes</MudButton>
                            </MudItem>

                            <MudItem xs="12" Class="pb-0">
                                <MudCheckBox @bind-Value="_attributeSelectedFilter" Color="Color.Primary">Show only selected?</MudCheckBox>
                            </MudItem>
                        </MudGrid>
                    </MudPaper>
                
                    <MudTable 
                        Items="@_selectedObjectType.Attributes"
                        Virtualize="true"
                        Hover="true"
                        Dense="true"
                        Breakpoint="Breakpoint.Sm"
                        SortLabel="Sort By"
                        Filter="new Func<ConnectedSystemObjectTypeAttribute,bool>(SchemaFilterFuncHandler)"
                        Class="mt-5"
                        Outlined="true"
                        Elevation="0">
                        <HeaderContent>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Selected)">Selected</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.IsExternalId)">External ID</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.ClassName!)">Class</MudTableSortLabel></MudTh>
                            }
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Type)">Type</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.AttributePlurality)">Plurality</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Description!)">Description</MudTableSortLabel></MudTh>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTh></MudTh>
                            }
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Selected">
                                <MudSwitch @bind-Value="@context.Selected" Color="@Color.Primary"></MudSwitch>
                            </MudTd>
                            <MudTd DataLabel="External ID">
                                @(context.IsExternalId ? "Yes" : "-")
                            </MudTd>
                            <MudTd DataLabel="Name">@context.Name</MudTd>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTd DataLabel="Class">
                                    @context.ClassName
                                </MudTd>
                            }
                            <MudTd DataLabel="Type">
                                @context.Type
                            </MudTd>
                            <MudTd DataLabel="Plurality" Class="jim-nowrap">
                                @context.AttributePlurality.ToString().SplitOnCapitalLetters()
                            </MudTd>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTd DataLabel="Description">
                                    @context.Description
                                </MudTd>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTd>
                                    <MudButton 
                                        DropShadow="false" 
                                        Size="Size.Small" 
                                        Variant="Variant.Filled"
                                        OnClick="() => HandleShowEditAttributeDialogAsync(context)"
                                        StartIcon="@Icons.Material.Filled.Edit">
                                        Edit
                                    </MudButton>
                                </MudTd>
                            }
                        </RowTemplate>
                        <NoRecordsContent>
                            @if (_attributeSelectedFilter) {
                                <MudText>There are no selected attributes for this object type.</MudText>
                            } else {
                                <MudText>There are no attributes to show.</MudText>
                            }
                        </NoRecordsContent>
                    </MudTable>
                }

                <MudButton 
                    Color="Color.Primary" 
                    Variant="Variant.Filled" 
                    OnClick="HandleObjectTypesAndAttributeSelectionSubmitAsync" 
                    Class="mt-5" 
                    DropShadow="false"
                    Disabled="DisableSaveSchemaButton()">Save Changes</MudButton>
            }

        </MudTabPanel>

        @if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            <MudTabPanel Text="Partitions & Containers" Disabled="@AreSettingDependentTabsDisabled()">

                <MudAlert Severity="(_connectedSystem.Partitions is { Count: > 0 } ? Severity.Warning : Severity.Info)">
                    @if (_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0)
                    {
                        <MudText>Retrieve the hierarchy @_partitionAndHierarchyText hierarchy from the connected system, to be able to select which ones you want to manage with JIM.</MudText>
                    }
                    else
                    {
                        <MudText>
                            <strong>Refreshing the @_partitionAndHierarchyText hierarchy can result in data-loss</strong>. If partitions and/or containers are removed, then this will result in all objects in them being deleted
                            from the Connected System, which depending on your configuration, could result in those objects being deprovisioned from the Metaverse and any downstream Connected Systems. Refresh with caution.
                            Ensure the Connected System identity has the right permissions needed to retrieve the hierarchy, and consider a database backup before proceeding.
                        </MudText>
                    }
                    <MudButton 
                            Disabled="@_hierarchyBeingRetrieved"
                            Color="_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0 ? Color.Primary : Color.Warning"
                            Size="Size.Small"
                            OnClick="HandleImportHierarchyAsync"
                            Variant="Variant.Filled"
                            Class="mt-5"
                            DropShadow="false">
                        @if (_connectedSystem.Partitions?.Count == 0)
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Retrieving Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Retrieve Hierarchy</text>
                            }
                        }
                        else
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Refreshing Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Refresh Hierarchy</text>
                            }
                        }
                    </MudButton>
                </MudAlert>

                @if (_connectedSystem.Partitions is { Count: > 0 })
                {
                    <MudText Class="mt-5">Select which @_partitionsAndHierarchiesText are to be managed by JIM here. To maximise performance, only select those that need managing.</MudText>
                    @foreach (var partition in _connectedSystem.Partitions)
                    {
                        <MudPaper Class="mt-5" Outlined="true">
                            <div class="pa-4">
                                <MudText Typo="Typo.h5" Class="mb-5">@partition.Name</MudText>
                                <MudSwitch @bind-Value="@partition.Selected" Color="Color.Primary" Label="Manage this partition?" />
                            </div>
                            <MudDivider />

                            <div class="pa-4">
                                <MudText>Select the containers you want to manage in this partition.</MudText>
                                
                                @*
                                TODO:
                                <MudButtonGroup Color="Color.Default" Size="Size.Small" Variant="Variant.Outlined" Class="mt-5 mb-5">
                                    <MudButton>Select All</MudButton>
                                    <MudButton>Clear All</MudButton>
                                </MudButtonGroup>
                                *@
                                
                                @if (partition.Containers != null)
                                {
                                    <MudTreeView Items="@GetTreeItemData(partition.Containers)" ReadOnly AutoExpand>
                                        <ItemTemplate Context="item">
                                            <MudTreeViewItem @bind-Expanded="@item.Expanded" Items="@item.Children">
                                                <BodyContent>
                                                    @if (item.Value != null)
                                                    {
                                                        @if (item.Value.Included)
                                                        {
                                                            <MudCheckBox T="bool?"
                                                                         Value="@(item.Value.AreAnyChildContainersSelected() ? null : item.Value.Selected)"
                                                                         ValueChanged="@(_ => ConnectedSystemContainerSelectedChanged(item.Value))"
                                                                         UncheckedIcon="@Icons.Material.Outlined.FilterCenterFocus"
                                                                         Disabled="true"
                                                                         title="Included"/>
                                                        }
                                                        else
                                                        {
                                                            <MudCheckBox T="bool?"
                                                                         Value="@(item.Value.AreAnyChildContainersSelected() ? null : item.Value.Selected)"
                                                                         ValueChanged="@(_ => ConnectedSystemContainerSelectedChanged(item.Value))"
                                                                         title="@(item.Value.Selected ? "Selected" : string.Empty)"/>
                                                        }
                                                        <MudText>@item.Value.Name</MudText>    
                                                    }
                                                </BodyContent>
                                            </MudTreeViewItem>
                                        </ItemTemplate>
                                    </MudTreeView>
                                }
                            </div>
                        </MudPaper>
                    }

                    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleHierarchySelectionSubmitAsync" Class="mt-5" DropShadow="false">Save Changes</MudButton>
                }
            </MudTabPanel>
        }

        <MudTabPanel Text="Run Profiles" Disabled="@IsRunProfilesTabDisabled()">
            <MudAlert Severity="Severity.Info">Run profiles define what operations can be performed on a Connector, i.e. import, export and synchronisation, with any required settings.</MudAlert>

            <MudPaper Outlined="true" Class="pa-4 mt-5">
                <MudText Typo="Typo.h6">Create a New Run Profile</MudText>

                <MudForm @bind-IsValid="@IsNewRunProfileFormValid">
                    <MudTextField T="string" @bind-Value="_newRunProfile.Name" Label="Name" Variant="Variant.Outlined" Class="mt-3" Required="true" RequiredError="A name for the run profile is required" />

                    <!-- would like to make this conditional, but the connector definition needs to state if it's file-based or not. this can be determined for custom connectors, but not built-in as there are no files for those. -->
                    <MudTextField
                        T="string"
                        @bind-Value="_newRunProfile.FilePath"
                        Label="File Path"
                        Variant="Variant.Outlined"
                        Class="mt-3"
                        HelperText="File-based connectors need the in-container path specifying, i.e. /var/connector-files/test-data/Users.csv" />

                    <MudSelect 
                        T="ConnectedSystemRunType" 
                        @bind-Value="_newRunProfile.RunType" 
                        Label="Run Type" 
                        Variant="Variant.Outlined" 
                        AnchorOrigin="Origin.BottomCenter" 
                        Class="mt-5" 
                        Required="true" 
                        RequiredError="A run profile type is required">
                        @foreach (ConnectedSystemRunType runType in Enum.GetValues(typeof(ConnectedSystemRunType)))
                        {
                            var runTypeSupported = true;
                            switch (runType)
                            {
                                case ConnectedSystemRunType.Export when !_connectedSystem.ConnectorDefinition.SupportsExport:
                                case ConnectedSystemRunType.DeltaImport when !_connectedSystem.ConnectorDefinition.SupportsDeltaImport:
                                case ConnectedSystemRunType.FullImport when !_connectedSystem.ConnectorDefinition.SupportsFullImport:
                                case ConnectedSystemRunType.NotSet:
                                    runTypeSupported = false;
                                    break;
                                case ConnectedSystemRunType.FullSynchronisation:
                                case ConnectedSystemRunType.DeltaSynchronisation:
                                    break;
                            }

                            <MudSelectItem Value="@runType" Disabled="@(!runTypeSupported)">
                                @runType.ToString().SplitOnCapitalLetters()
                                @if (!runTypeSupported)
                                {
                                    <span> (not supported by Connector)</span>
                                }
                            </MudSelectItem>
                        }
                    </MudSelect>
                    
                    @if (_connectedSystem.ConnectorDefinition.SupportsPartitions && _connectedSystem.Partitions != null)
                    {
                        <MudSelect 
                            T="ConnectedSystemPartition" 
                            @bind-Value="_newRunProfile.Partition" 
                            Label="Partition" 
                            Variant="Variant.Outlined" 
                            Class="mt-5" 
                            AnchorOrigin="Origin.BottomCenter" 
                            Required="@_connectedSystem.ConnectorDefinition.SupportsPartitions" 
                            RequiredError="A run profile partition is required">
                            @foreach (var partition in _connectedSystem.Partitions.Where(p => p.Selected))
                            {
                                <MudSelectItem Value="@partition" />
                            }
                        </MudSelect>
                    }
                    <MudNumericField @bind-Value="_newRunProfile.PageSize" Label="Page Size" Variant="Variant.Outlined" Class="mt-3" Min="0" Step="100" Required="true" RequiredError="How many items to process in one go when importing/exporting" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsNewRunProfileFormValid)" OnClick="HandleNewRunProfileFormSubmitAsync" Class="mt-5" DropShadow="false">Create Run Profile</MudButton>
                </MudForm>
            </MudPaper>

            <MudTable Items="@_connectedSystem.RunProfiles" Hover="true" Breakpoint="Breakpoint.Sm" Class="mt-5" SortLabel="Sort By" Outlined="true" Elevation="0">
                <HeaderContent>
                    <MudTh>Actions</MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.RunType)">Run Type</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Partition?.Name!)">Partition</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.PageSize)">Page Size</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.FilePath!)">File Path</MudTableSortLabel></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true">
                            <MudMenuItem Icon="@Icons.Material.Filled.Delete" OnClick="_ => HandleRunProfileDeleteAsync(context)">Delete</MudMenuItem>
                        </MudMenu>
                    </MudTd>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudTd DataLabel="Run Type">@context.RunType.ToString().SplitOnCapitalLetters()</MudTd>
                    <MudTd DataLabel="Partition">@(context.Partition != null ? context.Partition.Name : "-")</MudTd>
                    <MudTd DataLabel="Page Size">@context.PageSize</MudTd>
                    <MudTd DataLabel="File Path">@(context.FilePath ?? "-")</MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    There are no run profiles. Create your first.
                </NoRecordsContent>
            </MudTable>

        </MudTabPanel>

        <MudTabPanel Text="Danger Zone" Icon="@Icons.Material.Filled.Warning" BadgeColor="Color.Error">
            <MudAlert Severity="Severity.Warning" Class="mb-5">
                The actions in this section are destructive and cannot be undone. Please proceed with caution.
            </MudAlert>

            <MudPaper Outlined="true" Class="pa-4">
                <MudText Typo="Typo.h6" Color="Color.Error">Delete Connected System</MudText>
                <MudText Class="mt-2">
                    Permanently delete this Connected System and all its related data, including:
                </MudText>
                <ul class="mt-2 ml-4">
                    <li>All Connected System Objects (CSOs)</li>
                    <li>All Sync Rules</li>
                    <li>All Run Profiles</li>
                    <li>All Partitions and Containers</li>
                    <li>All Pending Exports</li>
                </ul>
                <MudText Class="mt-2">
                    Metaverse Objects joined to this system's CSOs will be disconnected but not deleted.
                </MudText>

                <MudButton
                    Variant="Variant.Filled"
                    Color="Color.Error"
                    Class="mt-5"
                    DropShadow="false"
                    StartIcon="@Icons.Material.Filled.Delete"
                    OnClick="HandleShowDeleteConfirmationAsync"
                    Disabled="@(_connectedSystem?.Status == ConnectedSystemStatus.Deleting)">
                    @if (_connectedSystem?.Status == ConnectedSystemStatus.Deleting)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Deletion in Progress...</MudText>
                    }
                    else
                    {
                        <text>Delete Connected System</text>
                    }
                </MudButton>
            </MudPaper>
        </MudTabPanel>

    </MudTabs>

    @* Delete Confirmation Dialog *@
    <MudDialog @bind-Visible="_deleteConfirmationDialogVisible" Options="_deleteDialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Warning" Color="Color.Error" Class="mr-3" /> Confirm Deletion
            </MudText>
        </TitleContent>
        <DialogContent>
            @if (_deletionPreview != null)
            {
                <MudAlert Severity="Severity.Error" Class="mb-4">
                    This action is <strong>permanent</strong> and cannot be undone!
                </MudAlert>

                <MudText Typo="Typo.subtitle1">The following will be deleted:</MudText>
                <MudSimpleTable Dense="true" Hover="true" Class="mt-2" Elevation="0" Outlined="true">
                    <tbody>
                        <tr>
                            <td>Connected System Objects</td>
                            <td class="text-right">@_deletionPreview.ConnectedSystemObjectCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Sync Rules</td>
                            <td class="text-right">@_deletionPreview.SyncRuleCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Run Profiles</td>
                            <td class="text-right">@_deletionPreview.RunProfileCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Partitions</td>
                            <td class="text-right">@_deletionPreview.PartitionCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Containers</td>
                            <td class="text-right">@_deletionPreview.ContainerCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Pending Exports</td>
                            <td class="text-right">@_deletionPreview.PendingExportCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Activities (will be preserved)</td>
                            <td class="text-right">@_deletionPreview.ActivityCount.ToString("N0")</td>
                        </tr>
                    </tbody>
                </MudSimpleTable>

                @if (_deletionPreview.JoinedMvoCount > 0)
                {
                    <MudAlert Severity="Severity.Info" Class="mt-4">
                        @_deletionPreview.JoinedMvoCount.ToString("N0") Metaverse Object(s) will be disconnected from this system.
                    </MudAlert>
                }

                @if (_deletionPreview.Warnings.Count > 0)
                {
                    <MudText Typo="Typo.subtitle1" Class="mt-4">Warnings:</MudText>
                    <ul class="mt-2 ml-4">
                        @foreach (var warning in _deletionPreview.Warnings)
                        {
                            <li><MudText Color="Color.Warning">@warning</MudText></li>
                        }
                    </ul>
                }

                @if (_deletionPreview.WillRunAsBackgroundJob)
                {
                    <MudAlert Severity="Severity.Info" Class="mt-4">
                        Due to the size of this system, deletion will run as a background job.
                        Estimated time: @_deletionPreview.EstimatedDeletionTime.ToString(@"hh\:mm\:ss")
                    </MudAlert>
                }

                <MudTextField
                    T="string"
                    @bind-Value="_deleteConfirmationText"
                    Label="@($"Type \"{_connectedSystem?.Name}\" to confirm")"
                    Variant="Variant.Outlined"
                    Class="mt-4"
                    FullWidth="true"
                    Immediate="true" />
            }
            else if (_deletionPreviewLoading)
            {
                <div class="d-flex justify-center align-center pa-8">
                    <MudProgressCircular Indeterminate="true" />
                    <MudText Class="ml-4">Loading deletion preview...</MudText>
                </div>
            }
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="@(() => _deleteConfirmationDialogVisible = false)" DropShadow="false">Cancel</MudButton>
            <MudButton
                Color="Color.Error"
                Variant="Variant.Filled"
                DropShadow="false"
                OnClick="HandleDeleteConfirmedAsync"
                Disabled="@(!IsDeleteConfirmationValid())">
                @if (_deletionInProgress)
                {
                    <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                    <MudText Class="ms-2">Deleting...</MudText>
                }
                else
                {
                    <text>Delete Permanently</text>
                }
            </MudButton>
        </DialogActions>
    </MudDialog>
}

@code {
    [Parameter]
    public int Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }
    private bool IsDetailsFormValid { get; set; }
    private string[] DetailsFormErrors { get; set; } = [];
    private bool IsSettingsFormValid { get; set; }
    private string[] SettingsFormErrors { get; set; } = [];
    private Dictionary<string, string> SettingsFormCustomErrors { get; } = new();
    private bool IsNewRunProfileFormValid { get; set; }
    private ConnectedSystem? _connectedSystem;
    private bool _settingsBeingSaved;
    private List<ConnectedSystemSettingCategory>? _settingCategories;
    private string? _partitionsAndHierarchiesText;
    private string? _partitionAndHierarchyText;
    private bool _schemaBeingRetrieved;
    private ConnectedSystemObjectType? _selectedObjectType;
    private bool _selectedObjectTypeHasClasses;
    private bool _selectedObjectTypeHasDescriptions;
    private bool _hierarchyBeingRetrieved;
    private string _schemaSearchString = "";
    private ConnectedSystemRunProfile _newRunProfile = new() { PageSize = 500 };
    private IEnumerable<string> AttributeClassFilterSelectedValues { get; set; } = new HashSet<string>();
    private bool _attributeSelectedFilter;
    private string? _attributeSelectionCsv;
    private List<BreadcrumbItem> _breadcrumbs = null!;

    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private bool _editSchemaAttributeDialogVisible;
    private ConnectedSystemObjectTypeAttribute? _objectTypeAttributeBeingEdited;
    private string? _objectTypeAttributeBeingEditedText;
    private bool _objectTypeAttributeBeingEditedIsEditable;

    // Delete confirmation dialog
    private readonly DialogOptions _deleteDialogOptions = new() { FullWidth = true, MaxWidth = MaxWidth.Small };
    private bool _deleteConfirmationDialogVisible;
    private ConnectedSystemDeletionPreview? _deletionPreview;
    private bool _deletionPreviewLoading;
    private bool _deletionInProgress;
    private string? _deleteConfirmationText;

    protected override async Task OnInitializedAsync()
    {
        _connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(Id);
        if (_connectedSystem == null)
        {
            // connected system not found, redirect to index page
            NavManager.NavigateTo("../");
            return;
        }

        _breadcrumbs =
        [
            new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
            new BreadcrumbItem("Connected Systems", href: "/admin/connected-systems/"),
            new BreadcrumbItem(_connectedSystem.Name, href: null, disabled: true)
        ];

        // get a list of the distinct setting categories in use, so we can render them in category blocks
        // Filter out categories based on connector capabilities and order them logically
        _settingCategories = _connectedSystem.SettingValues
            .Select(q => q.Setting.Category)
            .Distinct()
            .Where(category => ShouldShowCategory(category))
            .OrderBy(category => GetCategoryDisplayOrder(category))
            .ToList();

        // to save us having to perform this comparison all over the view
        if (_connectedSystem.ConnectorDefinition is { SupportsPartitions: true, SupportsPartitionContainers: true })
        {
            _partitionsAndHierarchiesText = "partitions and containers";
            _partitionAndHierarchyText = "partition and container";
        }
        else if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            _partitionsAndHierarchiesText = "partitions";
            _partitionAndHierarchyText = "partition";
        }

        // show the first selected object type attribute table
        if (_connectedSystem.ObjectTypes != null)
            _selectedObjectType = _connectedSystem.ObjectTypes.FirstOrDefault(q => q.Selected);

        ApplyContainerIncludedToPartitions(_connectedSystem);
    }

    private bool AreSettingDependentTabsDisabled()
    {
        if (_connectedSystem == null)
            return true;

        return !_connectedSystem.SettingValuesValid;
    }

    /// <summary>
    /// Determines whether a setting category should be displayed based on connector capabilities.
    /// </summary>
    private bool ShouldShowCategory(ConnectedSystemSettingCategory category)
    {
        if (_connectedSystem?.ConnectorDefinition == null)
            return true;

        return category switch
        {
            // Only show Import category if the connector supports full or delta import
            ConnectedSystemSettingCategory.Import =>
                _connectedSystem.ConnectorDefinition.SupportsFullImport ||
                _connectedSystem.ConnectorDefinition.SupportsDeltaImport,

            // Only show Export category if the connector supports export
            ConnectedSystemSettingCategory.Export =>
                _connectedSystem.ConnectorDefinition.SupportsExport,

            // Always show other categories
            _ => true
        };
    }

    /// <summary>
    /// Returns the display order for setting categories.
    /// Order: Import, Export, General, Schema, Connectivity, Capabilities
    /// </summary>
    private static int GetCategoryDisplayOrder(ConnectedSystemSettingCategory category)
    {
        return category switch
        {
            ConnectedSystemSettingCategory.Import => 0,
            ConnectedSystemSettingCategory.Export => 1,
            ConnectedSystemSettingCategory.General => 2,
            ConnectedSystemSettingCategory.Schema => 3,
            ConnectedSystemSettingCategory.Connectivity => 4,
            ConnectedSystemSettingCategory.Capabilities => 5,
            _ => 99
        };
    }

    private async Task HandleValidDetailsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidDetailsSubmitAsync)}: connectedSystem was null");
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your details changes have been saved.", Severity.Success);
    }

    private async Task HandleValidSettingsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidSettingsSubmitAsync)}: connectedSystem was null");
            return;
        }

        _settingsBeingSaved = true;
        SettingsFormCustomErrors.Clear();

        StateHasChanged();
        await Task.Delay(1);

        // validate the form
        var results = Jim.ConnectedSystems.ValidateConnectedSystemSettings(_connectedSystem);
        for (var i = 0; i < results.Count; i++)
        {
            var result = results[i];
            if (result.IsValid)
                continue;

            switch (result.SettingValue)
            {
                case { Setting.Name: not null } when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add(result.SettingValue.Setting.Name, result.ErrorMessage);
                    break;
                case null when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add($"General issue {i + 1}", result.ErrorMessage);
                    break;
            }
        }

        if (SettingsFormCustomErrors.Any())
        {
            _settingsBeingSaved = false;
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your setting changes have been saved.", Severity.Success);
        _settingsBeingSaved = false;

        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task HandleImportSchemaAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _schemaBeingRetrieved = true;
        StateHasChanged();
        await Task.Delay(1);

        await Jim.ConnectedSystems.ImportConnectedSystemSchemaAsync(_connectedSystem, user);

        // if there's just a single object type in the schema, auto-select it
        if (_connectedSystem.ObjectTypes is { Count: 1 })
            HandleSelectedObjectTypeClick(_connectedSystem.ObjectTypes[0], true);

        _schemaBeingRetrieved = false;
        StateHasChanged();
        await Task.Delay(1);
    }

    private void HandleSelectedObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType, bool isObjectTypeChecked)
    {
        if (_connectedSystem == null)
            return;

        // actuate the state change
        connectedSystemObjectType.Selected = isObjectTypeChecked;

        // now cascade
        // if only one type is selected, make that the selected object type
        // if none are selected, clear selected object type
        // if the selected type is being de-selected, null the selected type
        if (_connectedSystem.ObjectTypes != null && _connectedSystem.ObjectTypes.Count(q => q.Selected) == 1)
            _selectedObjectType = _connectedSystem.ObjectTypes.Single(q => q.Selected);
        else if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count(q => q.Selected) == 0)
            _selectedObjectType = null;
        else if (_selectedObjectType != null && _selectedObjectType.Id == connectedSystemObjectType.Id && !isObjectTypeChecked)
            _selectedObjectType = null;

        // some parts of the UI only make sense if the attributes have classes
        _selectedObjectTypeHasClasses = connectedSystemObjectType.Attributes.Any(q => q.ClassName != null);
        _selectedObjectTypeHasDescriptions = connectedSystemObjectType.Attributes.Any(q => q.Description != null);
    }

    private void HandleActiveObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType)
    {
        _selectedObjectType = connectedSystemObjectType;
    }

    private void HandleMakeExternalId(ConnectedSystemObjectTypeAttribute selectedAttribute)
    {
        if (_selectedObjectType == null)
        {
            Log.Error($"CS Detail > HandleMakeExternalId: {nameof(_selectedObjectType)} is null!");
            return;
        }

        // make sure there's not already an attribute marked as the external id
        foreach (var attribute in _selectedObjectType.Attributes.Where(a => a.IsExternalId))
            attribute.IsExternalId = false;

        // mark the intended attribute as the external id, and select it
        selectedAttribute.IsExternalId = true;
        selectedAttribute.Selected = true;
        Log.Verbose($"CS Detail > HandleMakeExternalId: Set attribute id {selectedAttribute} as the external id.");
    }

    private async Task HandleObjectTypesAndAttributeSelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your attribute changes have been saved.", Severity.Success);
    }

    private async Task HandleImportHierarchyAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _hierarchyBeingRetrieved = true;
        StateHasChanged();
        await Task.Delay(1);

        await Jim.ConnectedSystems.ImportConnectedSystemHierarchyAsync(_connectedSystem, user);
        _hierarchyBeingRetrieved = false;
        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task HandleHierarchySelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your hierarchy changes have been saved.", Severity.Success);
    }

    private bool SchemaFilterFuncHandler(ConnectedSystemObjectTypeAttribute element) => SchemaFilterFunc(element, _schemaSearchString, AttributeClassFilterSelectedValues, _attributeSelectedFilter);

    private static bool SchemaFilterFunc(ConnectedSystemObjectTypeAttribute element, string searchString, IEnumerable<string> attributeClassFilterSelectedValues, bool attributeSelectedFilter)
    {
        // what type of search is this? name, class or csv?
        var classHashset = (HashSet<string>)attributeClassFilterSelectedValues;

        if (!string.IsNullOrEmpty(searchString))
            return element.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase);

        if (classHashset.Count > 0)
            return classHashset.Any(q => q == element.ClassName);

        return !attributeSelectedFilter || element.Selected;
    }

    private static List<TreeItemData<ConnectedSystemContainer>> GetTreeItemData(HashSet<ConnectedSystemContainer> containers)
    {
        return containers.Select(connectedSystemContainer => new TreeItemData<ConnectedSystemContainer>
        {
            Value = connectedSystemContainer, 
            Children = GetTreeItemData(connectedSystemContainer.ChildContainers)
        }).ToList();
    }
    
    private static void ConnectedSystemContainerSelectedChanged(ConnectedSystemContainer container)
    {
        // if included and clicked, change to not included, not selected
        if (container.Included)
        {
            container.Selected = false;
        }
        else
        {
            // toggle the current setting
            container.Selected = !container.Selected;
        }

        container.Included = false;

        // set the right selected/included values for all children
        if (container.Selected)
        {
            // all children should be included and not selected
            foreach (var child in container.ChildContainers)
            {
                child.Included = true;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, true);
            }
        }
        else
        {
            // all children should be not selected and not included
            foreach (var child in container.ChildContainers)
            {
                child.Included = false;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, false);
            }
        }

        // set the parent(s) if necessary
        if (container.ParentContainer != null)
        {
            // go up a level. if all children are selected, then make parent selected and all children (recursively) included.
            CorrectUpwardContainerStatus(container.ParentContainer);
        }

        // make sure the partition is selected if not already
        AutoSelectPartitionIfContainersSelected(container);
    }

    /// <summary>
    /// Makes sure the partition is selected if any contains in its hierarchy are selected.
    /// </summary>
    private static void AutoSelectPartitionIfContainersSelected(ConnectedSystemContainer container)
    {
        // this method could probably be optimised. I was having a hard time writing this.
        // get the partition at the top of the container hierarchy
        var partition = container.Partition;
        var areAnyContainersSelected = container.Selected;
        if (partition != null && areAnyContainersSelected && !partition.Selected)
        {
            partition.Selected = true;
            return;
        }
        
        // we need a variable to hold the TLC when we eventually find it
        ConnectedSystemContainer? topLevelContainer = null;
        
        // we need a variable to hold the current container as we navigate up the hierarchy
        var currentContainer = container;
        
        // keep moving up the container hierarchy until we find the TLC
        // ReSharper disable once LoopVariableIsNeverChangedInsideLoop : incorrect
        while (topLevelContainer == null)
        {
            if (currentContainer.ParentContainer == null)
            {
                // found it! stop looping
                topLevelContainer = currentContainer;
                break;
            }

            // move up one level in the container hierarchy
            currentContainer = currentContainer.ParentContainer;
        }

        // it's possible the TLC hasn't been found
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse : incorrect
        if (topLevelContainer == null)
        {
            Log.Warning("Couldn't find the top-level container. unable to auto-select partition.");
            return;
        }

        // we might already know if any containers are selected
        if (!areAnyContainersSelected)
        {
            // we have a TLC! now, are any containers in the hierarchy selected?
            if (topLevelContainer.Partition is { Containers: not null })
                if (topLevelContainer.Partition.Containers.Any(IsContainerOrAnyChildrenSelected))
                    areAnyContainersSelected = true;
        }
        
        // does the top-level container have a parent partition?
        if (topLevelContainer.Partition != null && areAnyContainersSelected)
            topLevelContainer.Partition.Selected = true;
    }

    private static bool IsContainerOrAnyChildrenSelected(ConnectedSystemContainer container)
    {
        return container.Selected || container.ChildContainers.Any(IsContainerOrAnyChildrenSelected);
    }

    private static void ApplyContainerStatusDownBranch(ConnectedSystemContainer container, bool selected, bool included)
    {
        foreach (var child in container.ChildContainers)
        {
            child.Included = included;
            child.Selected = selected;
            ApplyContainerStatusDownBranch(child, selected, included);
        }
    }

    private static void ApplyContainerIncludedToPartitions(ConnectedSystem connectedSystemInQuestion)
    {
        if (connectedSystemInQuestion.Partitions == null)
            return;

        foreach (var partition in connectedSystemInQuestion.Partitions)
            if (partition.Containers != null)
                foreach (var container in partition.Containers)
                    ApplyContainerIncludedRecursively(container, container.Selected);
    }

    private static void ApplyContainerIncludedRecursively(ConnectedSystemContainer connectedSystemContainer, bool aParentWasSelected)
    {
        foreach (var childContainer in connectedSystemContainer.ChildContainers)
        {
            var shouldChildBeIncluded = aParentWasSelected;

            // parent was selected, so this child container should be marked as included
            if (aParentWasSelected)
                childContainer.Included = true;

            // if this child container is selected, then it's children should be marked as included
            if (childContainer.Selected)
                shouldChildBeIncluded = true;

            ApplyContainerIncludedRecursively(childContainer, shouldChildBeIncluded);
        }
    }

    private static void CorrectUpwardContainerStatus(ConnectedSystemContainer parentContainer)
    {
        if (parentContainer.ChildContainers.All(q => q.Selected))
        {
            parentContainer.Selected = true;
            parentContainer.Included = false;

            foreach (var childContainer in parentContainer.ChildContainers)
            {
                childContainer.Selected = false;
                childContainer.Included = true;
                ApplyContainerStatusDownBranch(childContainer, false, true);
            }
        }

        if (parentContainer.ParentContainer != null)
            CorrectUpwardContainerStatus(parentContainer.ParentContainer);
    }

    private bool IsRunProfilesTabDisabled()
    {
        if (_connectedSystem == null)
            return true;

        return _connectedSystem.ConnectorDefinition.SupportsPartitions && (_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0);
    }

    private async Task HandleNewRunProfileFormSubmitAsync()
    {
        if (_connectedSystem?.RunProfiles == null)
            return;

        // copy the form bound object to a new one we can persist separately from the form bind
        var runProfile = new ConnectedSystemRunProfile {
            ConnectedSystemId = _connectedSystem.Id,
            Name = _newRunProfile.Name,
            RunType = _newRunProfile.RunType,
            Partition = _newRunProfile.Partition,
            PageSize = _newRunProfile.PageSize,
            FilePath = _newRunProfile.FilePath
        };

        // attribute the action to the user and create the run profile
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.CreateConnectedSystemRunProfileAsync(runProfile, user);

        Snackbar.Add("New run profile added.", Severity.Success);

        // reset the object we've bound to the form so a new run profile can be created if the user chooses
        _newRunProfile = new ConnectedSystemRunProfile();
    }

    private async Task HandleRunProfileDeleteAsync(ConnectedSystemRunProfile connectedSystemRunProfile)
    {
        if (_connectedSystem?.RunProfiles == null)
            return;

        _connectedSystem.RunProfiles.Remove(connectedSystemRunProfile);

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.DeleteConnectedSystemRunProfileAsync(connectedSystemRunProfile, user);

        Snackbar.Add("Run profile removed.", Severity.Success);
    }

    private void HandleAttributeCsvSubmit()
    {
        if (_selectedObjectType == null)
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: connectedSystem was null");
            return;
        }

        if (string.IsNullOrEmpty(_attributeSelectionCsv))
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: attributeSelectionCsv is null or empty");
            return;
        }

        // clear the other search boxes
        _schemaSearchString = string.Empty;
        ((HashSet<string>)AttributeClassFilterSelectedValues).Clear();

        // convert the csv to a list and trim the entries
        // go through each attribute on the object type and select it
        foreach (var attributeName in _attributeSelectionCsv.Split(','))
        {
            var attribute = _selectedObjectType.Attributes.SingleOrDefault(a => a.Name.Equals(attributeName.Trim(), StringComparison.OrdinalIgnoreCase));
            if (attribute == null)
                continue;

            attribute.Selected = true;
        }

        // filter by selected
        _attributeSelectedFilter = true;

        // clear the attribute csv text box
        _attributeSelectionCsv = null;

        // all done, let the user know
        Snackbar.Add("Attributes selected.", Severity.Success);
    }

    private bool DisableSelectedSchemaObjectType(ConnectedSystemObjectType connectedSystemObjectType)
    {
        if (_selectedObjectType == null)
            return false;

        if (connectedSystemObjectType.Id.Equals(_selectedObjectType.Id))
            return true; // BOTH IDS ARE 0 WHEN THEY'RE DIFFERENT TYPES! HOW?! - BECAUSE THEY HAVEN'T BEEN PERSISTED YET!

        return false;
    }

    /// <summary>
    /// Determines whether the Save Schema changes button should be disabled or not.
    /// </summary>
    private bool DisableSaveSchemaButton()
    {
        // must select at least one object type
        // all selected object types must have an external id selected

        if (_connectedSystem?.ObjectTypes == null)
            return true;

        var objectTypesSelected = _connectedSystem.ObjectTypes.Any(ot => ot.Selected);
        var externalIdsSet = _connectedSystem.ObjectTypes.Where(ot => ot.Selected).All(ot => ot.Attributes.Any(a => a.IsExternalId));

        return !objectTypesSelected || !externalIdsSet;
    }

    private async Task HandleShowEditAttributeDialogAsync(ConnectedSystemObjectTypeAttribute connectedSystemObjectTypeAttribute)
    {
        // can the connected system attribute be edited? are there any references to it?
        _objectTypeAttributeBeingEditedIsEditable = !await Jim.ConnectedSystems.IsObjectTypeAttributeBeingReferencedAsync(connectedSystemObjectTypeAttribute);
        _objectTypeAttributeBeingEdited = connectedSystemObjectTypeAttribute;
        _objectTypeAttributeBeingEditedText = connectedSystemObjectTypeAttribute.Type.ToString();
        _editSchemaAttributeDialogVisible = true;
    }

    private void HandleEditAttributeDataTypeButtonClick()
    {
        if (_objectTypeAttributeBeingEdited == null)
            return;

        if (_objectTypeAttributeBeingEditedText == null)
            return;

        _objectTypeAttributeBeingEdited.Type = (AttributeDataType)Enum.Parse(typeof(AttributeDataType), _objectTypeAttributeBeingEditedText);
        _editSchemaAttributeDialogVisible = false;

        // all done, let the user know
        Snackbar.Add("Attribute data type updated.", Severity.Success);
    }

    #region Delete Connected System
    private async Task HandleShowDeleteConfirmationAsync()
    {
        _deleteConfirmationText = string.Empty;
        _deletionPreview = null;
        _deletionPreviewLoading = true;
        _deleteConfirmationDialogVisible = true;

        StateHasChanged();
        await Task.Delay(1);

        // Load the deletion preview
        _deletionPreview = await Jim.ConnectedSystems.GetDeletionPreviewAsync(Id);
        _deletionPreviewLoading = false;

        StateHasChanged();
    }

    private bool IsDeleteConfirmationValid()
    {
        if (_deletionPreview == null || _deletionInProgress)
            return false;

        // User must type the exact name of the connected system to confirm
        return string.Equals(_deleteConfirmationText?.Trim(), _connectedSystem?.Name, StringComparison.Ordinal);
    }

    private async Task HandleDeleteConfirmedAsync()
    {
        if (_connectedSystem == null || !IsDeleteConfirmationValid())
            return;

        _deletionInProgress = true;
        StateHasChanged();
        await Task.Delay(1);

        try
        {
            // Get the current user
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

            // Perform the deletion
            var result = await Jim.ConnectedSystems.DeleteAsync(Id, user);

            _deleteConfirmationDialogVisible = false;
            _deletionInProgress = false;

            if (result.Success)
            {
                switch (result.Outcome)
                {
                    case DeletionOutcome.CompletedImmediately:
                        Snackbar.Add("Connected System has been deleted.", Severity.Success);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;

                    case DeletionOutcome.QueuedAsBackgroundJob:
                        Snackbar.Add("Deletion has been queued as a background job. You can monitor progress in the Operations view.", Severity.Info);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;

                    case DeletionOutcome.QueuedAfterSync:
                        Snackbar.Add("A sync operation is running. Deletion will proceed after it completes.", Severity.Info);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;
                }
            }
            else
            {
                Snackbar.Add($"Failed to delete: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            _deletionInProgress = false;
            Log.Error(ex, "Error deleting connected system {Id}", Id);
            Snackbar.Add($"An error occurred: {ex.Message}", Severity.Error);
        }

        StateHasChanged();
    }
    #endregion
}