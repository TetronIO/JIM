@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Models.Tasking
@using JIM.Models.Tasking.DTOs
@using JIM.Utilities
@inject JimApplication Jim
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject IWebHostEnvironment Environment
@implements IDisposable

<MudPaper Outlined="true" Class="pa-4">
    <MudText Typo="Typo.h6">Execute a Run Profile</MudText>
    <MudText Typo="Typo.subtitle1" Class="mud-text-secondary">Add a Synchronisation Run to the queue. If it's empty, it'll run immediately, if not, it'll run when all other queued tasks are complete.</MudText>

    @if (_connectedSystemHeaders is { Count: > 0 })
    {
        <MudForm>
            <MudGrid>
                <MudItem xs="12" sm="5">
                    <MudSelect T="ConnectedSystemHeader" ValueChanged="HandleConnectedSystemHeaderChangedAsync" Label="Connected System" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomLeft" Required="true" RequiredError="Please select a Connected System">
                        @foreach (var connectedSystem in _connectedSystemHeaders)
                        {
                            <MudSelectItem Value="@connectedSystem" />
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" sm="5">
                    <MudSelect T="ConnectedSystemRunProfile" @bind-Value="_selectedConnectedSystemRunProfile" Label="Run Profile" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomLeft" Required="true" RequiredError="A run profile is required" Disabled="@(_connectedSystemRunProfiles == null)">
                        @if (_connectedSystemRunProfiles != null)
                        {
                            @foreach (var runProfile in _connectedSystemRunProfiles)
                            {
                                <MudSelectItem Value="@runProfile" />
                            }
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" sm="2" Class="d-flex align-end pb-2">
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="HandleExecuteRunProfileSubmitAsync" DropShadow="false" FullWidth="true" Style="height: 50px;">Execute</MudButton>
                </MudItem>
            </MudGrid>
        </MudForm>
    }
    else
    {
        <MudAlert Class="mt-5" Severity="Severity.Warning">Please create a <MudLink Href="/admin/connected-systems/">Connected System</MudLink> first.</MudAlert>
    }
</MudPaper>

@if (_workerTaskHeaders.Count == 0)
{
    <MudPaper Outlined="true" Class="mt-5 pa-6 d-flex justify-center">
        <MudText Class="mud-text-secondary">There are no tasks queued.</MudText>
    </MudPaper>
}
else
{
    <div class="d-flex align-center gap-1 mt-5 mb-1">
        <MudIcon Icon="@Icons.Material.Filled.ArrowDownward" Size="Size.Small" Class="mud-text-secondary" />
        <MudText Typo="Typo.caption" Class="mud-text-secondary">Queue processes from top to bottom</MudText>
    </div>

    <MudTable T="WorkerTaskHeader" Items="@GetSortedQueueItems()" Hover="true" Breakpoint="Breakpoint.Sm"
              Outlined="true" Elevation="0" Dense="true" GroupBy="@_groupDefinition"
              Class="@(_hasProcessingTasks ? "jim-queue-table-active" : "")">
        <HeaderContent>
            <MudTh><MudText Typo="Typo.button">Name</MudText></MudTh>
            <MudTh><MudText Typo="Typo.button">Status</MudText></MudTh>
            <MudTh Style="min-width: 200px;"><MudText Typo="Typo.button">Progress</MudText></MudTh>
            <MudTh><MudText Typo="Typo.button">Initiated By</MudText></MudTh>
            <MudTh Style="text-align: right;"><MudText Typo="Typo.button">Actions</MudText></MudTh>
        </HeaderContent>
        <GroupHeaderTemplate>
            @{
                var groupTasks = context.Items.ToList();
                var isScheduleGroup = groupTasks.First().ScheduleExecutionId.HasValue;
            }
            @if (isScheduleGroup)
            {
                var scheduleName = groupTasks.First().ScheduleExecutionName ?? "Schedule";
                var totalTasks = groupTasks.Count;
                var processing = groupTasks.Count(t => t.Status == WorkerTaskStatus.Processing);
                var queued = groupTasks.Count(t => t.Status == WorkerTaskStatus.Queued);
                var waiting = groupTasks.Count(t => t.Status == WorkerTaskStatus.WaitingForPreviousStep);
                var distinctSteps = groupTasks.Select(t => t.ScheduleStepIndex).Distinct().Count();
                var executionId = groupTasks.First().ScheduleExecutionId!.Value;

                <MudTh Class="mud-table-cell-custom-group" colspan="5">
                    <div class="d-flex align-center justify-space-between" style="width: 100%;">
                        <div class="d-flex align-center gap-3">
                            <MudIcon Icon="@Icons.Material.Filled.Schedule" />
                            <div>
                                <MudText Typo="Typo.body1"><b>@scheduleName</b></MudText>
                                <MudText Typo="Typo.caption" Class="mud-text-secondary">
                                    @totalTasks tasks across @distinctSteps steps
                                    @if (processing > 0) { <span> — @processing processing</span> }
                                    @if (queued > 0) { <span>, @queued queued</span> }
                                    @if (waiting > 0) { <span>, @waiting waiting</span> }
                                </MudText>
                            </div>
                        </div>
                        <MudTooltip Text="Cancel Schedule" Arrow="true" Placement="Placement.Left">
                            <MudIconButton Icon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Error"
                                           OnClick="() => HandleCancelScheduleExecutionAsync(executionId)" Size="Size.Small" />
                        </MudTooltip>
                    </div>
                </MudTh>
            }
            else
            {
                <MudTh Class="jim-queue-standalone-group" colspan="5"></MudTh>
            }
        </GroupHeaderTemplate>
        <RowTemplate>
            <MudTd DataLabel="Name">
                @if (context.ScheduleExecutionId.HasValue)
                {
                    <MudText Typo="Typo.caption" Class="mud-text-secondary" Style="display: inline;">Step @((context.ScheduleStepIndex ?? 0) + 1) — </MudText>
                }
                @context.Name
            </MudTd>
            <MudTd DataLabel="Status">
                @GetTaskStatusDisplay(context)
            </MudTd>
            <MudTd DataLabel="Progress">
                @RenderProgress(context)
            </MudTd>
            <MudTd DataLabel="Initiated By">
                @RenderInitiatedBy(context)
            </MudTd>
            <MudTd DataLabel="Actions" Style="text-align: right;">
                @if (context.Status != WorkerTaskStatus.WaitingForPreviousStep)
                {
                    <MudTooltip Text="Cancel" Arrow="true" Placement="Placement.Left">
                        <MudIconButton Icon="@Icons.Material.Filled.Cancel" Variant="Variant.Filled" Color="Color.Error" OnClick="() => HandleCancelTaskAsync(context)" Size="Size.Small"/>
                    </MudTooltip>
                }
            </MudTd>
        </RowTemplate>
    </MudTable>

    @if (_hasProcessingTasks)
    {
        <div class="jim-worker-activity-bar">
            <div class="jim-worker-activity-shimmer"></div>
            <div class="jim-worker-activity-text">
                <MudIcon Icon="@Icons.Material.Filled.Memory" Size="Size.Small" />
                <span>Worker processing</span>
            </div>
        </div>
    }
}

@code {
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private List<ConnectedSystemHeader>? _connectedSystemHeaders;
    private List<ConnectedSystemRunProfile>? _connectedSystemRunProfiles;
    private ConnectedSystemHeader? _selectedConnectedSystemHeader;
    private ConnectedSystemRunProfile? _selectedConnectedSystemRunProfile;
    private List<WorkerTaskHeader> _workerTaskHeaders = new();
    private readonly CancellationTokenSource _pollingCancellationTokenSource = new();
    private bool _hasProcessingTasks;

    private readonly TableGroupDefinition<WorkerTaskHeader> _groupDefinition = new()
    {
        GroupName = "Queue Group",
        Selector = t => t.ScheduleExecutionId?.ToString() ?? $"standalone-{t.Id}"
    };

    private IEnumerable<WorkerTaskHeader> GetSortedQueueItems()
    {
        return _workerTaskHeaders
            .OrderBy(t => GetStatusSortOrder(t.Status))
            .ThenBy(t => t.ScheduleStepIndex ?? 0)
            .ThenBy(t => t.Timestamp);
    }

    private static int GetStatusSortOrder(WorkerTaskStatus status) => status switch
    {
        WorkerTaskStatus.Processing => 0,
        WorkerTaskStatus.CancellationRequested => 1,
        WorkerTaskStatus.Queued => 2,
        WorkerTaskStatus.WaitingForPreviousStep => 3,
        _ => 4
    };

    protected override async Task OnInitializedAsync()
    {
        _connectedSystemHeaders = await Jim.ConnectedSystems.GetConnectedSystemHeadersAsync();

        // In development, ?demo query string activates demo mode with mock data
        if (Environment.IsDevelopment())
        {
            var uri = new Uri(NavigationManager.Uri);
            var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
            if (query.ContainsKey("demo"))
            {
                _workerTaskHeaders = GenerateDemoData();
                _hasProcessingTasks = _workerTaskHeaders.Any(t => t.Status == WorkerTaskStatus.Processing);
                return;
            }
        }

        // Get initial data for worker task table rendering
        _workerTaskHeaders = await Jim.Tasking.GetWorkerTaskHeadersAsync();
        _hasProcessingTasks = _workerTaskHeaders.Any(t => t.Status == WorkerTaskStatus.Processing);

        // Setup polling for worker task header updates
        var token = _pollingCancellationTokenSource.Token;
        _ = Task.Run(async () =>
        {
            while (!token.IsCancellationRequested)
            {
                try
                {
                    var stateHasChanged = false;
                    var newWorkerTaskHeaders = await Jim.Tasking.GetWorkerTaskHeadersAsync();

                    // Look for additions or updates
                    foreach (var newWorkerTaskHeader in newWorkerTaskHeaders)
                    {
                        var workerTaskHeader = _workerTaskHeaders.SingleOrDefault(q => q.Id == newWorkerTaskHeader.Id);
                        if (workerTaskHeader == null)
                        {
                            _workerTaskHeaders.Add(newWorkerTaskHeader);
                            stateHasChanged = true;
                        }
                        else if (HasWorkerTaskHeaderChanged(workerTaskHeader, newWorkerTaskHeader))
                        {
                            var position = _workerTaskHeaders.IndexOf(workerTaskHeader);
                            _workerTaskHeaders.Remove(workerTaskHeader);
                            _workerTaskHeaders.Insert(position, newWorkerTaskHeader);
                            stateHasChanged = true;
                        }
                    }

                    // Look for removals
                    var workerTaskHeadersToRemove = _workerTaskHeaders.Where(sth => newWorkerTaskHeaders.All(sth2 => sth2.Id != sth.Id)).ToList();
                    foreach (var workerTaskHeaderToRemove in workerTaskHeadersToRemove)
                    {
                        _workerTaskHeaders.Remove(workerTaskHeaderToRemove);
                        stateHasChanged = true;
                    }

                    if (stateHasChanged)
                    {
                        _hasProcessingTasks = _workerTaskHeaders.Any(t => t.Status == WorkerTaskStatus.Processing);
                        await InvokeAsync(StateHasChanged);
                    }

                    // Use a reasonable polling interval (1 second for queue updates)
                    await Task.Delay(TimeSpan.FromSeconds(1), token);
                }
                catch (TaskCanceledException)
                {
                    break;
                }
                catch
                {
                    // Ignore errors during polling, will retry on next interval
                    await Task.Delay(TimeSpan.FromSeconds(1), token);
                }
            }
        }, token);
    }

    void IDisposable.Dispose()
    {
        _pollingCancellationTokenSource.Cancel();
    }

    private async Task HandleConnectedSystemHeaderChangedAsync(ConnectedSystemHeader connectedSystemHeader)
    {
        _selectedConnectedSystemHeader = connectedSystemHeader;
        _connectedSystemRunProfiles = await Jim.ConnectedSystems.GetConnectedSystemRunProfilesAsync(connectedSystemHeader.Id);
    }

    private async Task HandleExecuteRunProfileSubmitAsync()
    {
        if (_selectedConnectedSystemHeader == null || _selectedConnectedSystemRunProfile == null)
            return;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        var task = SynchronisationWorkerTask.ForUser(_selectedConnectedSystemHeader.Id, _selectedConnectedSystemRunProfile.Id, user.Id, user.DisplayName ?? "Unknown User");
        var result = await Jim.Tasking.CreateWorkerTaskAsync(task);

        if (!result.Success)
        {
            Snackbar.Add(result.ErrorMessage ?? "Failed to create task.", Severity.Error);
            return;
        }

        foreach (var warning in result.Warnings)
        {
            Snackbar.Add(warning, Severity.Warning);
        }

        Snackbar.Add("Synchronisation task added.", Severity.Success);
    }

    private async Task HandleCancelTaskAsync(WorkerTaskHeader workerTaskHeader)
    {
        if (workerTaskHeader == null)
            return;

        var result = await DialogService.ShowMessageBox(
            "Cancel Task",
            $"Are you sure you want to cancel the task '{workerTaskHeader.Name}'?",
            yesText: "Cancel Task",
            cancelText: "Keep Running");

        if (result != true)
            return;

        await Jim.Tasking.CancelWorkerTaskAsync(workerTaskHeader.Id);
        Snackbar.Add("Worker task cancellation requested.", Severity.Success);
    }

    private async Task HandleCancelScheduleExecutionAsync(Guid scheduleExecutionId)
    {
        var scheduleName = _workerTaskHeaders
            .Where(t => t.ScheduleExecutionId == scheduleExecutionId)
            .Select(t => t.ScheduleExecutionName)
            .FirstOrDefault() ?? "this schedule execution";

        var result = await DialogService.ShowMessageBox(
            "Cancel Schedule Execution",
            $"Are you sure you want to cancel '{scheduleName}'? All pending and waiting steps will be cancelled.",
            yesText: "Cancel Execution",
            cancelText: "Keep Running");

        if (result != true)
            return;

        var cancelled = await Jim.Scheduler.CancelScheduleExecutionAsync(scheduleExecutionId);
        if (cancelled)
        {
            Snackbar.Add("Schedule execution cancellation requested.", Severity.Success);
        }
        else
        {
            Snackbar.Add("Could not cancel execution — it may have already completed.", Severity.Warning);
        }
    }

    private static string GetTaskStatusDisplay(WorkerTaskHeader task)
    {
        return task.Status switch
        {
            WorkerTaskStatus.WaitingForPreviousStep => "Waiting",
            _ => task.Status.ToString().SplitOnCapitalLetters()
        };
    }

    private static RenderFragment RenderProgress(WorkerTaskHeader context) => __builder =>
    {
        if (context.Status == WorkerTaskStatus.Processing)
        {
            if (context.ObjectsToProcess > 0)
            {
                var percentage = (double)context.ObjectsProcessed!.Value / context.ObjectsToProcess.Value * 100;
                <MudProgressLinear Value="@percentage" Color="Color.Primary" Rounded="true" />
                <MudText Typo="Typo.caption" Class="mt-2">@context.ObjectsProcessed.Value.ToString("N0") / @context.ObjectsToProcess.Value.ToString("N0")@(!string.IsNullOrEmpty(context.ProgressMessage) ? $" - {context.ProgressMessage}" : "")</MudText>
            }
            else
            {
                <MudProgressLinear Indeterminate="true" Color="Color.Primary" Rounded="true" />
                if (!string.IsNullOrEmpty(context.ProgressMessage))
                {
                    <MudText Typo="Typo.caption" Class="mud-text-secondary">@context.ProgressMessage</MudText>
                }
            }
        }
        else if (context.Status == WorkerTaskStatus.Queued)
        {
            <MudText Typo="Typo.caption" Class="mud-text-secondary">Waiting...</MudText>
        }
        else if (context.Status == WorkerTaskStatus.WaitingForPreviousStep)
        {
            <MudText Typo="Typo.caption" Class="mud-text-secondary">Waiting for previous step...</MudText>
        }
    };

    private static RenderFragment RenderInitiatedBy(WorkerTaskHeader context) => __builder =>
    {
        if (context.InitiatedByType == JIM.Models.Activities.ActivityInitiatorType.User && context.InitiatedById != null)
        {
            <MudIcon Icon="@Icons.Material.Filled.Person" Class="mr-1" Style="vertical-align: middle;" />
            <span>@context.InitiatedByName</span>
        }
        else if (context.InitiatedByType == JIM.Models.Activities.ActivityInitiatorType.ApiKey)
        {
            <MudIcon Icon="@Icons.Material.Filled.Key" Class="mr-1" Style="vertical-align: middle;" />
            <span>@context.InitiatedByName</span>
        }
        else if (context.InitiatedByType == JIM.Models.Activities.ActivityInitiatorType.System)
        {
            <MudIcon Icon="@Icons.Material.Filled.Schedule" Class="mr-1" Style="vertical-align: middle;" />
            <span>@(context.InitiatedByName ?? "Scheduler")</span>
        }
        else if (!string.IsNullOrEmpty(context.InitiatedByName))
        {
            <span>@context.InitiatedByName</span>
        }
    };

    private static List<WorkerTaskHeader> GenerateDemoData()
    {
        var executionId1 = Guid.NewGuid();
        var executionId2 = Guid.NewGuid();
        var now = DateTime.UtcNow;

        return new List<WorkerTaskHeader>
        {
            // Schedule 1: "Nightly Full Sync" — 6 steps, currently on step 2 (parallel)
            new()
            {
                Id = Guid.NewGuid(), Name = "HR System - Full Import", Type = "Synchronisation",
                Status = WorkerTaskStatus.Processing, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 1,
                ObjectsToProcess = 12500, ObjectsProcessed = 8320,
                ProgressMessage = "Importing users",
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "AD - Full Import", Type = "Synchronisation",
                Status = WorkerTaskStatus.Processing, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 1,
                ObjectsToProcess = 45000, ObjectsProcessed = 31200,
                ProgressMessage = "Importing objects",
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "HR System - Delta Sync", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 2,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "AD - Delta Sync", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 2,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "AD - Export", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 3,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "AD - Confirming Import", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-5),
                ScheduleExecutionId = executionId1, ScheduleExecutionName = "Nightly Full Sync",
                ScheduleStepIndex = 4,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },

            // Schedule 2: "Cloud Provisioning" — 3 steps, step 0 queued
            new()
            {
                Id = Guid.NewGuid(), Name = "Azure AD - Export", Type = "Synchronisation",
                Status = WorkerTaskStatus.Queued, Timestamp = now.AddMinutes(-1),
                ScheduleExecutionId = executionId2, ScheduleExecutionName = "Cloud Provisioning",
                ScheduleStepIndex = 0,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "Azure AD - Confirming Import", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-1),
                ScheduleExecutionId = executionId2, ScheduleExecutionName = "Cloud Provisioning",
                ScheduleStepIndex = 1,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },
            new()
            {
                Id = Guid.NewGuid(), Name = "Azure AD - Delta Sync", Type = "Synchronisation",
                Status = WorkerTaskStatus.WaitingForPreviousStep, Timestamp = now.AddMinutes(-1),
                ScheduleExecutionId = executionId2, ScheduleExecutionName = "Cloud Provisioning",
                ScheduleStepIndex = 2,
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.System
            },

            // Standalone task — manually triggered by user
            new()
            {
                Id = Guid.NewGuid(), Name = "LDAP Directory - Full Import", Type = "Synchronisation",
                Status = WorkerTaskStatus.Queued, Timestamp = now.AddSeconds(-30),
                InitiatedByType = JIM.Models.Activities.ActivityInitiatorType.User,
                InitiatedById = Guid.NewGuid(), InitiatedByName = "Admin User"
            }
        };
    }

    private static bool HasWorkerTaskHeaderChanged(WorkerTaskHeader existing, WorkerTaskHeader updated)
    {
        return existing.Status != updated.Status ||
               existing.ObjectsProcessed != updated.ObjectsProcessed ||
               existing.ObjectsToProcess != updated.ObjectsToProcess ||
               existing.ProgressMessage != updated.ProgressMessage;
    }
}
