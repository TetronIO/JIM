@using JIM.Application
@using JIM.Models.Activities
@using JIM.Models.Scheduling
@using JIM.Models.Utility
@using JIM.Utilities
@using JIM.Web.Services
@inject JimApplication Jim
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject IUserPreferenceService PreferenceService

@if (_preferencesLoaded)
{
    <MudTable @ref="_table" T="Schedule" ServerData="ServerReload"
              RowsPerPage="@_rowsPerPage" RowsPerPageChanged="OnRowsPerPageChanged"
              Hover="true" Dense="true" Breakpoint="Breakpoint.Sm"
              Outlined="true" Elevation="0" OnRowClick="HandleRowClick" RowClass="cursor-pointer"
              Loading="@_loading" LoadingProgressColor="Color.Primary">
        <ToolBarContent>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" DropShadow="false"
                       StartIcon="@Icons.Material.Filled.Add" OnClick="HandleCreateScheduleAsync">
                New Schedule
            </MudButton>
            <MudSpacer />
            <MudTextField T="string" ValueChanged="@(s => OnSearch(s))" Placeholder="Search..."
                          Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search"
                          IconSize="Size.Medium" Class="mt-0" Style="max-width: 300px;" />
        </ToolBarContent>
        <HeaderContent>
            <MudTh>
                <MudTableSortLabel SortLabel="name" T="Schedule">
                    <MudText Typo="Typo.button">Name</MudText>
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudText Typo="Typo.button">Steps</MudText>
            </MudTh>
            <MudTh>
                <MudText Typo="Typo.button">Trigger</MudText>
            </MudTh>
            <MudTh>
                <MudTableSortLabel SortLabel="nextruntime" T="Schedule">
                    <MudText Typo="Typo.button">Next Run</MudText>
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudTableSortLabel SortLabel="lastruntime" T="Schedule">
                    <MudText Typo="Typo.button">Last Run</MudText>
                </MudTableSortLabel>
            </MudTh>
            <MudTh>
                <MudText Typo="Typo.button">Status</MudText>
            </MudTh>
            <MudTh Style="text-align: right;">
                <MudText Typo="Typo.button">Actions</MudText>
            </MudTh>
        </HeaderContent>
        <RowTemplate Context="context">
            <MudTd DataLabel="Name">
                <MudText Typo="Typo.body2">@context.Name</MudText>
                @if (!string.IsNullOrEmpty(context.Description))
                {
                    <MudText Typo="Typo.caption" Class="mud-text-secondary">@context.Description</MudText>
                }
            </MudTd>
            <MudTd DataLabel="Steps">
                <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Default">
                    @context.Steps.Count step@(context.Steps.Count != 1 ? "s" : "")
                </MudChip>
            </MudTd>
            <MudTd DataLabel="Trigger">
                @if (context.TriggerType == ScheduleTriggerType.Cron)
                {
                    <MudTooltip Text="@context.CronExpression" Arrow="true" Placement="Placement.Top">
                        <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Info"
                                 Icon="@Icons.Material.Filled.Schedule">
                            @GetCronDescription(context.CronExpression)
                        </MudChip>
                    </MudTooltip>
                }
                else
                {
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Default"
                             Icon="@Icons.Material.Filled.TouchApp">
                        Manual
                    </MudChip>
                }
            </MudTd>
            <MudTd DataLabel="Next Run">
                @if (context.NextRunTime.HasValue && context.IsEnabled && context.TriggerType == ScheduleTriggerType.Cron)
                {
                    <MudTooltip Text="@context.NextRunTime.Value.ToLocalTime().ToFriendlyDate()" Arrow="true" Placement="Placement.Top">
                        @context.NextRunTime.Value.ToLocalTime().ToRelativeTime()
                    </MudTooltip>
                }
                else
                {
                    <MudText Typo="Typo.body2" Class="mud-text-disabled">-</MudText>
                }
            </MudTd>
            <MudTd DataLabel="Last Run">
                @if (context.LastRunTime.HasValue)
                {
                    <MudTooltip Text="@context.LastRunTime.Value.ToLocalTime().ToFriendlyDate()" Arrow="true" Placement="Placement.Top">
                        @context.LastRunTime.Value.ToLocalTime().ToRelativeTime()
                    </MudTooltip>
                }
                else
                {
                    <MudText Typo="Typo.body2" Class="mud-text-disabled">Never</MudText>
                }
            </MudTd>
            <MudTd DataLabel="Status">
                @if (context.IsEnabled)
                {
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Success">
                        Enabled
                    </MudChip>
                }
                else
                {
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Default">
                        Disabled
                    </MudChip>
                }
            </MudTd>
            <MudTd DataLabel="Actions" Style="text-align: right;" @onclick:stopPropagation="true">
                <MudStack Row="true" Spacing="1" Justify="Justify.FlexEnd">
                    @if (context.IsEnabled)
                    {
                        <MudTooltip Text="Disable" Arrow="true" Placement="Placement.Top">
                            <MudIconButton Icon="@Icons.Material.Outlined.Pause" Size="Size.Small"
                                           OnClick="@(() => HandleToggleEnabledAsync(context))" />
                        </MudTooltip>
                    }
                    else
                    {
                        <MudTooltip Text="Enable" Arrow="true" Placement="Placement.Top">
                            <MudIconButton Icon="@Icons.Material.Outlined.PlayArrow" Size="Size.Small"
                                           OnClick="@(() => HandleToggleEnabledAsync(context))" />
                        </MudTooltip>
                    }
                    <MudTooltip Text="Run Now" Arrow="true" Placement="Placement.Top">
                        <MudIconButton Icon="@Icons.Material.Outlined.PlayCircle" Size="Size.Small" Color="Color.Primary"
                                       OnClick="@(() => HandleRunNowAsync(context))"
                                       Disabled="@(context.Steps.Count == 0)" />
                    </MudTooltip>
                    <MudTooltip Text="Delete" Arrow="true" Placement="Placement.Top">
                        <MudIconButton Icon="@Icons.Material.Outlined.Delete" Size="Size.Small" Color="Color.Error"
                                       OnClick="@(() => HandleDeleteAsync(context))" />
                    </MudTooltip>
                </MudStack>
            </MudTd>
        </RowTemplate>
        <NoRecordsContent>
            <MudStack AlignItems="AlignItems.Center" Class="pa-8">
                <MudIcon Icon="@Icons.Material.Outlined.Schedule" Size="Size.Large" Class="mud-text-disabled" />
                <MudText Typo="Typo.body1" Class="mud-text-secondary">No schedules have been created yet.</MudText>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" DropShadow="false"
                           StartIcon="@Icons.Material.Filled.Add" OnClick="HandleCreateScheduleAsync" Class="mt-2">
                    Create Your First Schedule
                </MudButton>
            </MudStack>
        </NoRecordsContent>
        <PagerContent>
            <MudTablePager />
        </PagerContent>
    </MudTable>
}

@code {
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private MudTable<Schedule>? _table;
    private string _searchString = "";
    private bool _loading;
    private int _rowsPerPage = 10;
    private bool _preferencesLoaded;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_preferencesLoaded)
        {
            try
            {
                var preferredSize = await PreferenceService.GetRowsPerPageAsync();
                _rowsPerPage = preferredSize;
                _preferencesLoaded = true;
                StateHasChanged();
            }
            catch
            {
                // JS interop not yet available, will retry on next render
            }
        }
    }

    private async Task OnRowsPerPageChanged(int newSize)
    {
        _rowsPerPage = newSize;
        await PreferenceService.SetRowsPerPageAsync(newSize);
    }

    private async Task<TableData<Schedule>> ServerReload(TableState state, CancellationToken token)
    {
        _loading = true;
        StateHasChanged();

        try
        {
            var page = state.Page + 1;
            var sortDescending = state.SortDirection == SortDirection.Descending;

            var result = await Jim.Scheduler.GetSchedulesAsync(
                page,
                state.PageSize,
                string.IsNullOrWhiteSpace(_searchString) ? null : _searchString,
                state.SortLabel,
                sortDescending);

            return new TableData<Schedule>
            {
                TotalItems = result.TotalResults,
                Items = result.Results
            };
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    private void OnSearch(string text)
    {
        _searchString = text;
        _table?.ReloadServerData();
    }

    private async Task HandleRowClick(TableRowClickEventArgs<Schedule> args)
    {
        if (_loading || args.Item == null)
            return;

        await OpenScheduleEditorAsync(args.Item.Id);
    }

    private async Task HandleCreateScheduleAsync()
    {
        await OpenScheduleEditorAsync(null);
    }

    private async Task OpenScheduleEditorAsync(Guid? scheduleId)
    {
        var parameters = new DialogParameters<ScheduleEditorDialog>
        {
            { x => x.ScheduleId, scheduleId }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Medium,
            FullWidth = true,
            CloseOnEscapeKey = true,
            NoHeader = false
        };

        var dialog = await DialogService.ShowAsync<ScheduleEditorDialog>(
            scheduleId.HasValue ? "Edit Schedule" : "New Schedule",
            parameters,
            options);

        var result = await dialog.Result;
        if (result is { Canceled: false })
        {
            _table?.ReloadServerData();
        }
    }

    private async Task HandleToggleEnabledAsync(Schedule schedule)
    {
        schedule.IsEnabled = !schedule.IsEnabled;

        // Update audit info
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        schedule.LastUpdated = DateTime.UtcNow;
        schedule.LastUpdatedByType = ActivityInitiatorType.User;
        schedule.LastUpdatedById = user.Id;
        schedule.LastUpdatedByName = user.DisplayName;

        await Jim.Scheduler.UpdateScheduleAsync(schedule);

        var action = schedule.IsEnabled ? "enabled" : "disabled";
        Snackbar.Add($"Schedule '{schedule.Name}' has been {action}.", Severity.Success);

        _table?.ReloadServerData();
    }

    private async Task HandleRunNowAsync(Schedule schedule)
    {
        if (schedule.Steps.Count == 0)
        {
            Snackbar.Add("Cannot run a schedule with no steps.", Severity.Warning);
            return;
        }

        var confirmed = await DialogService.ShowMessageBox(
            "Run Schedule Now",
            $"Are you sure you want to run '{schedule.Name}' now? This will queue all steps for execution.",
            yesText: "Run Now",
            cancelText: "Cancel");

        if (confirmed != true)
            return;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        // Load schedule with steps for execution
        var scheduleWithSteps = await Jim.Scheduler.GetScheduleWithStepsAsync(schedule.Id);
        if (scheduleWithSteps == null)
        {
            Snackbar.Add("Schedule not found.", Severity.Error);
            return;
        }

        var execution = await Jim.Scheduler.StartScheduleExecutionAsync(
            scheduleWithSteps,
            ActivityInitiatorType.User,
            user.Id,
            user.DisplayName);

        if (execution != null)
        {
            Snackbar.Add($"Schedule '{schedule.Name}' has been queued for execution.", Severity.Success);
        }
        else
        {
            Snackbar.Add($"Failed to start schedule '{schedule.Name}'. It may have no steps.", Severity.Warning);
        }

        _table?.ReloadServerData();
    }

    private async Task HandleDeleteAsync(Schedule schedule)
    {
        var confirmed = await DialogService.ShowMessageBox(
            "Delete Schedule",
            $"Are you sure you want to delete '{schedule.Name}'? This action cannot be undone.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirmed != true)
            return;

        await Jim.Scheduler.DeleteScheduleAsync(schedule);
        Snackbar.Add($"Schedule '{schedule.Name}' has been deleted.", Severity.Success);
        _table?.ReloadServerData();
    }

    /// <summary>
    /// Converts a cron expression to a human-readable description.
    /// This is a simplified version; in future, we'll use a proper cron description library.
    /// </summary>
    private static string GetCronDescription(string? cronExpression)
    {
        if (string.IsNullOrWhiteSpace(cronExpression))
            return "Not configured";

        // Parse common patterns for display
        var parts = cronExpression.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length < 5)
            return cronExpression;

        var minute = parts[0];
        var hour = parts[1];
        var dayOfMonth = parts[2];
        var month = parts[3];
        var dayOfWeek = parts[4];

        // Daily at specific time
        if (dayOfMonth == "*" && month == "*" && dayOfWeek == "*")
        {
            return $"Daily at {FormatTime(hour, minute)}";
        }

        // Weekdays only
        if (dayOfMonth == "*" && month == "*" && (dayOfWeek == "1-5" || dayOfWeek == "MON-FRI"))
        {
            return $"Weekdays at {FormatTime(hour, minute)}";
        }

        // Weekends only
        if (dayOfMonth == "*" && month == "*" && (dayOfWeek == "0,6" || dayOfWeek == "SAT,SUN"))
        {
            return $"Weekends at {FormatTime(hour, minute)}";
        }

        // Specific day of week
        if (dayOfMonth == "*" && month == "*" && int.TryParse(dayOfWeek, out var dow))
        {
            var dayName = dow switch
            {
                0 => "Sunday",
                1 => "Monday",
                2 => "Tuesday",
                3 => "Wednesday",
                4 => "Thursday",
                5 => "Friday",
                6 => "Saturday",
                _ => "Unknown"
            };
            return $"{dayName}s at {FormatTime(hour, minute)}";
        }

        // Hourly
        if (hour == "*" && dayOfMonth == "*" && month == "*" && dayOfWeek == "*")
        {
            return minute == "0" ? "Hourly" : $"Hourly at :{minute.PadLeft(2, '0')}";
        }

        // Every N minutes
        if (minute.StartsWith("*/") && hour == "*")
        {
            var interval = minute[2..];
            return $"Every {interval} minutes";
        }

        // Every N hours
        if (hour.StartsWith("*/") && minute == "0")
        {
            var interval = hour[2..];
            return $"Every {interval} hours";
        }

        // Default: show abbreviated cron
        return cronExpression;
    }

    private static string FormatTime(string hour, string minute)
    {
        if (!int.TryParse(hour, out var h) || !int.TryParse(minute, out var m))
            return $"{hour}:{minute}";

        var period = h >= 12 ? "PM" : "AM";
        var displayHour = h > 12 ? h - 12 : (h == 0 ? 12 : h);
        return $"{displayHour}:{m:D2} {period}";
    }
}
