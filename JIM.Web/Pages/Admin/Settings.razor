@page "/admin/settings"
@attribute [Authorize(Roles = "Administrator")]
@using JIM.Application
@using JIM.Application.Services
@using JIM.Models.Core
@using JIM.Web
@inject JimApplication Jim
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ICredentialProtectionService CredentialProtection

<PageTitle>Service Settings</PageTitle>
<MudText Typo="Typo.h4">Service Settings</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>
<MudText Typo="Typo.subtitle1" Class="mud-text-secondary">
    Configure service-wide settings. Read-only settings are defined by environment variables and cannot be modified here.
</MudText>

<MudTable Items="@_filteredSettings" Hover="true" Dense="true" Breakpoint="Breakpoint.Sm" Class="mt-5 mb-5" SortLabel="Sort By"
    Filter="new Func<ServiceSetting, bool>(FilterFunc)" Outlined="true" Elevation="0" Loading="@_loading"
    GroupBy="@_groupDefinition">
    <ToolBarContent>
        <MudText Typo="Typo.h6">Settings</MudText>
        <MudSpacer />
        <MudCheckBox @bind-Value="_showConfigurableOnly" @bind-Value:after="UpdateFilteredSettings" Label="Show configurable only" Color="Color.Primary" Class="mr-4" />
        <MudCheckBox @bind-Value="_showOverriddenOnly" @bind-Value:after="UpdateFilteredSettings" Label="Show overridden only" Color="Color.Primary" Class="mr-4" />
        <MudTextField @bind-Value="_searchString" Variant="Variant.Outlined" Placeholder="Search" Margin="Margin.Dense" Adornment="Adornment.Start"
            AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0" Immediate="true"></MudTextField>
    </ToolBarContent>
    <ColGroup>
        <col />
        <col style="width: 300px;" />
        <col style="width: 150px;" />
        <col style="width: 120px;" />
    </ColGroup>
    <HeaderContent>
        <MudTh>
            <MudTableSortLabel SortBy="new Func<ServiceSetting, object>(x => x.DisplayName)">
                <MudText Typo="Typo.button">Setting</MudText>
            </MudTableSortLabel>
        </MudTh>
        <MudTh>
            <MudText Typo="Typo.button">Value</MudText>
        </MudTh>
        <MudTh>
            <MudText Typo="Typo.button">Status</MudText>
        </MudTh>
        <MudTh Style="text-align: right;">
            <MudText Typo="Typo.button">Actions</MudText>
        </MudTh>
    </HeaderContent>
    <GroupHeaderTemplate>
        <MudTh Class="mud-table-cell-custom-group" colspan="4">
            <MudIconButton Icon="@(IsGroupExpanded(context.Key) ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore)"
                OnClick="@((e) => ToggleGroupExpanded(context.Key))" Class="ms-n2" />
            <MudText Typo="Typo.button">@GetCategoryDisplayName(context.Key)</MudText>
        </MudTh>
    </GroupHeaderTemplate>
    <RowTemplate Context="settingContext">
        @if (IsGroupExpanded(settingContext.Category.ToString()))
        {
            <MudTd DataLabel="Setting" Class="@GetRowClass(settingContext)">
                <MudText Typo="Typo.body1">@settingContext.DisplayName</MudText>
                @if (!string.IsNullOrEmpty(settingContext.Description))
                {
                    <MudText Typo="Typo.body2" Class="mud-text-secondary">@settingContext.Description</MudText>
                }
            </MudTd>
            <MudTd DataLabel="Value" Class="@GetRowClass(settingContext)">
                @if (settingContext.ValueType == ServiceSettingValueType.StringEncrypted)
                {
                    @if (_revealedSecrets.Contains(settingContext.Key) && _decryptedCache.TryGetValue(settingContext.Key, out var decrypted))
                    {
                        <span class="jim-text-code">@(decrypted.Value ?? "(not set)")</span>
                        <MudIconButton Icon="@Icons.Material.Outlined.VisibilityOff" Variant="Variant.Filled" Size="Size.Small" OnClick="() => HideSecret(settingContext.Key)" />
                    }
                    else
                    {
                        <span class="jim-text-code">********</span>
                        <MudIconButton Icon="@Icons.Material.Outlined.Visibility" Variant="Variant.Filled" Size="Size.Small" OnClick="() => RevealSecretAsync(settingContext.Key)" />
                    }
                }
                else
                {
                    <span class="jim-text-code">@(settingContext.GetEffectiveValue() ?? "(not set)")</span>
                }
            </MudTd>
            <MudTd DataLabel="Status" Class="@GetRowClass(settingContext)">
                @if (settingContext.IsReadOnly)
                {
                    <MudChip T="string" Variant="Variant.Text" Color="Color.Default" Icon="@Icons.Material.Filled.Lock">Read-only</MudChip>
                }
                else if (settingContext.IsOverridden)
                {
                    <MudTooltip Arrow="true" Placement="Placement.Top">
                        <TooltipContent>
                            @if (settingContext.LastUpdated.HasValue)
                            {
                                <MudText Typo="Typo.caption">Modified @settingContext.LastUpdated.Value.ToLocalTime().ToFriendlyDate()</MudText>
                                @if (settingContext.LastUpdatedByName != null)
                                {
                                    <MudText Typo="Typo.caption">by @settingContext.LastUpdatedByName</MudText>
                                }
                            }
                        </TooltipContent>
                        <ChildContent>
                            <MudChip T="string" Variant="Variant.Text" Color="Color.Primary" Icon="@Icons.Material.Filled.Edit">Modified</MudChip>
                        </ChildContent>
                    </MudTooltip>
                }
                else
                {
                    <MudChip T="string" Variant="Variant.Text" Color="Color.Default" Icon="@Icons.Material.Filled.Check">Default</MudChip>
                }
            </MudTd>
            <MudTd DataLabel="Actions" Class="@GetRowClass(settingContext)">
                <div class="d-flex justify-end gap-2">
                    @if (!settingContext.IsReadOnly)
                    {
                        <MudTooltip Text="Edit" Arrow="true" Placement="Placement.Top">
                            <MudIconButton Icon="@Icons.Material.Outlined.Edit" Variant="Variant.Filled" Size="Size.Small" OnClick="_ => ShowEditDialog(settingContext)" />
                        </MudTooltip>
                        @if (settingContext.IsOverridden)
                        {
                            <MudTooltip Text="Revert to Default" Arrow="true" Placement="Placement.Top">
                                <MudIconButton Icon="@Icons.Material.Outlined.RestartAlt" Variant="Variant.Filled" Size="Size.Small" OnClick="_ => HandleRevertAsync(settingContext)" />
                            </MudTooltip>
                        }
                    }
                </div>
            </MudTd>
        }
    </RowTemplate>
    <NoRecordsContent>
        <MudText>No settings found.</MudText>
    </NoRecordsContent>
</MudTable>

@code {
    private List<ServiceSetting> _settings = new();
    private List<ServiceSetting> _filteredSettings = new();
    private string _searchString = string.Empty;
    private bool _showConfigurableOnly;
    private bool _showOverriddenOnly;
    private bool _loading = true;
    private HashSet<string> _revealedSecrets = new();
    private Dictionary<string, (string? Value, bool Error)> _decryptedCache = new();
    private HashSet<object> _expandedGroups = new();

    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private readonly List<BreadcrumbItem> _breadcrumbs =
    [
        new("Home", href: "/", icon: Icons.Material.Filled.Home),
        new("Service Settings", href: null, disabled: true)
    ];

    private TableGroupDefinition<ServiceSetting> _groupDefinition = new()
    {
        GroupName = "Category",
        Selector = (e) => e.Category.ToString()
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadSettingsAsync();
        InitializeExpandedGroups();
    }

    private async Task LoadSettingsAsync()
    {
        _loading = true;
        _settings = await Jim.ServiceSettings.GetAllSettingsAsync();
        _decryptedCache.Clear();
        _revealedSecrets.Clear();
        UpdateFilteredSettings();
        _loading = false;
    }

    private void InitializeExpandedGroups()
    {
        // Expand all categories by default
        foreach (var setting in _settings)
        {
            _expandedGroups.Add(setting.Category.ToString());
        }
    }

    private void UpdateFilteredSettings()
    {
        _filteredSettings = _settings
            .Where(s => !_showConfigurableOnly || !s.IsReadOnly)
            .Where(s => !_showOverriddenOnly || (s.IsOverridden && !s.IsReadOnly))
            .Where(s => FilterFunc(s))
            .ToList();
    }

    private bool FilterFunc(ServiceSetting setting)
    {
        if (string.IsNullOrWhiteSpace(_searchString))
            return true;
        if (setting.DisplayName.Contains(_searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        if (setting.Description?.Contains(_searchString, StringComparison.OrdinalIgnoreCase) == true)
            return true;
        if (setting.Key.Contains(_searchString, StringComparison.OrdinalIgnoreCase))
            return true;
        return false;
    }

    private string GetCategoryDisplayName(object? categoryValue)
    {
        var categoryString = categoryValue?.ToString();
        return categoryString switch
        {
            "SSO" => "Single Sign-On (SSO)",
            "Synchronisation" => "Synchronisation",
            "Maintenance" => "Maintenance",
            "History" => "History",
            "Security" => "Security",
            _ => categoryString ?? "Unknown"
        };
    }

    private string GetRowClass(ServiceSetting setting)
    {
        return setting.IsReadOnly ? "jim-readonly-row" : "";
    }

    private bool IsGroupExpanded(object? groupKey)
    {
        return _expandedGroups.Contains(groupKey!);
    }

    private void ToggleGroupExpanded(object? groupKey)
    {
        if (groupKey == null)
            return;

        if (_expandedGroups.Contains(groupKey))
            _expandedGroups.Remove(groupKey);
        else
            _expandedGroups.Add(groupKey);
    }

    private async Task RevealSecretAsync(string key)
    {
        var setting = _settings.FirstOrDefault(s => s.Key == key);
        if (setting == null)
            return;

        var result = GetDecryptedValue(setting);
        if (result.Error)
        {
            await DialogService.ShowMessageBox(
                "Decryption Failed",
                "Unable to decrypt this value. The encryption key may have changed or been deleted (e.g. after a environment reset). Edit and re-save this setting to re-encrypt it with the current key.",
                yesText: "OK");
            return;
        }

        _decryptedCache[key] = result;
        _revealedSecrets.Add(key);
    }

    private void HideSecret(string key)
    {
        _revealedSecrets.Remove(key);
        _decryptedCache.Remove(key);
    }

    private (string? Value, bool Error) GetDecryptedValue(ServiceSetting setting)
    {
        var effectiveValue = setting.GetEffectiveValue();
        if (string.IsNullOrEmpty(effectiveValue))
            return (null, false);

        try
        {
            return (CredentialProtection.Unprotect(effectiveValue), false);
        }
        catch (System.Security.Cryptography.CryptographicException)
        {
            return (null, true);
        }
    }

    private async Task ShowEditDialog(ServiceSetting setting)
    {
        var parameters = new DialogParameters<EditSettingDialog>
        {
            { x => x.Setting, setting }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<EditSettingDialog>($"Edit {setting.DisplayName}", parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: string newValue })
        {
            try
            {
                var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
                await Jim.ServiceSettings.UpdateSettingValueAsync(setting.Key, newValue, user);
                await LoadSettingsAsync();
                Snackbar.Add($"Setting '{setting.DisplayName}' updated.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to update setting: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task HandleRevertAsync(ServiceSetting setting)
    {
        var confirm = await DialogService.ShowMessageBox(
            "Revert to Default",
            $"Are you sure you want to revert '{setting.DisplayName}' to its default value?",
            yesText: "Revert", cancelText: "Cancel");

        if (confirm == true)
        {
            try
            {
                var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
                await Jim.ServiceSettings.RevertSettingToDefaultAsync(setting.Key, user);
                await LoadSettingsAsync();
                Snackbar.Add($"Setting '{setting.DisplayName}' reverted to default.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to revert setting: {ex.Message}", Severity.Error);
            }
        }
    }
}
