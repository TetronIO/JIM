@page "/admin/connected-systems/{Id:int}"
@attribute [Authorize(Roles = "Administrator")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Exceptions
@using JIM.Models.Logic
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Utilities
@using JIM.Web.Shared
@using Serilog
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<PageTitle>Connected System: @_connectedSystem?.Name</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Connected System:</span> @_connectedSystem?.Name</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>
<MudText Typo="Typo.subtitle1" Class="mud-text-secondary">Some aspects of a Connected System can only be configured once basic details and setting values have been provided.</MudText>

@if (_connectedSystem != null)
{
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="false" PanelClass="pt-5" Class="mt-5" Outlined="true">

        <MudTabPanel Text="Details">
            <MudPaper Class="pa-4" Outlined="true">
                <MudForm @bind-IsValid="@IsDetailsFormValid" @bind-Errors="@DetailsFormErrors">
                    <MudTextField T="string" Label="Connector" @bind-Value="_connectedSystem.ConnectorDefinition.Name" Disabled="true" Variant="Variant.Outlined" />
                    <MudTextField T="string" Label="Name" @bind-Value="_connectedSystem.Name" Required="true" RequiredError="A name is required" Variant="Variant.Outlined" Class="mt-5" />
                    <MudTextField T="string" Label="Description" Required="false" @bind-Value="_connectedSystem.Description" Lines="5" Variant="Variant.Outlined" Class="mt-5" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsDetailsFormValid)" Class="mt-5" OnClick="HandleValidDetailsSubmitAsync" DropShadow="false">Save Changes</MudButton>
                </MudForm>
            </MudPaper>

            <MudPaper Class="pa-4 mt-5" Outlined="true">
                <MudText Typo="Typo.h6">Quick Links</MudText>
                <MudGrid Class="mt-3">
                    <MudItem xs="12" sm="6" md="4">
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Default"
                                   FullWidth="true"
                                   StartIcon="@Icons.Material.Filled.Storage"
                                   Href="@($"/admin/connected-systems/{Id}/objects")">
                            Objects
                        </MudButton>
                    </MudItem>
                    <MudItem xs="12" sm="6" md="4">
                        <MudButton Variant="Variant.Outlined"
                                   Color="@(_pendingExportCount > 0 ? Color.Warning : Color.Default)"
                                   FullWidth="true"
                                   StartIcon="@Icons.Material.Filled.Outbox"
                                   Href="@($"/admin/connected-systems/{Id}/pending-exports")">
                            Pending Exports @(_pendingExportCount > 0 ? $"({_pendingExportCount})" : "")
                        </MudButton>
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudTabPanel>

        <MudTabPanel Text="Settings">
            <MudText>Configure the connector for your environment by supplying values for the settings below.</MudText>

            <MudForm @ref="_settingsForm" @bind-IsValid="@IsSettingsFormValid" @bind-Errors="@SettingsFormErrors" Class="mt-5">
                @if (_settingCategories != null)
                {
                    @for (var i = 0; i < _settingCategories.Count; i++)
                    {
                        var settingCategory = _settingCategories[i];
                        <MudText Typo="Typo.h5" Class="mt-5">@settingCategory.ToString()</MudText>
                        <MudPaper Class="pa-4 mt-5" Outlined="true">
                            @foreach (var settingValue in _connectedSystem.SettingValues
                                .Where(sv => sv.Setting.Category == settingCategory)
                                .OrderBy(sv => sv.Setting.Id))
                            {
                                if (settingValue.Setting.Type == ConnectedSystemSettingType.Heading)
                                {
                                    <MudText Typo="Typo.h6" Class="mb-5">@settingValue.Setting.Name</MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Divider)
                                {
                                    <hr />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.String)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.StringEncrypted)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringEncryptedValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Password"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Integer)
                                {
                                    <MudTextField T="int?"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.IntValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Number"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.CheckBox)
                                {
                                    <div class="mb-5">
                                        <MudSwitch @bind-Value="settingValue.CheckboxValue" Color="Color.Primary" Label="@settingValue.Setting.Name" />
                                        @if (!string.IsNullOrEmpty(settingValue.Setting.Description))
                                        {
                                            <MudText Typo="Typo.caption" Class="mud-text-secondary ml-12">@settingValue.Setting.Description</MudText>
                                        }
                                    </div>
                                }
                                else if (settingValue.Setting is { Type: ConnectedSystemSettingType.DropDown, DropDownValues: not null })
                                {
                                    <MudSelect @bind-Value="settingValue.StringValue"
                                               HelperText="@settingValue.Setting.Description"
                                               Label="@settingValue.Setting.Name"
                                               Variant="Variant.Outlined"
                                               Class="mb-5"
                                               Required="@settingValue.Setting.Required"
                                               RequiredError="@($"A {settingValue.Setting.Name} is required")">
                                        @foreach (var dropDownValue in settingValue.Setting.DropDownValues)
                                        {
                                            <MudSelectItem T="string" Value="@dropDownValue">@dropDownValue</MudSelectItem>
                                        }
                                    </MudSelect>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Label)
                                {
                                    <MudText Class="mb-5">
                                        @settingValue.Setting.Description
                                    </MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.File)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  Variant="Variant.Outlined"
                                                  ReadOnly="true"
                                                  Adornment="Adornment.End"
                                                  AdornmentIcon="@Icons.Material.Filled.FolderOpen"
                                                  OnAdornmentClick="@(() => OpenFileBrowserAsync(settingValue))"
                                                  Class="mb-5" />
                                }
                                else
                                {
                                    <MudText Class="mt-b">Oops. Unknown setting type!</MudText>
                                }
                            }
                        </MudPaper>
                    }
                }

                @if (SettingsFormCustomErrors.Count > 0)
                {
                    <MudAlert Severity="Severity.Error" Class="mt-5">
                        <MudText>There are issues with the settings:</MudText>
                        <ul class="mt-5">
                            @foreach (var error in SettingsFormCustomErrors)
                            {
                                <li>@error.Key: @error.Value</li>
                            }
                        </ul>
                    </MudAlert>
                }

                <MudButton Variant="Variant.Filled" Color="@(IsSettingsFormValid || !_settingsBeingSaved ? Color.Primary : Color.Default)" Disabled="@(!IsSettingsFormValid || _settingsBeingSaved)" Class="mt-5" DropShadow="false" OnClick="HandleValidSettingsSubmitAsync">
                    @if (_settingsBeingSaved)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Processing</MudText>
                    }
                    else
                    {
                        <MudText>Save Settings</MudText>
                    }
                </MudButton>
            </MudForm>
        </MudTabPanel>

        <MudTabPanel Text="Schema" Disabled="@AreSettingDependentTabsDisabled()">

            <MudAlert Severity="_connectedSystem.ObjectTypes is { Count: > 0 } ? Severity.Warning : Severity.Info">
                @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                {
                    <MudText>Retrieve the schema from the connected system, to be able to select which object types and attributes you want to manage with JIM.</MudText>
                }
                else
                {
                    <MudText>
                        <strong>Refreshing the schema can result in data-loss</strong>. If object types or attributes are discovered to have been removed at the connected system, then this
                        will result in all references to them being removed from within JIM, i.e. synchronisation rules, attribute flow, attributes values and even entire objects will be
                        deleted if object types are removed. Refresh with caution. Ensure the Connected System identity has the right permissions needed to retrieve the schema, and consider
                        a database backup before proceeding.
                    </MudText>
                }
                <MudButton
                    Color="_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0 ? Color.Info : Color.Warning"
                    Disabled="@(_schemaBeingRetrieved)"
                    Variant="Variant.Filled"
                    Size="Size.Small"
                    OnClick="HandleImportSchemaAsync"
                    Class="mt-5"
                    DropShadow="false">
                    @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Retrieving Schema</MudText>
                        }
                        else
                        {
                            <text>Retrieve Schema</text>
                        }
                    }
                    else
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Refreshing Schema</MudText>
                        }
                        else
                        {
                            <text>Refresh Schema</text>
                        }
                    }
                </MudButton>
            </MudAlert>

            @if (_schemaRefreshResult != null)
            {
                var result = _schemaRefreshResult;
                <MudAlert Severity="@(result.Success ? (result.HasChanges ? Severity.Info : Severity.Success) : Severity.Error)"
                          Icon="@(result.Success ? Icons.Material.Filled.CheckCircle : Icons.Material.Filled.Error)"
                          Class="mt-3 jim-alert-schema-refresh"
                          ShowCloseIcon="true"
                          CloseIconClicked="HandleCloseSchemaRefreshResult">
                    <MudText Typo="Typo.subtitle1" Class="mb-2">
                        Schema Refresh @(result.Success ? "Complete" : "Failed")
                    </MudText>

                    @if (result.Success)
                    {
                        <MudText Class="mb-2">
                            Found <strong>@result.TotalObjectTypes</strong> object type(s) with <strong>@result.TotalAttributes</strong> attribute(s).
                        </MudText>

                        @if (!result.HasChanges)
                        {
                            <MudText Color="Color.Success">No changes detected. The schema is up to date.</MudText>
                        }
                        else
                        {
                            <MudSimpleTable Dense="true" Hover="true" Bordered="true" Class="mt-2">
                                <thead>
                                    <tr>
                                        <th>Change Type</th>
                                        <th>Details</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @if (result.AddedObjectTypes.Count > 0)
                                    {
                                        <tr>
                                            <td><MudIcon Icon="@Icons.Material.Filled.Add" Color="Color.Success" Size="Size.Small" Class="me-1" /> Object Types Added</td>
                                            <td>@string.Join(", ", result.AddedObjectTypes)</td>
                                        </tr>
                                    }
                                    @if (result.RemovedObjectTypes.Count > 0)
                                    {
                                        <tr>
                                            <td><MudIcon Icon="@Icons.Material.Filled.Remove" Color="Color.Error" Size="Size.Small" Class="me-1" /> Object Types Removed</td>
                                            <td>@string.Join(", ", result.RemovedObjectTypes)</td>
                                        </tr>
                                    }
                                    @if (result.UpdatedObjectTypes.Count > 0)
                                    {
                                        <tr>
                                            <td><MudIcon Icon="@Icons.Material.Filled.Update" Color="Color.Info" Size="Size.Small" Class="me-1" /> Object Types Updated</td>
                                            <td>@string.Join(", ", result.UpdatedObjectTypes)</td>
                                        </tr>
                                    }
                                    @foreach (var kvp in result.AddedAttributes)
                                    {
                                        <tr>
                                            <td><MudIcon Icon="@Icons.Material.Filled.Add" Color="Color.Success" Size="Size.Small" Class="me-1" /> Attributes Added (@kvp.Key)</td>
                                            <td>@string.Join(", ", kvp.Value)</td>
                                        </tr>
                                    }
                                    @foreach (var kvp in result.RemovedAttributes)
                                    {
                                        <tr>
                                            <td><MudIcon Icon="@Icons.Material.Filled.Remove" Color="Color.Warning" Size="Size.Small" Class="me-1" /> Attributes Removed (@kvp.Key)</td>
                                            <td>@string.Join(", ", kvp.Value)</td>
                                        </tr>
                                    }
                                </tbody>
                            </MudSimpleTable>

                            @if (result.ActionRequired)
                            {
                                <MudAlert Severity="Severity.Warning" Class="mt-3">
                                    <strong>Action Required:</strong> Some attributes that were removed are still referenced by sync rules.
                                    Please update your sync rules to remove references to these attributes.
                                </MudAlert>
                            }
                        }
                    }
                    else
                    {
                        <MudText Color="Color.Error">@result.ErrorMessage</MudText>
                    }
                </MudAlert>
            }

            <MudDialog @bind-Visible="_editSchemaAttributeDialogVisible" Options="_dialogOptions">
                <TitleContent>
                    <MudText Typo="Typo.h6">
                        <MudIcon Icon="@Icons.Material.Filled.Edit" Class="mr-3" /> Edit Schema Attribute: @_objectTypeAttributeBeingEdited?.Name
                    </MudText>
                </TitleContent>
                <DialogContent>
                    @if (!_objectTypeAttributeBeingEditedIsEditable)
                    {
                        <MudAlert Severity="Severity.Error">
                            This Connected System attribute cannot be edited as it is being referenced by either a synchronisation rule, or has values already populated.
                        </MudAlert>
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Info">
                            This Connector supports changing the data type of a Connected System attribute. This might be because the data type
                            was detected automatically, and might need adjusting if not right.
                        </MudAlert>
                    }

                    <MudSelect
                        T="string"
                        Label="Please choose a data type"
                        Required="true"
                        Variant="Variant.Outlined"
                        Class="mt-5"
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable"
                        @bind-Value="_objectTypeAttributeBeingEditedText">
                        @foreach (AttributeDataType type in Enum.GetValues(typeof(AttributeDataType)))
                        {
                            if (type != AttributeDataType.NotSet)
                            {
                                <MudSelectItem Value="@type.ToString()"/>
                            }
                        }
                    </MudSelect>

                </DialogContent>
                <DialogActions>
                    <MudButton
                        DropShadow="false"
                        Variant="Variant.Text"
                        OnClick="@(() => _editSchemaAttributeDialogVisible = false)"
                        Class="ma-4">Cancel</MudButton>
                    <MudButton
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable"
                        DropShadow="false"
                        Variant="Variant.Filled"
                        Color="Color.Primary"
                        OnClick="HandleEditAttributeDataTypeButtonClick"
                        Class="ma-4">Confirm Change</MudButton>
                </DialogActions>
            </MudDialog>

            @if (_connectedSystem.ObjectTypes is { Count: > 0 })
            {
                if (_connectedSystem.ObjectTypes.Count > 1 || (_connectedSystem.ObjectTypes.Count == 1 && !_connectedSystem.ObjectTypes[0].Selected))
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText Class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            Select which object types you would like to manage with JIM.
                        </MudText>
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            @foreach (var objectType in _connectedSystem.ObjectTypes)
                            {
                                <MudCheckBox T="bool" Value="@objectType.Selected" Color="Color.Primary" Label="@objectType.Name" ValueChanged="((e) => HandleSelectedObjectTypeClick(objectType, e))" />
                            }
                        </div>
                    </MudPaper>
                }

                @if (_connectedSystem.ObjectTypes.Count(q => q.Selected) > 1)
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            <MudButtonGroup Color="Color.Default" Class="mb-5" DropShadow="false" Variant="Variant.Outlined">
                                @foreach (var objectType in _connectedSystem.ObjectTypes.Where(q => q.Selected))
                                {
                                    <MudButton
                                        OnClick="@((_) => HandleActiveObjectTypeClick(objectType))"
                                        Disabled="DisableSelectedSchemaObjectType(objectType)"
                                        DropShadow="false">@objectType.Name</MudButton>
                                }
                            </MudButtonGroup>
                        </div>
                    </MudPaper>
                }

                @if (_selectedObjectType != null)
                {
                    <MudText Typo="Typo.h6" Class="mt-5">@_selectedObjectType.Name</MudText>
                    @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedExternalId)
                    {
                        <MudPaper Outlined="true" Class="pa-4 mt-5">
                            <MudText>This connector requires you to select the attribute that is used as the External ID. Please select one below.</MudText>
                            <MudSelect
                                T="ConnectedSystemObjectTypeAttribute"
                                Label="External ID Attribute"
                                Variant="Variant.Outlined"
                                Class="mt-5"
                                Required="true"
                                RequiredError="You must select an attribute as the External ID."
                                Value="_selectedObjectType.Attributes.SingleOrDefault(q => q.IsExternalId)"
                                ValueChanged="HandleMakeExternalId">
                                @foreach (var objectTypeAttribute in _selectedObjectType.Attributes.Where(q => q.AttributePlurality == AttributePlurality.SingleValued))
                                {
                                    <MudSelectItem Value="@objectTypeAttribute">@(objectTypeAttribute.Name)</MudSelectItem>
                                }
                            </MudSelect>
                        </MudPaper>
                    }

                    @if (_connectedSystem.SupportsImportMode())
                    {
                        <MudPaper Outlined="true" Class="pa-4 mt-5">
                            <MudText Typo="Typo.subtitle1" Class="mb-3">Object Type Settings</MudText>
                            <MudSwitch
                                @bind-Value="@_selectedObjectType.RemoveContributedAttributesOnObsoletion"
                                Color="@Color.Primary"
                                Label="Remove contributed attributes when objects are obsoleted" />
                            <MudText Typo="Typo.caption" Class="mud-text-secondary">
                                When enabled, attribute values contributed by objects of this type will be removed from the Metaverse when the source object is deleted or no longer present in the connected system.
                            </MudText>
                        </MudPaper>
                    }

                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText>
                            Select which attributes you would like to manage for this object type. To maximise performance, only select those you need.
                        </MudText>

                        <MudGrid Class="mt-3 mb-3">
                            <MudItem xs="@(_selectedObjectTypeHasClasses ? 6 : 12)">
                                <MudTextField
                                    T="string"
                                    @bind-Value="_schemaSearchString"
                                    Label="Filter by name"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Search"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined"
                                    HelperText="Show only attributes where the name containers a specific value"
                                    autocomplete="schema_search_string" />
                            </MudItem>

                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudItem xs="6">
                                    <MudSelect
                                        T="string"
                                        Label="Filter by class"
                                        MultiSelection="true"
                                        @bind-SelectedValues="AttributeClassFilterSelectedValues"
                                        Variant="Variant.Outlined"
                                        HelperText="Show only attributes with a particular class"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.FilterAlt"
                                        IconSize="Size.Small">
                                        @foreach (var className in _selectedObjectType.Attributes.Select(a => a.ClassName).Distinct().OrderBy(a => a))
                                        {
                                            <MudSelectItem T="string" Value="@className">@className</MudSelectItem>
                                        }
                                    </MudSelect>
                                </MudItem>
                            }

                            <MudItem xs="10">
                                <MudTextField
                                    T="string"
                                    Label="Select attributes via CSV"
                                    @bind-Value="_attributeSelectionCsv"
                                    HelperText="You can also quick-select attributes by entering them in a comma-separated list, i.e. DisplayName,sAMAccountName"
                                    InputType="InputType.Text"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Input"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined" />
                            </MudItem>
                            <MudItem xs="2">
                                <MudButton
                                    Variant="Variant.Filled"
                                    DropShadow="false"
                                    Class="mt-4"
                                    Color="Color.Default"
                                    OnClick="HandleAttributeCsvSubmit">Select Attributes</MudButton>
                            </MudItem>

                            <MudItem xs="12" Class="pb-0">
                                <MudCheckBox @bind-Value="_attributeSelectedFilter" Color="Color.Primary">Show only selected?</MudCheckBox>
                            </MudItem>
                        </MudGrid>
                    </MudPaper>

                    <MudTable
                        Items="@_selectedObjectType.Attributes"
                        Virtualize="true"
                        Hover="true"
                        Dense="true"
                        Breakpoint="Breakpoint.Sm"
                        SortLabel="Sort By"
                        Filter="new Func<ConnectedSystemObjectTypeAttribute,bool>(SchemaFilterFuncHandler)"
                        Class="mt-5"
                        Outlined="true"
                        Elevation="0">
                        <HeaderContent>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Selected)">Selected</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.IsExternalId)">External ID</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.ClassName!)">Class</MudTableSortLabel></MudTh>
                            }
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Type)">Type</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.AttributePlurality)">Plurality</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Description!)">Description</MudTableSortLabel></MudTh>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTh></MudTh>
                            }
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Selected">
                                <MudSwitch @bind-Value="@context.Selected" Color="@Color.Primary"></MudSwitch>
                            </MudTd>
                            <MudTd DataLabel="External ID">
                                @(context.IsExternalId ? "Yes" : "-")
                            </MudTd>
                            <MudTd DataLabel="Name">@context.Name</MudTd>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTd DataLabel="Class">
                                    @context.ClassName
                                </MudTd>
                            }
                            <MudTd DataLabel="Type">
                                @context.Type
                            </MudTd>
                            <MudTd DataLabel="Plurality" Class="jim-nowrap">
                                @context.AttributePlurality.ToString().SplitOnCapitalLetters()
                            </MudTd>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTd DataLabel="Description">
                                    @context.Description
                                </MudTd>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTd>
                                    <MudButton
                                        DropShadow="false"
                                        Size="Size.Small"
                                        Variant="Variant.Filled"
                                        OnClick="() => HandleShowEditAttributeDialogAsync(context)"
                                        StartIcon="@Icons.Material.Filled.Edit">
                                        Edit
                                    </MudButton>
                                </MudTd>
                            }
                        </RowTemplate>
                        <NoRecordsContent>
                            @if (_attributeSelectedFilter) {
                                <MudText>There are no selected attributes for this object type.</MudText>
                            } else {
                                <MudText>There are no attributes to show.</MudText>
                            }
                        </NoRecordsContent>
                    </MudTable>
                }

                <MudButton
                    Color="Color.Primary"
                    Variant="Variant.Filled"
                    OnClick="HandleObjectTypesAndAttributeSelectionSubmitAsync"
                    Class="mt-5"
                    DropShadow="false"
                    Disabled="DisableSaveSchemaButton()">Save Changes</MudButton>
            }

        </MudTabPanel>

        @if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            <MudTabPanel Text="Partitions & Containers" Disabled="@AreSettingDependentTabsDisabled()">

                <MudAlert Severity="(_connectedSystem.Partitions is { Count: > 0 } ? Severity.Warning : Severity.Info)">
                    @if (_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0)
                    {
                        <MudText>Retrieve the hierarchy @_partitionAndHierarchyText hierarchy from the connected system, to be able to select which ones you want to manage with JIM.</MudText>
                    }
                    else
                    {
                        <MudText>
                            <strong>Refreshing the @_partitionAndHierarchyText hierarchy can result in data-loss</strong>. If partitions and/or containers are removed, then this will result in all objects in them being deleted
                            from the Connected System, which depending on your configuration, could result in those objects being deprovisioned from the Metaverse and any downstream Connected Systems. Refresh with caution.
                            Ensure the Connected System identity has the right permissions needed to retrieve the hierarchy, and consider a database backup before proceeding.
                        </MudText>
                    }
                    <MudButton
                            Disabled="@_hierarchyBeingRetrieved"
                            Color="_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0 ? Color.Primary : Color.Warning"
                            Size="Size.Small"
                            OnClick="HandleImportHierarchyAsync"
                            Variant="Variant.Filled"
                            Class="mt-5"
                            DropShadow="false">
                        @if (_connectedSystem.Partitions?.Count == 0)
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Retrieving Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Retrieve Hierarchy</text>
                            }
                        }
                        else
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Refreshing Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Refresh Hierarchy</text>
                            }
                        }
                    </MudButton>
                </MudAlert>

                @if (_connectedSystem.Partitions is { Count: > 0 } && !_connectedSystem.HasPartitionsOrContainersSelected())
                {
                    <MudAlert Severity="Severity.Warning" Class="mt-5">
                        <MudText>
                            <strong>No partitions or containers have been selected.</strong> You must select at least one partition
                            @if (_connectedSystem.ConnectorDefinition.SupportsPartitionContainers)
                            {
                                <text> and at least one container within that partition</text>
                            }
                            before you can configure object matching rules or create run profiles.
                        </MudText>
                    </MudAlert>
                }

                @if (_connectedSystem.Partitions is { Count: > 0 })
                {
                    <MudText Class="mt-5">Select which @_partitionsAndHierarchiesText are to be managed by JIM here. To maximise performance, only select those that need managing.</MudText>
                    @foreach (var partition in _connectedSystem.Partitions)
                    {
                        <MudPaper Class="mt-5" Outlined="true">
                            <div class="pa-4">
                                <MudText Typo="Typo.h5" Class="mb-5">@partition.Name</MudText>
                                <MudSwitch @bind-Value="@partition.Selected" Color="Color.Primary" Label="Manage this partition?" />
                            </div>
                            <MudDivider />

                            <div class="pa-4">
                                <MudText>Select the containers you want to manage in this partition.</MudText>

                                @*
                                TODO:
                                <MudButtonGroup Color="Color.Default" Size="Size.Small" Variant="Variant.Outlined" Class="mt-5 mb-5">
                                    <MudButton>Select All</MudButton>
                                    <MudButton>Clear All</MudButton>
                                </MudButtonGroup>
                                *@

                                @if (partition.Containers != null)
                                {
                                    <MudTreeView Items="@GetTreeItemData(partition.Containers)" ReadOnly AutoExpand>
                                        <ItemTemplate Context="item">
                                            <MudTreeViewItem @bind-Expanded="@item.Expanded" Items="@item.Children">
                                                <BodyContent>
                                                    @if (item.Value != null)
                                                    {
                                                        @if (item.Value.Included)
                                                        {
                                                            <MudCheckBox T="bool?"
                                                                         Value="@(item.Value.AreAnyChildContainersSelected() ? null : item.Value.Selected)"
                                                                         ValueChanged="@(_ => ConnectedSystemContainerSelectedChanged(item.Value))"
                                                                         UncheckedIcon="@Icons.Material.Outlined.FilterCenterFocus"
                                                                         Disabled="true"
                                                                         title="Included"/>
                                                        }
                                                        else
                                                        {
                                                            <MudCheckBox T="bool?"
                                                                         Value="@(item.Value.AreAnyChildContainersSelected() ? null : item.Value.Selected)"
                                                                         ValueChanged="@(_ => ConnectedSystemContainerSelectedChanged(item.Value))"
                                                                         title="@(item.Value.Selected ? "Selected" : string.Empty)"/>
                                                        }
                                                        <MudText>@item.Value.Name</MudText>
                                                    }
                                                </BodyContent>
                                            </MudTreeViewItem>
                                        </ItemTemplate>
                                    </MudTreeView>
                                }
                            </div>
                        </MudPaper>
                    }

                    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleHierarchySelectionSubmitAsync" Class="mt-5" DropShadow="false">Save Changes</MudButton>
                }
            </MudTabPanel>
        }

        <MudTabPanel Text="Object Matching" Disabled="@IsObjectMatchingTabDisabled()">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4">
                <div>
                    <MudText Typo="Typo.body1">
                        @if (_connectedSystem.ObjectMatchingRuleMode == ObjectMatchingRuleMode.ConnectedSystem)
                        {
                            <text>Matching rules are defined here per object type and shared across all sync rules.</text>
                        }
                        else
                        {
                            <text>Matching rules are configured on each individual sync rule.</text>
                        }
                    </MudText>
                </div>
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                    <MudText Class="mud-text-secondary">Simple</MudText>
                    <MudSwitch T="bool"
                               Value="@(_connectedSystem.ObjectMatchingRuleMode == ObjectMatchingRuleMode.SyncRule)"
                               ValueChanged="HandleObjectMatchingModeToggleAsync"
                               Color="Color.Primary" />
                    <MudText Class="mud-text-secondary">Advanced</MudText>
                </MudStack>
            </MudStack>

            @if (_connectedSystem.ObjectMatchingRuleMode == ObjectMatchingRuleMode.SyncRule)
            {
                @* Advanced Mode - matching rules are on sync rules *@
                <MudAlert Severity="Severity.Info" Class="mt-4">
                    In Advanced Mode, matching rules are configured on each individual sync rule. This allows different
                    matching logic for different scenarios.
                </MudAlert>
                <MudButton StartIcon="@Icons.Material.Filled.OpenInNew"
                           Variant="Variant.Filled"
                           Href="/admin/connected-systems/sync-rules"
                           Color="Color.Primary"
                           Class="mt-4"
                           DropShadow="false">
                    Go to Synchronisation Rules
                </MudButton>
            }
            else if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
            {
                <MudAlert Severity="Severity.Warning">
                    No object types have been configured. Import the schema first to configure object matching rules.
                </MudAlert>
            }
            else
            {
                var selectedObjectTypes = _connectedSystem.ObjectTypes.Where(ot => ot.Selected).ToList();

                @if (selectedObjectTypes.Count == 0)
                {
                    <MudAlert Severity="Severity.Warning">
                        No object types have been selected. Select object types in the Schema tab first.
                    </MudAlert>
                }
                else if (selectedObjectTypes.Count == 1)
                {
                    @* Single object type - show directly without selection UI *@
                    @RenderMatchingRulesForObjectType(selectedObjectTypes[0])
                }
                else
                {
                    @* Multiple object types - use tabs for navigation *@
                    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pt-4" Outlined="true" @bind-ActivePanelIndex="_selectedMatchingRuleTabIndex">
                        @foreach (var objectType in selectedObjectTypes)
                        {
                            <MudTabPanel Text="@objectType.Name" Tag="@objectType">
                                @RenderMatchingRulesForObjectType(objectType)
                            </MudTabPanel>
                        }
                    </MudTabs>
                }
            }
        </MudTabPanel>

        <MudTabPanel Text="Run Profiles" Disabled="@IsRunProfilesTabDisabled()">
            <MudAlert Severity="Severity.Info">Run profiles define what operations can be performed on a Connector, i.e. import, export and synchronisation, with any required settings.</MudAlert>

            <MudButton
                Variant="Variant.Filled"
                Color="Color.Primary"
                Class="mt-5"
                DropShadow="false"
                StartIcon="@Icons.Material.Filled.Add"
                OnClick="HandleShowNewRunProfileDialogAsync">
                Create Run Profile
            </MudButton>

            <MudTable Items="@_connectedSystem.RunProfiles" Hover="true" Breakpoint="Breakpoint.Sm" Class="mt-5" SortLabel="Sort By" Outlined="true" Elevation="0">
                <HeaderContent>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.RunType)">Run Type</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Partition?.Name!)">Partition</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.PageSize)">Page Size</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.FilePath!)">File Path</MudTableSortLabel></MudTh>
                    <MudTh>Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudTd DataLabel="Run Type">@context.RunType.ToString().SplitOnCapitalLetters()</MudTd>
                    <MudTd DataLabel="Partition">@(context.Partition != null ? context.Partition.Name : "-")</MudTd>
                    <MudTd DataLabel="Page Size">@context.PageSize</MudTd>
                    <MudTd DataLabel="File Path">
                        @if (!string.IsNullOrEmpty(context.FilePath))
                        {
                            <span class="jim-code-inline">@context.FilePath</span>
                        }
                        else
                        {
                            <span>-</span>
                        }
                    </MudTd>
                    <MudTd DataLabel="Actions">
                        <MudTooltip Text="Delete">



                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                           Size="Size.Small"
                                           Color="Color.Error"
                                           Variant="Variant.Filled"
                                           OnClick="_ => HandleRunProfileDeleteAsync(context)" />
                        </MudTooltip>
                    </MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    There are no run profiles. Create your first.
                </NoRecordsContent>
            </MudTable>

        </MudTabPanel>

        <MudTabPanel Text="Danger Zone" Icon="@Icons.Material.Filled.Warning" BadgeColor="Color.Error">
            <MudPaper Class="pa-4 jim-paper-danger-zone">
                <MudText Typo="Typo.h6" Color="Color.Error">Delete Connected System</MudText>
                <MudText Class="mt-2">
                    Permanently delete this Connected System and all its related data, including:
                </MudText>
                <ul class="mt-2 ml-4">
                    <li>All Connected System Objects (CSOs)</li>
                    <li>All Sync Rules</li>
                    <li>All Run Profiles</li>
                    <li>All Partitions and Containers</li>
                    <li>All Pending Exports</li>
                </ul>
                <MudText Class="mt-2">
                    Metaverse Objects joined to this system's CSOs will be disconnected but not deleted.
                </MudText>

                <MudButton
                    Variant="Variant.Filled"
                    Color="Color.Error"
                    Class="mt-5"
                    DropShadow="false"
                    StartIcon="@Icons.Material.Filled.Delete"
                    OnClick="HandleShowDeleteConfirmationAsync"
                    Disabled="@(_connectedSystem?.Status == ConnectedSystemStatus.Deleting)">
                    @if (_connectedSystem?.Status == ConnectedSystemStatus.Deleting)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Deletion in Progress...</MudText>
                    }
                    else
                    {
                        <text>Delete Connected System</text>
                    }
                </MudButton>
            </MudPaper>
        </MudTabPanel>

    </MudTabs>

    @* New Run Profile Dialog *@
    <MudDialog @bind-Visible="_newRunProfileDialogVisible" Options="_newRunProfileDialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Add" Class="me-3" /> Create New Run Profile
            </MudText>
        </TitleContent>
        <DialogContent>
            <MudForm @bind-IsValid="@IsNewRunProfileFormValid">
                <MudTextField T="string" @bind-Value="_newRunProfile.Name" Label="Name" Variant="Variant.Outlined" Class="mt-3" Required="true" RequiredError="A name for the run profile is required" />

                <MudSelect
                    T="ConnectedSystemRunType"
                    @bind-Value="_newRunProfile.RunType"
                    Label="Run Type"
                    Variant="Variant.Outlined"
                    AnchorOrigin="Origin.BottomCenter"
                    Class="mt-5"
                    Required="true"
                    RequiredError="A run profile type is required"
                    Validation="@(new Func<ConnectedSystemRunType, string?>(ValidateRunType))"
                    Immediate="true">
                    <MudSelectItem Value="ConnectedSystemRunType.NotSet" Disabled="true">Select run type</MudSelectItem>
                    @foreach (ConnectedSystemRunType runType in Enum.GetValues(typeof(ConnectedSystemRunType)))
                    {
                        if (runType == ConnectedSystemRunType.NotSet)
                            continue;

                        var runTypeSupported = true;
                        switch (runType)
                        {
                            case ConnectedSystemRunType.Export when !_connectedSystem!.ConnectorDefinition.SupportsExport:
                            case ConnectedSystemRunType.DeltaImport when !_connectedSystem!.ConnectorDefinition.SupportsDeltaImport:
                            case ConnectedSystemRunType.FullImport when !_connectedSystem!.ConnectorDefinition.SupportsFullImport:
                                runTypeSupported = false;
                                break;
                            case ConnectedSystemRunType.FullSynchronisation:
                            case ConnectedSystemRunType.DeltaSynchronisation:
                                break;
                        }

                        <MudSelectItem Value="@runType" Disabled="@(!runTypeSupported)">
                            @runType.ToString().SplitOnCapitalLetters()
                            @if (!runTypeSupported)
                            {
                                <span> (not supported by Connector)</span>
                            }
                        </MudSelectItem>
                    }
                </MudSelect>

                @if (_newRunProfile.RunType == ConnectedSystemRunType.FullImport ||
                     _newRunProfile.RunType == ConnectedSystemRunType.DeltaImport ||
                     _newRunProfile.RunType == ConnectedSystemRunType.Export)
                {
                    <MudTextField
                        T="string"
                        @bind-Value="_newRunProfile.FilePath"
                        Label="File Path"
                        Variant="Variant.Outlined"
                        Class="mt-3"
                        HelperText="File-based connectors need the in-container path specifying, i.e. /var/connector-files/test-data/Users.csv" />
                }

                @if (_connectedSystem!.ConnectorDefinition.SupportsPartitions && _connectedSystem.Partitions != null)
                {
                    <MudSelect
                        T="ConnectedSystemPartition"
                        @bind-Value="_newRunProfile.Partition"
                        Label="Partition"
                        Variant="Variant.Outlined"
                        Class="mt-5"
                        AnchorOrigin="Origin.BottomCenter"
                        Required="@_connectedSystem.ConnectorDefinition.SupportsPartitions"
                        RequiredError="A run profile partition is required">
                        @foreach (var partition in _connectedSystem.Partitions.Where(p => p.Selected))
                        {
                            <MudSelectItem Value="@partition" />
                        }
                    </MudSelect>
                }

                @if (_newRunProfile.RunType == ConnectedSystemRunType.FullImport ||
                     _newRunProfile.RunType == ConnectedSystemRunType.DeltaImport ||
                     _newRunProfile.RunType == ConnectedSystemRunType.Export)
                {
                    <MudNumericField @bind-Value="_newRunProfile.PageSize" Label="Page Size" Variant="Variant.Outlined" Class="mt-3" Min="0" Step="100" Required="true" RequiredError="How many items to process in one go when importing/exporting" />
                }
            </MudForm>
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="@(() => _newRunProfileDialogVisible = false)" DropShadow="false">Cancel</MudButton>
            <MudButton
                Color="Color.Primary"
                Variant="Variant.Filled"
                DropShadow="false"
                OnClick="HandleNewRunProfileFormSubmitAsync"
                Disabled="@(!IsNewRunProfileFormValid || _newRunProfile.RunType == ConnectedSystemRunType.NotSet)">
                Create Run Profile
            </MudButton>
        </DialogActions>
    </MudDialog>

    @* Delete Confirmation Dialog *@
    <MudDialog @bind-Visible="_deleteConfirmationDialogVisible" Options="_deleteDialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Warning" Color="Color.Error" Class="mr-3" /> Confirm Deletion
            </MudText>
        </TitleContent>
        <DialogContent>
            @if (_deletionPreview != null)
            {
                <MudAlert Severity="Severity.Error" Class="mb-4">
                    This action is <strong>permanent</strong> and cannot be undone!
                </MudAlert>

                <MudText Typo="Typo.subtitle1">The following will be deleted:</MudText>
                <MudSimpleTable Dense="true" Hover="true" Class="mt-2" Elevation="0" Outlined="true">
                    <tbody>
                        <tr>
                            <td>Connected System Objects</td>
                            <td class="text-right">@_deletionPreview.ConnectedSystemObjectCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Sync Rules</td>
                            <td class="text-right">@_deletionPreview.SyncRuleCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Run Profiles</td>
                            <td class="text-right">@_deletionPreview.RunProfileCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Partitions</td>
                            <td class="text-right">@_deletionPreview.PartitionCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Containers</td>
                            <td class="text-right">@_deletionPreview.ContainerCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Pending Exports</td>
                            <td class="text-right">@_deletionPreview.PendingExportCount.ToString("N0")</td>
                        </tr>
                        <tr>
                            <td>Activities (will be preserved)</td>
                            <td class="text-right">@_deletionPreview.ActivityCount.ToString("N0")</td>
                        </tr>
                    </tbody>
                </MudSimpleTable>

                @if (_deletionPreview.JoinedMvoCount > 0)
                {
                    <MudAlert Severity="Severity.Info" Class="mt-4">
                        @_deletionPreview.JoinedMvoCount.ToString("N0") Metaverse Object(s) will be disconnected from this system.
                    </MudAlert>
                }

                @if (_deletionPreview.Warnings.Count > 0)
                {
                    <MudText Typo="Typo.subtitle1" Class="mt-4">Warnings:</MudText>
                    <ul class="mt-2 ml-4">
                        @foreach (var warning in _deletionPreview.Warnings)
                        {
                            <li><MudText Color="Color.Warning">@warning</MudText></li>
                        }
                    </ul>
                }

                @if (_deletionPreview.WillRunAsBackgroundJob)
                {
                    <MudAlert Severity="Severity.Info" Class="mt-4">
                        Due to the size of this system, deletion will run as a background job.
                        Estimated time: @_deletionPreview.EstimatedDeletionTime.ToString(@"hh\:mm\:ss")
                    </MudAlert>
                }

                <MudTextField
                    T="string"
                    @bind-Value="_deleteConfirmationText"
                    Label="@($"Type \"{_connectedSystem?.Name}\" to confirm")"
                    Variant="Variant.Outlined"
                    Class="mt-4"
                    FullWidth="true"
                    Immediate="true" />
            }
            else if (_deletionPreviewLoading)
            {
                <div class="d-flex justify-center align-center pa-8">
                    <MudProgressCircular Indeterminate="true" />
                    <MudText Class="ml-4">Loading deletion preview...</MudText>
                </div>
            }
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="@(() => _deleteConfirmationDialogVisible = false)" DropShadow="false">Cancel</MudButton>
            <MudButton
                Color="Color.Error"
                Variant="Variant.Filled"
                DropShadow="false"
                OnClick="HandleDeleteConfirmedAsync"
                Disabled="@(!IsDeleteConfirmationValid())">
                @if (_deletionInProgress)
                {
                    <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                    <MudText Class="ms-2">Deleting...</MudText>
                }
                else
                {
                    <text>Delete Permanently</text>
                }
            </MudButton>
        </DialogActions>
    </MudDialog>
}

@* Mode Switch Dialog *@
<MudDialog @bind-Visible="_modeSwitchDialogVisible" Options="_deleteDialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.SwapHoriz" Class="mr-3 mb-n1" />
            Switch to @(_switchingToAdvancedMode ? "Advanced" : "Simple") Mode
        </MudText>
    </TitleContent>
    <DialogContent>
        @if (_switchingToAdvancedMode)
        {
            <MudText>
                Switching to <strong>Advanced Mode</strong> will allow you to configure different matching rules for each sync rule.
            </MudText>
            <MudAlert Severity="Severity.Info" Class="mt-4">
                The current matching rules will be copied to all existing import sync rules for this Connected System, giving you a starting point to customise.
            </MudAlert>
        }
        else
        {
            <MudText>
                Switching to <strong>Simple Mode</strong> will configure matching rules here, shared across all sync rules.
            </MudText>
            <MudAlert Severity="Severity.Warning" Class="mt-4">
                <strong>Migration:</strong> Matching rules from sync rules will be analysed and migrated to the object type level:
                <ul class="mt-2 mb-0">
                    <li>If all sync rules have the same matching rules, they will be used directly.</li>
                    <li>If sync rules have different matching rules, the most common configuration will be selected.</li>
                    <li>Matching rules will be cleared from all sync rules after migration.</li>
                </ul>
            </MudAlert>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="@(() => _modeSwitchDialogVisible = false)" DropShadow="false" Disabled="_modeSwitchInProgress">Cancel</MudButton>
        <MudButton
            Color="Color.Primary"
            Variant="Variant.Filled"
            DropShadow="false"
            OnClick="HandleModeSwitchConfirmedAsync"
            Disabled="_modeSwitchInProgress">
            @if (_modeSwitchInProgress)
            {
                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                <MudText Class="ms-2">Switching...</MudText>
            }
            else
            {
                <text>Switch Mode</text>
            }
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public int Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }
    private bool IsDetailsFormValid { get; set; }
    private string[] DetailsFormErrors { get; set; } = [];
    private bool IsSettingsFormValid { get; set; }
    private string[] SettingsFormErrors { get; set; } = [];
    private Dictionary<string, string> SettingsFormCustomErrors { get; } = new();
    private bool IsNewRunProfileFormValid { get; set; }
    private ConnectedSystem? _connectedSystem;
    private bool _settingsBeingSaved;
    private MudForm? _settingsForm;
    private List<ConnectedSystemSettingCategory>? _settingCategories;
    private string? _partitionsAndHierarchiesText;
    private string? _partitionAndHierarchyText;
    private bool _schemaBeingRetrieved;
    private SchemaRefreshResult? _schemaRefreshResult;
    private int _pendingExportCount;
    private ConnectedSystemObjectType? _selectedObjectType;
    private bool _selectedObjectTypeHasClasses;
    private bool _selectedObjectTypeHasDescriptions;
    private bool _hierarchyBeingRetrieved;
    private string _schemaSearchString = "";
    private ConnectedSystemRunProfile _newRunProfile = new() { PageSize = 500, RunType = ConnectedSystemRunType.NotSet };
    private IEnumerable<string> AttributeClassFilterSelectedValues { get; set; } = new HashSet<string>();
    private bool _attributeSelectedFilter;
    private string? _attributeSelectionCsv;
    private List<BreadcrumbItem> _breadcrumbs = null!;

    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private bool _editSchemaAttributeDialogVisible;
    private ConnectedSystemObjectTypeAttribute? _objectTypeAttributeBeingEdited;
    private string? _objectTypeAttributeBeingEditedText;
    private bool _objectTypeAttributeBeingEditedIsEditable;

    // New Run Profile dialog
    private readonly DialogOptions _newRunProfileDialogOptions = new() { FullWidth = true, MaxWidth = MaxWidth.Small };
    private bool _newRunProfileDialogVisible;

    // Delete confirmation dialog
    private readonly DialogOptions _deleteDialogOptions = new() { FullWidth = true, MaxWidth = MaxWidth.Small };
    private bool _deleteConfirmationDialogVisible;
    private ConnectedSystemDeletionPreview? _deletionPreview;
    private bool _deletionPreviewLoading;
    private bool _deletionInProgress;
    private string? _deleteConfirmationText;

    // Object Matching Rules
    private int _selectedMatchingRuleTabIndex;
    private ConnectedSystemObjectTypeAttribute? _newMatchingRuleSourceAttribute;
    private MetaverseAttribute? _newMatchingRuleTargetAttribute;
    private bool _newMatchingRuleCaseSensitive = true;
    private IList<MetaverseAttribute>? _metaverseAttributes;
    // Track the currently active object type for the matching rules form state
    private ConnectedSystemObjectType? _currentMatchingRuleObjectType;
    // Mode switch dialog
    private bool _modeSwitchDialogVisible;
    private bool _switchingToAdvancedMode;
    private bool _modeSwitchInProgress;

    protected override async Task OnInitializedAsync()
    {
        _connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(Id);
        if (_connectedSystem == null)
        {
            // connected system not found, redirect to index page
            NavManager.NavigateTo("../");
            return;
        }

        _breadcrumbs =
        [
            new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
            new BreadcrumbItem("Connected Systems", href: "/admin/connected-systems/"),
            new BreadcrumbItem(_connectedSystem.Name, href: null, disabled: true)
        ];

        // get a list of the distinct setting categories in use, so we can render them in category blocks
        // Filter out categories based on connector capabilities and order them logically
        _settingCategories = _connectedSystem.SettingValues
            .Select(q => q.Setting.Category)
            .Distinct()
            .Where(category => ShouldShowCategory(category))
            .OrderBy(category => GetCategoryDisplayOrder(category))
            .ToList();

        // to save us having to perform this comparison all over the view
        if (_connectedSystem.ConnectorDefinition is { SupportsPartitions: true, SupportsPartitionContainers: true })
        {
            _partitionsAndHierarchiesText = "partitions and containers";
            _partitionAndHierarchyText = "partition and container";
        }
        else if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            _partitionsAndHierarchiesText = "partitions";
            _partitionAndHierarchyText = "partition";
        }

        // show the first selected object type attribute table
        if (_connectedSystem.ObjectTypes != null)
            _selectedObjectType = _connectedSystem.ObjectTypes.FirstOrDefault(q => q.Selected);

        ApplyContainerIncludedToPartitions(_connectedSystem);

        // load the pending export count for the quick links section
        _pendingExportCount = await Jim.ConnectedSystems.GetPendingExportsCountAsync(Id);

        // load metaverse attributes for object matching rules
        _metaverseAttributes = await Jim.Metaverse.GetMetaverseAttributesAsync();
    }

    private bool AreSettingDependentTabsDisabled()
    {
        if (_connectedSystem == null)
            return true;

        return !_connectedSystem.SettingValuesValid;
    }

    /// <summary>
    /// Determines whether a setting category should be displayed based on connector capabilities.
    /// </summary>
    private bool ShouldShowCategory(ConnectedSystemSettingCategory category)
    {
        if (_connectedSystem?.ConnectorDefinition == null)
            return true;

        return category switch
        {
            // Only show Import category if the connector supports full or delta import
            ConnectedSystemSettingCategory.Import =>
                _connectedSystem.ConnectorDefinition.SupportsFullImport ||
                _connectedSystem.ConnectorDefinition.SupportsDeltaImport,

            // Only show Export category if the connector supports export
            ConnectedSystemSettingCategory.Export =>
                _connectedSystem.ConnectorDefinition.SupportsExport,

            // Always show other categories
            _ => true
        };
    }

    /// <summary>
    /// Returns the display order for setting categories.
    /// Order: Import, Export, General, Schema, Connectivity, Capabilities
    /// </summary>
    private static int GetCategoryDisplayOrder(ConnectedSystemSettingCategory category)
    {
        return category switch
        {
            ConnectedSystemSettingCategory.Import => 0,
            ConnectedSystemSettingCategory.Export => 1,
            ConnectedSystemSettingCategory.General => 2,
            ConnectedSystemSettingCategory.Schema => 3,
            ConnectedSystemSettingCategory.Connectivity => 4,
            ConnectedSystemSettingCategory.Capabilities => 5,
            _ => 99
        };
    }

    private async Task HandleValidDetailsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidDetailsSubmitAsync)}: connectedSystem was null");
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your details changes have been saved.", Severity.Success);
    }

    private async Task HandleValidSettingsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidSettingsSubmitAsync)}: connectedSystem was null");
            return;
        }

        _settingsBeingSaved = true;
        SettingsFormCustomErrors.Clear();

        StateHasChanged();
        await Task.Delay(1);

        // validate the form
        var results = Jim.ConnectedSystems.ValidateConnectedSystemSettings(_connectedSystem);
        for (var i = 0; i < results.Count; i++)
        {
            var result = results[i];
            if (result.IsValid)
                continue;

            switch (result.SettingValue)
            {
                case { Setting.Name: not null } when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add(result.SettingValue.Setting.Name, result.ErrorMessage);
                    break;
                case null when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add($"General issue {i + 1}", result.ErrorMessage);
                    break;
            }
        }

        if (SettingsFormCustomErrors.Any())
        {
            _settingsBeingSaved = false;
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your setting changes have been saved.", Severity.Success);
        _settingsBeingSaved = false;

        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task HandleImportSchemaAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _schemaBeingRetrieved = true;
        _schemaRefreshResult = null; // Clear any previous result
        StateHasChanged();
        await Task.Delay(1);

        try
        {
            _schemaRefreshResult = await Jim.ConnectedSystems.ImportConnectedSystemSchemaAsync(_connectedSystem, user);

            // if there's just a single object type in the schema, auto-select it
            if (_connectedSystem.ObjectTypes is { Count: 1 })
                HandleSelectedObjectTypeClick(_connectedSystem.ObjectTypes[0], true);
        }
        catch (CsvParsingException ex)
        {
            await ShowCsvErrorDialogAsync(ex);
            _schemaRefreshResult = SchemaRefreshResult.Failed(ex.Message);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to import schema for connected system {SystemId}", _connectedSystem.Id);
            _schemaRefreshResult = SchemaRefreshResult.Failed(ex.Message);
        }
        finally
        {
            _schemaBeingRetrieved = false;
            StateHasChanged();
            await Task.Delay(1);
        }
    }

    private void HandleCloseSchemaRefreshResult()
    {
        _schemaRefreshResult = null;
        StateHasChanged();
    }

    private void HandleSelectedObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType, bool isObjectTypeChecked)
    {
        if (_connectedSystem == null)
            return;

        // actuate the state change
        connectedSystemObjectType.Selected = isObjectTypeChecked;

        // now cascade
        // if only one type is selected, make that the selected object type
        // if none are selected, clear selected object type
        // if the selected type is being de-selected, null the selected type
        if (_connectedSystem.ObjectTypes != null && _connectedSystem.ObjectTypes.Count(q => q.Selected) == 1)
            _selectedObjectType = _connectedSystem.ObjectTypes.Single(q => q.Selected);
        else if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count(q => q.Selected) == 0)
            _selectedObjectType = null;
        else if (_selectedObjectType != null && _selectedObjectType.Id == connectedSystemObjectType.Id && !isObjectTypeChecked)
            _selectedObjectType = null;

        // some parts of the UI only make sense if the attributes have classes
        _selectedObjectTypeHasClasses = connectedSystemObjectType.Attributes.Any(q => q.ClassName != null);
        _selectedObjectTypeHasDescriptions = connectedSystemObjectType.Attributes.Any(q => q.Description != null);
    }

    private void HandleActiveObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType)
    {
        _selectedObjectType = connectedSystemObjectType;
    }

    private void HandleMakeExternalId(ConnectedSystemObjectTypeAttribute selectedAttribute)
    {
        if (_selectedObjectType == null)
        {
            Log.Error($"CS Detail > HandleMakeExternalId: {nameof(_selectedObjectType)} is null!");
            return;
        }

        // make sure there's not already an attribute marked as the external id
        foreach (var attribute in _selectedObjectType.Attributes.Where(a => a.IsExternalId))
            attribute.IsExternalId = false;

        // mark the intended attribute as the external id, and select it
        selectedAttribute.IsExternalId = true;
        selectedAttribute.Selected = true;
        Log.Verbose($"CS Detail > HandleMakeExternalId: Set attribute id {selectedAttribute} as the external id.");
    }

    private async Task HandleObjectTypesAndAttributeSelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your attribute changes have been saved.", Severity.Success);
    }

    private async Task HandleImportHierarchyAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _hierarchyBeingRetrieved = true;
        StateHasChanged();
        await Task.Delay(1);

        try
        {
            await Jim.ConnectedSystems.ImportConnectedSystemHierarchyAsync(_connectedSystem, user);
            Snackbar.Add("Hierarchy has been retrieved successfully.", Severity.Success);
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to import hierarchy for Connected System {ConnectedSystemId}", _connectedSystem.Id);
            Snackbar.Add($"Failed to retrieve hierarchy: {ex.Message}", Severity.Error);
        }
        finally
        {
            _hierarchyBeingRetrieved = false;
            StateHasChanged();
        }
    }

    private async Task HandleHierarchySelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your hierarchy changes have been saved.", Severity.Success);
    }

    private async Task HandleAddMatchingRuleAsync(ConnectedSystemObjectType objectType)
    {
        if (_connectedSystem == null || _newMatchingRuleSourceAttribute == null || _newMatchingRuleTargetAttribute == null)
            return;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        // Calculate the next order value
        var nextOrder = objectType.ObjectMatchingRules.Count > 0
            ? objectType.ObjectMatchingRules.Max(r => r.Order) + 1
            : 0;

        var rule = new ObjectMatchingRule
        {
            Order = nextOrder,
            ConnectedSystemObjectTypeId = objectType.Id,
            ConnectedSystemObjectType = objectType,
            TargetMetaverseAttributeId = _newMatchingRuleTargetAttribute.Id,
            TargetMetaverseAttribute = _newMatchingRuleTargetAttribute,
            CaseSensitive = _newMatchingRuleCaseSensitive,
            Sources = new List<ObjectMatchingRuleSource>
            {
                new()
                {
                    Order = 0,
                    ConnectedSystemAttributeId = _newMatchingRuleSourceAttribute.Id,
                    ConnectedSystemAttribute = _newMatchingRuleSourceAttribute
                }
            }
        };

        try
        {
            await Jim.ConnectedSystems.CreateObjectMatchingRuleAsync(rule, user);

            // Note: EF Core automatically adds the rule to the ObjectMatchingRules collection
            // because we set ConnectedSystemObjectType on the rule before saving

            // Reset the form
            _newMatchingRuleSourceAttribute = null;
            _newMatchingRuleTargetAttribute = null;
            _newMatchingRuleCaseSensitive = true;

            Snackbar.Add("Matching rule has been created.", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to create matching rule for object type {ObjectTypeId}", objectType.Id);
            Snackbar.Add($"Failed to create matching rule: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleDeleteMatchingRuleAsync(ObjectMatchingRule rule, ConnectedSystemObjectType objectType)
    {
        if (_connectedSystem == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox(
            "Delete Matching Rule",
            $"Are you sure you want to delete this matching rule? This action cannot be undone.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirmationResult != true)
            return;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        try
        {
            await Jim.ConnectedSystems.DeleteObjectMatchingRuleAsync(rule, user);

            // Remove from the local list for immediate UI update
            objectType.ObjectMatchingRules.Remove(rule);

            Snackbar.Add("Matching rule has been deleted.", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to delete matching rule {RuleId}", rule.Id);
            Snackbar.Add($"Failed to delete matching rule: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleToggleMatchingRuleCaseSensitiveAsync(ObjectMatchingRule rule, bool caseSensitive)
    {
        if (_connectedSystem == null)
            return;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        try
        {
            rule.CaseSensitive = caseSensitive;
            await Jim.ConnectedSystems.UpdateObjectMatchingRuleAsync(rule, user);

            Snackbar.Add($"Matching rule is now {(caseSensitive ? "case-sensitive" : "case-insensitive")}.", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            // Revert the change on failure
            rule.CaseSensitive = !caseSensitive;
            Log.Error(ex, "Failed to update matching rule {RuleId}", rule.Id);
            Snackbar.Add($"Failed to update matching rule: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleMoveMatchingRuleUpAsync(ObjectMatchingRule rule, ConnectedSystemObjectType objectType)
    {
        await SwapMatchingRuleOrderAsync(rule, -1, objectType);
    }

    private async Task HandleMoveMatchingRuleDownAsync(ObjectMatchingRule rule, ConnectedSystemObjectType objectType)
    {
        await SwapMatchingRuleOrderAsync(rule, 1, objectType);
    }

    private async Task SwapMatchingRuleOrderAsync(ObjectMatchingRule rule, int direction, ConnectedSystemObjectType objectType)
    {
        if (_connectedSystem == null)
            return;

        var rules = objectType.ObjectMatchingRules.OrderBy(r => r.Order).ToList();
        var currentIndex = rules.IndexOf(rule);
        var targetIndex = currentIndex + direction;

        if (targetIndex < 0 || targetIndex >= rules.Count)
            return;

        var targetRule = rules[targetIndex];

        // Swap the order values
        var tempOrder = rule.Order;
        rule.Order = targetRule.Order;
        targetRule.Order = tempOrder;

        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        try
        {
            // Update both rules
            await Jim.ConnectedSystems.UpdateObjectMatchingRuleAsync(rule, user);
            await Jim.ConnectedSystems.UpdateObjectMatchingRuleAsync(targetRule, user);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to reorder matching rules");
            Snackbar.Add($"Failed to reorder matching rules: {ex.Message}", Severity.Error);
        }
    }

    private Task HandleObjectMatchingModeToggleAsync(bool advancedMode)
    {
        _switchingToAdvancedMode = advancedMode;
        _modeSwitchDialogVisible = true;
        return Task.CompletedTask;
    }

    private async Task HandleModeSwitchConfirmedAsync()
    {
        if (_connectedSystem == null)
            return;

        _modeSwitchInProgress = true;
        StateHasChanged();

        try
        {
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
            var newMode = _switchingToAdvancedMode ? ObjectMatchingRuleMode.SyncRule : ObjectMatchingRuleMode.ConnectedSystem;

            var result = await Jim.ConnectedSystems.SwitchObjectMatchingModeAsync(_connectedSystem, newMode, user);

            if (!result.Success)
            {
                Snackbar.Add($"Failed to switch mode: {result.ErrorMessage}", Severity.Error);
                return;
            }

            if (_switchingToAdvancedMode)
            {
                Snackbar.Add($"Switched to Advanced Mode. Matching rules copied to {result.SyncRulesUpdated} sync rule(s).", Severity.Success);
            }
            else
            {
                // Show success message
                var message = $"Switched to Simple Mode. Matching rules set on {result.ObjectTypesUpdated} object type(s).";
                Snackbar.Add(message, Severity.Success);

                // Show any warnings about diverging rules
                foreach (var warning in result.Warnings)
                {
                    Snackbar.Add(warning, Severity.Warning);
                }
            }

            _modeSwitchDialogVisible = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Log.Error(ex, "Failed to switch object matching mode");
            Snackbar.Add($"Failed to switch mode: {ex.Message}", Severity.Error);
        }
        finally
        {
            _modeSwitchInProgress = false;
            StateHasChanged();
        }
    }

    private bool SchemaFilterFuncHandler(ConnectedSystemObjectTypeAttribute element) => SchemaFilterFunc(element, _schemaSearchString, AttributeClassFilterSelectedValues, _attributeSelectedFilter);

    private static bool SchemaFilterFunc(ConnectedSystemObjectTypeAttribute element, string searchString, IEnumerable<string> attributeClassFilterSelectedValues, bool attributeSelectedFilter)
    {
        // what type of search is this? name, class or csv?
        var classHashset = (HashSet<string>)attributeClassFilterSelectedValues;

        if (!string.IsNullOrEmpty(searchString))
            return element.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase);

        if (classHashset.Count > 0)
            return classHashset.Any(q => q == element.ClassName);

        return !attributeSelectedFilter || element.Selected;
    }

    private static List<TreeItemData<ConnectedSystemContainer>> GetTreeItemData(HashSet<ConnectedSystemContainer> containers)
    {
        return containers.Select(connectedSystemContainer => new TreeItemData<ConnectedSystemContainer>
        {
            Value = connectedSystemContainer,
            Children = GetTreeItemData(connectedSystemContainer.ChildContainers)
        }).ToList();
    }

    private static void ConnectedSystemContainerSelectedChanged(ConnectedSystemContainer container)
    {
        // if included and clicked, change to not included, not selected
        if (container.Included)
        {
            container.Selected = false;
        }
        else
        {
            // toggle the current setting
            container.Selected = !container.Selected;
        }

        container.Included = false;

        // set the right selected/included values for all children
        if (container.Selected)
        {
            // all children should be included and not selected
            foreach (var child in container.ChildContainers)
            {
                child.Included = true;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, true);
            }
        }
        else
        {
            // all children should be not selected and not included
            foreach (var child in container.ChildContainers)
            {
                child.Included = false;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, false);
            }
        }

        // set the parent(s) if necessary
        if (container.ParentContainer != null)
        {
            // go up a level. if all children are selected, then make parent selected and all children (recursively) included.
            CorrectUpwardContainerStatus(container.ParentContainer);
        }

        // make sure the partition is selected if not already
        AutoSelectPartitionIfContainersSelected(container);
    }

    /// <summary>
    /// Makes sure the partition is selected if any contains in its hierarchy are selected.
    /// </summary>
    private static void AutoSelectPartitionIfContainersSelected(ConnectedSystemContainer container)
    {
        // this method could probably be optimised. I was having a hard time writing this.
        // get the partition at the top of the container hierarchy
        var partition = container.Partition;
        var areAnyContainersSelected = container.Selected;
        if (partition != null && areAnyContainersSelected && !partition.Selected)
        {
            partition.Selected = true;
            return;
        }

        // we need a variable to hold the TLC when we eventually find it
        ConnectedSystemContainer? topLevelContainer = null;

        // we need a variable to hold the current container as we navigate up the hierarchy
        var currentContainer = container;

        // keep moving up the container hierarchy until we find the TLC
        // ReSharper disable once LoopVariableIsNeverChangedInsideLoop : incorrect
        while (topLevelContainer == null)
        {
            if (currentContainer.ParentContainer == null)
            {
                // found it! stop looping
                topLevelContainer = currentContainer;
                break;
            }

            // move up one level in the container hierarchy
            currentContainer = currentContainer.ParentContainer;
        }

        // it's possible the TLC hasn't been found
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse : incorrect
        if (topLevelContainer == null)
        {
            Log.Warning("Couldn't find the top-level container. unable to auto-select partition.");
            return;
        }

        // we might already know if any containers are selected
        if (!areAnyContainersSelected)
        {
            // we have a TLC! now, are any containers in the hierarchy selected?
            if (topLevelContainer.Partition is { Containers: not null })
                if (topLevelContainer.Partition.Containers.Any(IsContainerOrAnyChildrenSelected))
                    areAnyContainersSelected = true;
        }

        // does the top-level container have a parent partition?
        if (topLevelContainer.Partition != null && areAnyContainersSelected)
            topLevelContainer.Partition.Selected = true;
    }

    private static bool IsContainerOrAnyChildrenSelected(ConnectedSystemContainer container)
    {
        return container.Selected || container.ChildContainers.Any(IsContainerOrAnyChildrenSelected);
    }

    private static void ApplyContainerStatusDownBranch(ConnectedSystemContainer container, bool selected, bool included)
    {
        foreach (var child in container.ChildContainers)
        {
            child.Included = included;
            child.Selected = selected;
            ApplyContainerStatusDownBranch(child, selected, included);
        }
    }

    private static void ApplyContainerIncludedToPartitions(ConnectedSystem connectedSystemInQuestion)
    {
        if (connectedSystemInQuestion.Partitions == null)
            return;

        foreach (var partition in connectedSystemInQuestion.Partitions)
            if (partition.Containers != null)
                foreach (var container in partition.Containers)
                    ApplyContainerIncludedRecursively(container, container.Selected);
    }

    private static void ApplyContainerIncludedRecursively(ConnectedSystemContainer connectedSystemContainer, bool aParentWasSelected)
    {
        foreach (var childContainer in connectedSystemContainer.ChildContainers)
        {
            var shouldChildBeIncluded = aParentWasSelected;

            // parent was selected, so this child container should be marked as included
            if (aParentWasSelected)
                childContainer.Included = true;

            // if this child container is selected, then it's children should be marked as included
            if (childContainer.Selected)
                shouldChildBeIncluded = true;

            ApplyContainerIncludedRecursively(childContainer, shouldChildBeIncluded);
        }
    }

    private static void CorrectUpwardContainerStatus(ConnectedSystemContainer parentContainer)
    {
        if (parentContainer.ChildContainers.All(q => q.Selected))
        {
            parentContainer.Selected = true;
            parentContainer.Included = false;

            foreach (var childContainer in parentContainer.ChildContainers)
            {
                childContainer.Selected = false;
                childContainer.Included = true;
                ApplyContainerStatusDownBranch(childContainer, false, true);
            }
        }

        if (parentContainer.ParentContainer != null)
            CorrectUpwardContainerStatus(parentContainer.ParentContainer);
    }

    private bool IsRunProfilesTabDisabled()
    {
        if (_connectedSystem == null)
            return true;

        // Disable if settings are invalid
        if (!_connectedSystem.SettingValuesValid)
            return true;

        // Disable if the connector supports partitions but none are selected (with containers if applicable)
        if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
            return !_connectedSystem.HasPartitionsOrContainersSelected();

        return false;
    }

    private bool IsObjectMatchingTabDisabled()
    {
        if (_connectedSystem == null)
            return true;

        // Disable if settings are invalid
        if (!_connectedSystem.SettingValuesValid)
            return true;

        // Disable if the connector supports partitions but none are selected (with containers if applicable)
        if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
            return !_connectedSystem.HasPartitionsOrContainersSelected();

        return false;
    }

    private string? ValidateRunType(ConnectedSystemRunType runType)
    {
        if (runType == ConnectedSystemRunType.NotSet)
            return "Please select a run type";

        return null;
    }

    private Task HandleShowNewRunProfileDialogAsync()
    {
        // Reset the form for a fresh run profile
        _newRunProfile = new ConnectedSystemRunProfile { PageSize = 500, RunType = ConnectedSystemRunType.NotSet };
        _newRunProfileDialogVisible = true;
        return Task.CompletedTask;
    }

    private async Task HandleNewRunProfileFormSubmitAsync()
    {
        if (_connectedSystem?.RunProfiles == null)
            return;

        // copy the form bound object to a new one we can persist separately from the form bind
        var runProfile = new ConnectedSystemRunProfile {
            ConnectedSystemId = _connectedSystem.Id,
            Name = _newRunProfile.Name,
            RunType = _newRunProfile.RunType,
            Partition = _newRunProfile.Partition,
            PageSize = _newRunProfile.PageSize,
            FilePath = _newRunProfile.FilePath
        };

        // attribute the action to the user and create the run profile
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.CreateConnectedSystemRunProfileAsync(runProfile, user);

        Snackbar.Add("New run profile added.", Severity.Success);

        // close the dialog and reset the form
        _newRunProfileDialogVisible = false;
        _newRunProfile = new ConnectedSystemRunProfile { PageSize = 500, RunType = ConnectedSystemRunType.NotSet };
    }

    private async Task HandleRunProfileDeleteAsync(ConnectedSystemRunProfile connectedSystemRunProfile)
    {
        if (_connectedSystem?.RunProfiles == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox(
            "Delete Run Profile",
            $"Are you sure you want to delete the run profile '{connectedSystemRunProfile.Name}'? This action cannot be undone.",
            yesText: "Delete",
            cancelText: "Cancel");

        if (confirmationResult != true)
            return;

        _connectedSystem.RunProfiles.Remove(connectedSystemRunProfile);

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.DeleteConnectedSystemRunProfileAsync(connectedSystemRunProfile, user);

        Snackbar.Add("Run profile removed.", Severity.Success);
    }

    private void HandleAttributeCsvSubmit()
    {
        if (_selectedObjectType == null)
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: connectedSystem was null");
            return;
        }

        if (string.IsNullOrEmpty(_attributeSelectionCsv))
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: attributeSelectionCsv is null or empty");
            return;
        }

        // clear the other search boxes
        _schemaSearchString = string.Empty;
        ((HashSet<string>)AttributeClassFilterSelectedValues).Clear();

        // convert the csv to a list and trim the entries
        // go through each attribute on the object type and select it
        foreach (var attributeName in _attributeSelectionCsv.Split(','))
        {
            var attribute = _selectedObjectType.Attributes.SingleOrDefault(a => a.Name.Equals(attributeName.Trim(), StringComparison.OrdinalIgnoreCase));
            if (attribute == null)
                continue;

            attribute.Selected = true;
        }

        // filter by selected
        _attributeSelectedFilter = true;

        // clear the attribute csv text box
        _attributeSelectionCsv = null;

        // all done, let the user know
        Snackbar.Add("Attributes selected.", Severity.Success);
    }

    private bool DisableSelectedSchemaObjectType(ConnectedSystemObjectType connectedSystemObjectType)
    {
        if (_selectedObjectType == null)
            return false;

        if (connectedSystemObjectType.Id.Equals(_selectedObjectType.Id))
            return true; // BOTH IDS ARE 0 WHEN THEY'RE DIFFERENT TYPES! HOW?! - BECAUSE THEY HAVEN'T BEEN PERSISTED YET!

        return false;
    }

    /// <summary>
    /// Determines whether the Save Schema changes button should be disabled or not.
    /// </summary>
    private bool DisableSaveSchemaButton()
    {
        // must select at least one object type
        // all selected object types must have an external id selected

        if (_connectedSystem?.ObjectTypes == null)
            return true;

        var objectTypesSelected = _connectedSystem.ObjectTypes.Any(ot => ot.Selected);
        var externalIdsSet = _connectedSystem.ObjectTypes.Where(ot => ot.Selected).All(ot => ot.Attributes.Any(a => a.IsExternalId));

        return !objectTypesSelected || !externalIdsSet;
    }

    private async Task HandleShowEditAttributeDialogAsync(ConnectedSystemObjectTypeAttribute connectedSystemObjectTypeAttribute)
    {
        // can the connected system attribute be edited? are there any references to it?
        _objectTypeAttributeBeingEditedIsEditable = !await Jim.ConnectedSystems.IsObjectTypeAttributeBeingReferencedAsync(connectedSystemObjectTypeAttribute);
        _objectTypeAttributeBeingEdited = connectedSystemObjectTypeAttribute;
        _objectTypeAttributeBeingEditedText = connectedSystemObjectTypeAttribute.Type.ToString();
        _editSchemaAttributeDialogVisible = true;
    }

    private void HandleEditAttributeDataTypeButtonClick()
    {
        if (_objectTypeAttributeBeingEdited == null)
            return;

        if (_objectTypeAttributeBeingEditedText == null)
            return;

        _objectTypeAttributeBeingEdited.Type = (AttributeDataType)Enum.Parse(typeof(AttributeDataType), _objectTypeAttributeBeingEditedText);
        _editSchemaAttributeDialogVisible = false;

        // all done, let the user know
        Snackbar.Add("Attribute data type updated.", Severity.Success);
    }

    #region File Browser
    private async Task OpenFileBrowserAsync(ConnectedSystemSettingValue settingValue)
    {
        // Determine if this is an export mode (may need new filename)
        var isExportMode = _connectedSystem?.IsExportOnlyMode() ?? false;
        var title = isExportMode ? "Select Export Location" : "Select File";

        var parameters = new DialogParameters<FileBrowserDialog>
        {
            { x => x.Title, title },
            { x => x.AllowNewFilename, isExportMode },
            { x => x.InitialPath, settingValue.StringValue }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<FileBrowserDialog>(title, parameters, options);
        var result = await dialog.Result;

        if (result is { Canceled: false, Data: string selectedPath })
        {
            settingValue.StringValue = selectedPath;
            StateHasChanged();

            // Force form to re-validate after programmatic value change
            if (_settingsForm != null)
            {
                await _settingsForm.Validate();
            }
        }
    }

    private async Task ShowCsvErrorDialogAsync(CsvParsingException ex)
    {
        var parameters = new DialogParameters<CsvErrorDialog>
        {
            { x => x.ErrorMessage, ex.Message },
            { x => x.RowNumber, ex.RowNumber },
            { x => x.ColumnInfo, ex.ColumnInfo },
            { x => x.RawData, ex.RawRow },
            { x => x.Suggestion, ex.Suggestion }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        await DialogService.ShowAsync<CsvErrorDialog>("CSV Parsing Error", parameters, options);
    }
    #endregion

    #region Delete Connected System
    private async Task HandleShowDeleteConfirmationAsync()
    {
        _deleteConfirmationText = string.Empty;
        _deletionPreview = null;
        _deletionPreviewLoading = true;
        _deleteConfirmationDialogVisible = true;

        StateHasChanged();
        await Task.Delay(1);

        // Load the deletion preview
        _deletionPreview = await Jim.ConnectedSystems.GetDeletionPreviewAsync(Id);
        _deletionPreviewLoading = false;

        StateHasChanged();
    }

    private bool IsDeleteConfirmationValid()
    {
        if (_deletionPreview == null || _deletionInProgress)
            return false;

        // User must type the exact name of the connected system to confirm
        return string.Equals(_deleteConfirmationText?.Trim(), _connectedSystem?.Name, StringComparison.Ordinal);
    }

    private async Task HandleDeleteConfirmedAsync()
    {
        if (_connectedSystem == null || !IsDeleteConfirmationValid())
            return;

        _deletionInProgress = true;
        StateHasChanged();
        await Task.Delay(1);

        try
        {
            // Get the current user
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

            // Perform the deletion
            var result = await Jim.ConnectedSystems.DeleteAsync(Id, user);

            _deleteConfirmationDialogVisible = false;
            _deletionInProgress = false;

            if (result.Success)
            {
                switch (result.Outcome)
                {
                    case DeletionOutcome.CompletedImmediately:
                        Snackbar.Add("Connected System has been deleted.", Severity.Success);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;

                    case DeletionOutcome.QueuedAsBackgroundJob:
                        Snackbar.Add("Deletion has been queued as a background job. You can monitor progress in the Operations view.", Severity.Info);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;

                    case DeletionOutcome.QueuedAfterSync:
                        Snackbar.Add("A sync operation is running. Deletion will proceed after it completes.", Severity.Info);
                        NavManager.NavigateTo("/admin/connected-systems/");
                        break;
                }
            }
            else
            {
                Snackbar.Add($"Failed to delete: {result.ErrorMessage}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            _deletionInProgress = false;
            Log.Error(ex, "Error deleting connected system {Id}", Id);
            Snackbar.Add($"An error occurred: {ex.Message}", Severity.Error);
        }

        StateHasChanged();
    }
    #endregion

    #region Object Matching Rules Render Fragment
    private RenderFragment RenderMatchingRulesForObjectType(ConnectedSystemObjectType objectType) => __builder =>
    {
        // Track the current object type for form operations
        _currentMatchingRuleObjectType = objectType;

        <MudPaper Outlined="true" Class="pa-4 mb-4">
            <MudText Typo="Typo.h6" Class="mb-3">Matching Rules for @objectType.Name</MudText>

            @if (objectType.ObjectMatchingRules.Count == 0)
            {
                <MudAlert Severity="Severity.Info" Dense="true" Class="mb-3">
                    No matching rules configured. Objects will only match if explicitly joined.
                </MudAlert>
            }
            else
            {
                <MudTable Items="@objectType.ObjectMatchingRules.OrderBy(r => r.Order)"
                          Hover="true"
                          Outlined="true"
                          Elevation="0"
                          Class="mb-4">
                    <HeaderContent>
                        <MudTh>Connected System Attribute</MudTh>
                        <MudTh>Operator</MudTh>
                        <MudTh>Metaverse Attribute</MudTh>
                        <MudTh>Case Sensitive</MudTh>
                        <MudTh>Actions</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="Source">
                            @if (context.Sources.Count > 0)
                            {
                                var source = context.Sources.First();
                                @if (source.ConnectedSystemAttribute != null)
                                {
                                    <text>@source.ConnectedSystemAttribute.Name</text>
                                }
                                else if (source.MetaverseAttribute != null)
                                {
                                    <text>@source.MetaverseAttribute.Name (MV)</text>
                                }
                                else
                                {
                                    <text>-</text>
                                }
                            }
                            else
                            {
                                <text>-</text>
                            }
                        </MudTd>
                        <MudTd DataLabel="Operator">=</MudTd>
                        <MudTd DataLabel="Target">@(context.TargetMetaverseAttribute?.Name ?? "-")</MudTd>
                        <MudTd DataLabel="Case Sensitive">
                            <MudSwitch T="bool" Value="@context.CaseSensitive"
                                       ValueChanged="@(value => HandleToggleMatchingRuleCaseSensitiveAsync(context, value))"
                                       Color="Color.Primary"
                                       Size="Size.Small" />
                        </MudTd>
                        <MudTd>
                            <MudTooltip Text="Move up">
                                <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward"
                                               Size="Size.Small"
                                               Color="Color.Default"
                                               Disabled="@(context.Order == 0)"
                                               OnClick="() => HandleMoveMatchingRuleUpAsync(context, objectType)" />
                            </MudTooltip>
                            <MudTooltip Text="Move down">
                                <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward"
                                               Size="Size.Small"
                                               Color="Color.Default"
                                               Disabled="@(context.Order == objectType.ObjectMatchingRules.Max(r => r.Order))"
                                               OnClick="() => HandleMoveMatchingRuleDownAsync(context, objectType)" />
                            </MudTooltip>
                            <MudTooltip Text="Delete">
                                <MudIconButton
                                    Icon="@Icons.Material.Filled.Delete"
                                    Variant="Variant.Filled"
                                    Size="Size.Small"
                                    Color="Color.Error"
                                    OnClick="() => HandleDeleteMatchingRuleAsync(context, objectType)" />
                            </MudTooltip>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            }

            <MudDivider Class="my-4" />
            <MudText Typo="Typo.subtitle1" Class="mb-3">Add New Matching Rule</MudText>

            <MudGrid>
                <MudItem xs="12" md="5">
                    <MudSelect T="ConnectedSystemObjectTypeAttribute"
                               @bind-Value="_newMatchingRuleSourceAttribute"
                               Label="Connected System Attribute"
                               Variant="Variant.Outlined"
                               HelperText="The Connected System attribute to match from">
                        @foreach (var attr in objectType.Attributes.Where(a => a.Selected).OrderBy(a => a.Name))
                        {
                            <MudSelectItem Value="@attr">@attr.Name</MudSelectItem>
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" md="2" Class="d-flex align-center justify-center">
                    <MudText Typo="Typo.h6">=</MudText>
                </MudItem>
                <MudItem xs="12" md="5">
                    <MudSelect T="MetaverseAttribute"
                               @bind-Value="_newMatchingRuleTargetAttribute"
                               Label="Metaverse Attribute"
                               Variant="Variant.Outlined"
                               HelperText="The Metaverse attribute to match against">
                        @if (_metaverseAttributes != null)
                        {
                            @foreach (var attr in _metaverseAttributes.OrderBy(a => a.Name))
                            {
                                <MudSelectItem Value="@attr">@attr.Name</MudSelectItem>
                            }
                        }
                    </MudSelect>
                </MudItem>
                <MudItem xs="12">
                    <MudCheckBox T="bool" @bind-Value="_newMatchingRuleCaseSensitive"
                                 Label="Case sensitive"
                                 Color="Color.Primary" />
                    <MudText Typo="Typo.caption" Class="mud-text-secondary">
                        When enabled (default), attribute values must match exactly including case. When disabled, "John" matches "JOHN".
                    </MudText>
                </MudItem>
            </MudGrid>

            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       Class="mt-4"
                       DropShadow="false"
                       Disabled="@(_newMatchingRuleSourceAttribute == null || _newMatchingRuleTargetAttribute == null)"
                       OnClick="() => HandleAddMatchingRuleAsync(objectType)">
                Add Matching Rule
            </MudButton>
        </MudPaper>
    };
    #endregion
}
