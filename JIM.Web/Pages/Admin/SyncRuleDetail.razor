@page "/admin/connected-systems/sync-rules/new"
@page "/admin/connected-systems/sync-rules/{Id:int}"
@attribute [Authorize(Roles = "Administrator")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Logic
@using JIM.Models.Search
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Models.Utility
@using JIM.Utilities
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<PageTitle>Synchronisation Rule: @_syncRuleNameOrCreate</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Synchronisation Rule:</span> @_syncRuleNameOrCreate</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>

@if (_isLoading)
{
    <div class="d-flex flex-column align-center justify-center mt-16">
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
        <MudText Typo="Typo.body2" Class="mt-4 mud-text-secondary">Loading synchronisation rule...</MudText>
    </div>
}
else if (_syncRule != null)
{
    <MudPaper Class="pa-4 mt-5" Outlined="true">

        <div class="d-flex justify-space-between align-center">
            <MudText Typo="Typo.h5" Class="mb-5">Details</MudText>
            @if (_syncRule.Id > 0)
            {
                <div class="d-flex gap-2">
                    <MudTooltip Text="@_syncRule.Created.ToLocalTime().ToFriendlyDate()" Placement="Placement.Top">
                        <MudChip T="string" Variant="Variant.Text" Color="Color.Info">
                            Created @_syncRule.Created.ToLocalTime().ToRelativeTime()@if (_syncRule.CreatedBy != null)
                            {<text> by @_syncRule.CreatedBy.DisplayName</text>}
                        </MudChip>
                    </MudTooltip>
                    @if (_syncRule.LastUpdated.HasValue)
                    {
                        <MudTooltip Text="@_syncRule.LastUpdated.Value.ToLocalTime().ToFriendlyDate()" Placement="Placement.Top">
                            <MudChip T="string" Variant="Variant.Text" Color="Color.Info">
                                Updated @_syncRule.LastUpdated.Value.ToLocalTime().ToRelativeTime()
                            </MudChip>
                        </MudTooltip>
                    }
                </div>
            }
        </div>

        <MudForm @bind-IsValid="@_isDetailsFormValid" @bind-Errors="@_detailsFormErrors">
            <MudTextField Label="Name" Required="true" RequiredError="A name is required" @bind-Value="_syncRule.Name"
                Variant="Variant.Outlined" />

            @if (_syncRule.Id > 0 && _syncRule.ConnectedSystem != null)
            {
                <MudStack Row="true" AlignItems="AlignItems.Center" Class="mt-4" Spacing="3">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudIcon Icon="@Icons.Material.Filled.Power" Size="Size.Small" Class="mud-text-secondary" />
                        <MudText Typo="Typo.body2" Class="mud-text-secondary">Connected System:</MudText>
                        <MudLink Href="@($"/admin/connected-systems/{_syncRule.ConnectedSystemId}")" Typo="Typo.body2">
                            @_syncRule.ConnectedSystem.Name
                        </MudLink>
                    </MudStack>
                    <MudDivider Vertical="true" FlexItem="true" />
                    <MudChip T="string" Variant="Variant.Text" Size="Size.Small"
                             Color="@(_syncRule.Direction == SyncRuleDirection.Import ? Color.Info : Color.Warning)">
                        @(_syncRule.Direction == SyncRuleDirection.Import ? "Inbound" : "Outbound")
                    </MudChip>
                    <MudDivider Vertical="true" FlexItem="true" />
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                        <MudText Typo="Typo.body2" Class="mud-text-secondary">Object Types:</MudText>
                        <MudChip T="string" Size="Size.Small" Variant="Variant.Text">MV: @_syncRule.MetaverseObjectType?.Name</MudChip>
                        <MudIcon Icon="@(_syncRule.Direction == SyncRuleDirection.Import ? Icons.Material.Filled.KeyboardDoubleArrowLeft : Icons.Material.Filled.KeyboardDoubleArrowRight)"
                                 Size="Size.Small" Class="mud-text-secondary" />
                        <MudChip T="string" Size="Size.Small" Variant="Variant.Text">CS: @_syncRule.ConnectedSystemObjectType?.Name</MudChip>
                    </MudStack>
                </MudStack>
            }

            @if (_syncRule.Id == 0)
            {
                @if (_connectedSystemHeaders != null)
                {
                    <MudSelect T="string" Label="Connected System" Placeholder="Please select a Connected System..." Required="true"
                        ValueChanged="HandleConnectedSystemSelectedAsync" AdornmentIcon="@Icons.Material.Filled.Power"
                        Adornment="Adornment.Start" Variant="Variant.Outlined" Class="mt-5">
                        @foreach (var header in _connectedSystemHeaders)
                        {
                            <MudSelectItem Value="@header.Id.ToString()">@header.Name</MudSelectItem>
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null)
                {
                    <MudSelect T="string" Label="Direction" Placeholder="Please select an attribute flow direction..."
                        Required="true" ValueChanged="HandleSyncRuleDirectionSelection" Variant="Variant.Outlined" Class="mt-5">
                        @foreach (SyncRuleDirection direction in Enum.GetValues(typeof(SyncRuleDirection)))
                        {
                            if (direction != SyncRuleDirection.NotSet)
                            {
                                // does the connector definition support this direction?
                                var directionSupported = false;
                                if (direction == SyncRuleDirection.Export)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsExport;
                                }
                                else if (direction == SyncRuleDirection.Import)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsDeltaImport ||
                                    _syncRule.ConnectedSystem.ConnectorDefinition.SupportsFullImport;
                                }

                                <MudSelectItem Disabled="!directionSupported" Value="@direction.ToString()">@direction@(directionSupported ?
                                                    "" : " (not supported by Connector)")</MudSelectItem>
                            }
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null && _syncRule.Direction != SyncRuleDirection.NotSet &&
                        _metaverseObjectTypes != null && _syncRule.ConnectedSystem is { ObjectTypes: not null })
                {
                    <MudGrid>
                        <MudItem xs="5">
                            <MudSelect T="MetaverseObjectType" Label="Metaverse Object Type"
                                @bind-Value="@_syncRule.MetaverseObjectType" Required="true" Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var mvObjectType in _metaverseObjectTypes)
                                {
                                    <MudSelectItem Value="@mvObjectType">@mvObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="2">
                            <MudPaper Outlined="false" Elevation="0"
                                Class="d-flex flex-column align-center justify-center mud-width-full py-10">
                                <MudIcon Size="Size.Medium"
                                    Icon="@(_syncRule.Direction == SyncRuleDirection.Export ? Icons.Material.Filled.KeyboardDoubleArrowRight : Icons.Material.Filled.KeyboardDoubleArrowLeft)">
                                </MudIcon>
                            </MudPaper>
                        </MudItem>
                        <MudItem xs="5">
                            <MudSelect T="ConnectedSystemObjectType" Label="Connected System Object Type"
                                @bind-Value="@_syncRule.ConnectedSystemObjectType" Required="true" Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var csObjectType in _syncRule.ConnectedSystem.ObjectTypes.Where(ot => ot.Selected))
                                {
                                    <MudSelectItem Value="@csObjectType">@csObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                    </MudGrid>
                }

                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudSwitch @bind-Value="@_syncRule.ProjectToMetaverse" Color="Color.Primary"
                        Label="Create imported objects in the Metaverse?" />
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, objects imported from this
                        Connected System matched in this synchronisation rule will not result in a Metaverse object being created.
                        Enabling this option causes the object to be projected to the Metaverse, allowing it to be managed within
                        JIM and synchronised to other Connected Systems. You would typically enable this for a source system, i.e. a
                        HR system.</MudAlert>
                }

                @if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    <MudSwitch @bind-Value="@_syncRule.ProvisionToConnectedSystem" Color="Color.Primary"
                        Label="Create objects in the Connected System?" />
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, Metaverse objects matched
                        in this synchronisation rule will not be created (provisioned) in the Connected Systems. Enabling this
                        option will cause the Metaverse object to be created in the Connected System. You would typically enable
                        this option for a destination system, i.e. when trying to implement a HR to Active Directory flow.
                    </MudAlert>
                }
            }
        </MudForm>
        <MudTooltip Text="Synchronisation Rules will not be evaluated when disabled. This allows to either prepare a rule in advance of it being needed, or to temporarily stop a sync rule from being evaluated."
                    Placement="Placement.Bottom">
            <MudSwitch Class="mt-5" @bind-Value="@_syncRule.Enabled" Color="Color.Primary" Label="Enabled?" />
        </MudTooltip>
    </MudPaper>

    @if (_syncRule.Direction != SyncRuleDirection.NotSet)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <div class="d-flex justify-space-between align-center">
                <MudText Typo="Typo.h5">Matching Rules</MudText>
                @if (_syncRule.ConnectedSystem?.ObjectMatchingRuleMode == ObjectMatchingRuleMode.SyncRule)
                {
                    <MudTooltip Text="Matching rules are specific to this sync rule." Placement="Placement.Top">
                        <MudChip T="string" Variant="Variant.Text" Text="Advanced Mode" Color="Color.Info" />
                    </MudTooltip>
                }
            </div>

            @if (_syncRule.ConnectedSystem?.ObjectMatchingRuleMode == ObjectMatchingRuleMode.ConnectedSystem)
            {
                <MudAlert Severity="Severity.Info" Class="mt-3" Icon="@Icons.Material.Outlined.Info">
                    This Connected System uses <strong>Simple Mode</strong> for object matching.
                    <MudLink Href="@($"/admin/connected-systems/{_syncRule.ConnectedSystemId}")" Underline="Underline.Always" Class="ms-1">
                        <MudIcon Icon="@Icons.Material.Filled.OpenInNew" Size="Size.Small" Class="me-1" Style="vertical-align: middle;" />Configure Matching Rules
                    </MudLink>
                </MudAlert>
            }
            else
            {
                @* Advanced Mode - matching rules are managed per sync rule *@
                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudText Class="mt-3">
                        Define rules to match Connected System Objects to Metaverse objects. Use immutable attributes (e.g., employeeID, objectGUID).
                        Multiple rules can be ordered; the first match wins. Objects are Joined when matched, Disconnected when not.
                    </MudText>
                }
                else if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    <MudText Class="mt-3">
                        Define rules to match Metaverse objects to Connected System Objects. Use immutable attributes (e.g., employeeID, objectGUID).
                        Multiple rules can be ordered; the first match wins.
                    </MudText>
                }

                <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
                    OnClick="HandleOpenAddMatchingRuleMappingDialog" Color="Color.Default" Class="mt-5" DropShadow="false"
                    Disabled="@(_syncRule.MetaverseObjectType == null || _syncRule.ConnectedSystemObjectType == null)">Add Matching
                    Rule</MudButton>

                @foreach (var objectMatchingRule in _syncRule.ObjectMatchingRules.OrderBy(omr => omr.Order))
                {
                    var sourceType = objectMatchingRule.GetSourceType();
                    <MudPaper Class="pa-4 mt-5" Outlined="true">
                        @if (sourceType == SyncRuleMappingSourcesType.AttributeMapping && objectMatchingRule.TargetMetaverseAttribute !=
                                null)
                        {
                            var source = objectMatchingRule.Sources[0];
                            if (source.ConnectedSystemAttribute != null)
                            {
                                <MudGrid Spacing="0">
                                    <MudItem xs="6">
                                        <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span>
                                            @objectMatchingRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                                    </MudItem>
                                    <MudItem xs="6" Class="d-flex align-center justify-end">
                                        <MudText Typo="Typo.overline">POSITION: @(objectMatchingRule.Order + 1)</MudText>
                                    </MudItem>
                                    <MudItem xs="12" Class="d-flex align-center">
                                        <MudChip T="string">
                                            <AvatarContent>
                                                <MudTooltip Text="Connected System Attribute">
                                                    <MudAvatar>CS</MudAvatar>
                                                </MudTooltip>
                                            </AvatarContent>
                                            <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                                        </MudChip>
                                        <MudChip T="string">
                                            <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.DragHandle"></MudIcon>
                                        </MudChip>
                                        <MudChip T="string">
                                            <AvatarContent>
                                                <MudTooltip Text="Metaverse Attribute">
                                                    <MudAvatar>MV</MudAvatar>
                                                </MudTooltip>
                                            </AvatarContent>
                                            <ChildContent>@objectMatchingRule.TargetMetaverseAttribute.Name</ChildContent>
                                        </MudChip>
                                        <MudSwitch T="bool" Value="@objectMatchingRule.CaseSensitive"
                                            ValueChanged="@(value => HandleToggleMatchingRuleCaseSensitive(objectMatchingRule, value))"
                                            Label="Case Sensitive" Color="Color.Primary" Size="Size.Small" Class="ms-4" />
                                        <MudSpacer />
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Color="Color.Default" Size="Size.Small"
                                            Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "up"))"
                                            Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "up")" />
                                        <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Default" Size="Size.Small"
                                            Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "down"))"
                                            Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "down")" />
                                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" Size="Size.Small"
                                            aria-label="delete" OnClick="@(() => HandleObjectMatchingRuleDeleteClickAsync(objectMatchingRule))">
                                        </MudIconButton>
                                    </MudItem>
                                </MudGrid>
                            }
                        }
                    </MudPaper>
                }
            }
        </MudPaper>

        <MudDialog @bind-Visible="_addMatchingRuleDialogVisible" Options="_dialogOptions">
            <TitleContent>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Matching Rule
                </MudText>
            </TitleContent>
            <DialogContent>

                <MudSelect T="string" Label="Source Type" Placeholder="Please select the type of source for this matching rule"
                    Required="true" ValueChanged="HandleAddMatchingRuleMappingTypeValueChange" Variant="Variant.Outlined">
                    <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                    <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
                </MudSelect>

                @if (_matchingRuleMapping != null && _matchingRuleMappingSource != null)
                {
                    @switch (_matchingRuleMappingSourceType)
                    {
                        case "Attribute":
                            {
                                <MudSelect T="MetaverseAttribute" @bind-Value="_matchingRuleMapping.TargetMetaverseAttribute"
                                    Label="Metaverse Attribute" Placeholder="Please select a Metaverse attribute" Required="true" Class="mt-5"
                                    Variant="Variant.Outlined">
                                    @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(a => a.AttributePlurality
                                                == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                    {
                                        <MudSelectItem Value="@metaverseAttribute">
                                            @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                                @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                        </MudSelectItem>
                                    }
                                </MudSelect>

                                if (_matchingRuleMapping.TargetMetaverseAttribute != null)
                                {
                                    <MudSelect T="ConnectedSystemObjectTypeAttribute"
                                        @bind-Value="_matchingRuleMappingSource.ConnectedSystemAttribute" Label="Connected System Attribute"
                                        Placeholder="Please select the Connected System attribute" Required="true" Class="mt-5"
                                        Variant="Variant.Outlined">
                                        @foreach (var connectedSystemObjectTypeAttribute in _syncRule.ConnectedSystemObjectType.Attributes.Where(a
                                                    => a.AttributePlurality == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                        {
                                            <MudSelectItem Value="@connectedSystemObjectTypeAttribute"
                                                Disabled="@(connectedSystemObjectTypeAttribute.Type != _matchingRuleMapping.TargetMetaverseAttribute.Type)">
                                                @connectedSystemObjectTypeAttribute.Name <span
                                                    style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemObjectTypeAttribute.Type :
                                                    @connectedSystemObjectTypeAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                            </MudSelectItem>
                                        }
                                    </MudSelect>

                                    <MudCheckBox T="bool" @bind-Value="_matchingRuleMapping.CaseSensitive" Label="Case Sensitive" Class="mt-5" />
                                }
                                break;
                            }
                        case "Expression":
                            <MudText Class="mt-5">Sorry, expressions are not yet supported.</MudText>
                            break;
                    }
                }
            </DialogContent>
            <DialogActions>
                <MudButton Disabled="DisableAddMappingButton()" DropShadow="false" Variant="Variant.Filled"
                    Color="Color.Primary" OnClick="HandleAddMappingButtonClick" Class="ma-4">Add Matching Rule</MudButton>
            </DialogActions>
        </MudDialog>
    }

    @* Scoping criteria are only applicable to export sync rules *@
    @if (_syncRule.Id > 0 && _syncRule.Direction == SyncRuleDirection.Export && _syncRule.MetaverseObjectType != null)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <MudText Typo="Typo.h5">Metaverse Object Scope</MudText>
            <MudText Class="mt-5">
                By default, all Metaverse objects of type '@_syncRule.MetaverseObjectType.Name' will be in scope of this
                Synchronisation Rule, though to
                have it apply to a subset of those objects, use a filter. i.e. you might only want this rule to apply to Staff,
                not Contractors.
            </MudText>
            <MudRadioGroup @bind-Value="_syncRuleScopingFiltered" Class="mt-5">
                <MudRadio Value="false">All Objects</MudRadio>
                <MudRadio Value="true">Filtered</MudRadio>
            </MudRadioGroup>

            @if (_syncRuleScopingFiltered)
            {
                @if (_syncRule.ObjectScopingCriteriaGroups.Count == 0)
                {
                    <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
                        OnClick="HandleOpenAddScopingCriteriaGroupDialog" Class="mt-5" DropShadow="false">Add Criteria Group</MudButton>
                }

                <MudDialog @bind-Visible="_addScopingCriteriaGroupDialogVisible" Options="_dialogOptions">
                    <TitleContent>
                        <MudText Typo="Typo.h6">
                            <MudIcon Icon="@Icons.Material.Filled.AccountTree" Class="mr-3" /> Add Criteria Group
                        </MudText>
                    </TitleContent>
                    <DialogContent>
                        <MudSelect T="string" Label="Please choose a group type" Required="true" Variant="Variant.Outlined"
                            @bind-Value="_criteriaGroupTypeText">
                            @foreach (var type in Enum.GetValues(typeof(SearchGroupType)))
                            {
                                <MudSelectItem Value="@type.ToString()" />
                            }
                        </MudSelect>
                    </DialogContent>
                    <DialogActions>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="HandleAddCriteriaGroupButtonClick"
                            Disabled="DisableAddScopingCriteriaGroupFormButton()" DropShadow="false" Class="ma-4">Add Group
                        </MudButton>
                    </DialogActions>
                </MudDialog>
            }
        </MudPaper>

        @foreach (var rootCriteriaGroup in _syncRule.ObjectScopingCriteriaGroups)
        {
            <SyncRuleDetailScopingCriteriaGroup SyncRule="_syncRule" SyncRuleScopingCriteriaGroup="rootCriteriaGroup"
                SyncRuleChanged="HandleStateHasChanged" SyncRuleScopingCriteriaGroupChanged="HandleStateHasChanged" />
        }
    }

    <MudText Typo="Typo.h5" Class="mt-5">Attribute Flow</MudText>
    <MudButton StartIcon="@Icons.Material.Filled.Add" Variant="Variant.Filled"
        OnClick="HandleOpenAddAttributeFlowRuleDialog" Color="Color.Default" Class="mt-5 mb-5"
        Disabled="DisableAddAttributeFlowButton()" DropShadow="false">Add Attribute Flow</MudButton>

    <MudDialog @bind-Visible="_addAttributeFlowRuleDialogVisible" Options="_dialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Attribute Flow
            </MudText>
        </TitleContent>
        <DialogContent>
            <MudSelect T="string" Label="Source Type" Placeholder="Please select the type of source for this attribute flow"
                Required="true" @bind-Value="_attributeFlowMappingSourceType" Variant="Variant.Outlined">
                <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                <MudSelectItem Value="@("Function")">Function</MudSelectItem>
                <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
            </MudSelect>

            @if (_attributeFlowMapping != null && _attributeFlowMappingSource != null && _syncRule.MetaverseObjectType !=
                    null)
            {
                @switch (_attributeFlowMappingSourceType)
                {
                    case "Attribute":
                        {
                            if (_syncRule.Direction == SyncRuleDirection.Import)
                            {
                                <MudSelect T="ConnectedSystemObjectTypeAttribute"
                                    @bind-Value="_attributeFlowMappingSource.ConnectedSystemAttribute" Label="Connected System Attribute"
                                    Placeholder="Please select the source Connected System attribute" Required="true" Class="mt-5"
                                    Variant="Variant.Outlined">
                                    @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType.Attributes)
                                    {
                                        <MudSelectItem Value="@connectedSystemAttribute">@connectedSystemAttribute.Name <span
                                                style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type :
                                                @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                        </MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            else if (_syncRule.Direction == SyncRuleDirection.Export)
                            {
                                <MudSelect T="MetaverseAttribute" @bind-Value="_attributeFlowMappingSource.MetaverseAttribute"
                                    Label="Metaverse Attribute" Placeholder="Please select the source Metaverse attribute" Required="true"
                                    Class="mt-5" Variant="Variant.Outlined">
                                    @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes)
                                    {
                                        <MudSelectItem Value="@metaverseAttribute">@metaverseAttribute.Name <span
                                                style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                                @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span></MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            break;
                        }
                    case "Function":
                        <MudAlert Severity="Severity.Error" Class="mt-5">Sorry, functions are no yet supported.</MudAlert>
                        break;
                    case "Expression":
                        <MudAlert Severity="Severity.Error" Class="mt-5">Sorry, expressions are no yet supported.</MudAlert>
                        break;
                }

                // user must have chosen the source attribute before being shown the target attribute controls
                if (_attributeFlowMappingSource.ConnectedSystemAttribute != null ||
                _attributeFlowMappingSource.MetaverseAttribute != null)
                {
                    <MudText Class="mt-5">Will flow to:</MudText>
                    if (_syncRule.Direction == SyncRuleDirection.Import)
                    {
                        <MudSelect T="MetaverseAttribute" @bind-Value="_attributeFlowMapping.TargetMetaverseAttribute"
                            Label="Metaverse Attribute" Placeholder="Please select the target Metaverse attribute" Required="true"
                            Class="mt-5" Variant="Variant.Outlined">
                            @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(q =>
                                        !_syncRule.AttributeFlowRules.Any(afr => afr.TargetMetaverseAttribute != null &&
                                        afr.TargetMetaverseAttribute.Id == q.Id)))
                            {
                                <MudSelectItem Disabled="IsAttributeFlowTargetDisabled(metaverseAttribute)" Value="@metaverseAttribute">
                                    @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type :
                                        @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                    else if (_syncRule.Direction == SyncRuleDirection.Export)
                    {
                        <MudSelect T="ConnectedSystemObjectTypeAttribute"
                            @bind-Value="_attributeFlowMapping.TargetConnectedSystemAttribute" Label="Connected System Attribute"
                            Placeholder="Please select the target Connected System attribute" Required="true" Class="mt-5"
                            Variant="Variant.Outlined">
                            @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType.Attributes)
                            {
                                <MudSelectItem Disabled="IsAttributeFlowTargetDisabled(connectedSystemAttribute)"
                                    Value="@connectedSystemAttribute">
                                    @connectedSystemAttribute.Name <span
                                        style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type :
                                        @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                }
            }
        </DialogContent>
        <DialogActions>
            <MudButton DropShadow="false" Variant="Variant.Filled" Color="Color.Default"
                OnClick="@(() => _addAttributeFlowRuleDialogVisible = false)" Class="me-2">Cancel</MudButton>
            <MudButton Disabled="DisableAddAttributeFlowMappingButton()" DropShadow="false" Variant="Variant.Filled"
                Color="Color.Primary" OnClick="HandleAddAttributeFlowMappingButtonClick">Add Attribute Flow</MudButton>
        </DialogActions>
    </MudDialog>

    <MudStack Row="true" Wrap="Wrap.Wrap" Spacing="3">
        @foreach (var attributeFlowRule in _syncRule.AttributeFlowRules)
        {
            <MudPaper Class="pa-3" Elevation="0" Outlined="true" Style="min-width: 200px;">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Start">
                    <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span>
                        @attributeFlowRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" Size="Size.Small"
                        Style="flex-shrink: 0;" aria-label="delete"
                        OnClick="@(() => HandleAttributeFlowRuleDeleteClick(attributeFlowRule))">
                    </MudIconButton>
                </MudStack>

                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudChip T="string">
                        <AvatarContent>
                            <MudTooltip Text="Metaverse Attribute">
                                <MudAvatar Color="Color.Dark">MV</MudAvatar>
                            </MudTooltip>
                        </AvatarContent>
                        <ChildContent>@attributeFlowRule.TargetMetaverseAttribute?.Name</ChildContent>
                    </MudChip>

                    <MudChip T="string">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.KeyboardDoubleArrowLeft"></MudIcon>
                    </MudChip>

                    foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                    {
                        if (source.ConnectedSystemAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Connected System Attribute">
                                        <MudAvatar Color="Color.Dark">CS</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (!string.IsNullOrWhiteSpace(source.Expression))
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Expression">
                                        <MudAvatar Color="Color.Secondary">Fx</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.Expression</ChildContent>
                            </MudChip>
                        }

                        <!-- some thought needs to be given to how we handle specifying constant values -->
                    }
                }
                else if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                    {
                        if (source.MetaverseAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Metaverse Attribute">
                                        <MudAvatar Color="Color.Dark">MV</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.MetaverseAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (!string.IsNullOrWhiteSpace(source.Expression))
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Expression">
                                        <MudAvatar Color="Color.Secondary">Fx</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.Expression</ChildContent>
                            </MudChip>
                        }

                        <!-- some thought needs to be given to how we handle specifying constant values -->
                    }

                    <MudChip T="string">
                        <MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.KeyboardDoubleArrowRight"></MudIcon>
                    </MudChip>

                    <MudChip T="string">
                        <AvatarContent>
                            <MudTooltip Text="Connected System Attribute">
                                <MudAvatar Color="Color.Dark">CS</MudAvatar>
                            </MudTooltip>
                        </AvatarContent>
                        <ChildContent>@attributeFlowRule.TargetConnectedSystemAttribute?.Name</ChildContent>
                    </MudChip>
                }
            </MudPaper>
        }
    </MudStack>

    @if (_syncRule.Validate().Count > 0)
    {
        <MudAlert Severity="Severity.Normal" Class="mt-5">
            <MudText Class="mb-3">There are issues:</MudText>
            @foreach (var item in _syncRule.Validate())
            {
                <div class="d-flex align-center mb-2">
                    <MudIcon Class="mr-2" Color="@(item.Level == ValidityStatusItemLevel.Warning ? Color.Warning : Color.Error)"
                        Icon="@(item.Level == ValidityStatusItemLevel.Warning ? @Icons.Material.Filled.Warning : @Icons.Material.Filled.Error)" />
                    <MudText>@item.Message</MudText>
                </div>
            }
        </MudAlert>
    }

    <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-5" OnClick="HandleCreateOrUpdateSyncRuleAsync"
        Disabled="!_syncRule.IsValid()" DropShadow="false">@(_syncRule.Id == 0 ? "Create" : "Update") Sync Rule
    </MudButton>

    @if (_syncRule.Id > 0)
    {
        <MudPaper Class="pa-4 mt-20 jim-paper-danger-zone" Outlined="false">
            <MudText Typo="Typo.h5" Class="mb-3">Danger Zone</MudText>
            <MudText Class="mud-text-secondary mb-4">
                Deleting this synchronisation rule is permanent and cannot be undone. All configuration and attribute flow
                mappings will be lost.
            </MudText>
            <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Delete" OnClick="HandleDeleteSyncRuleAsync"
                DropShadow="false" Color="Color.Error">Delete Sync Rule</MudButton>
        </MudPaper>
    }
}

@code {
    [Parameter]
    public int? Id { get; set; }

    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private string _syncRuleNameOrCreate = "New";
    private List<BreadcrumbItem> _breadcrumbs = null!;
    private SyncRule? _syncRule;
    private bool _isLoading = true;
    private bool _isDetailsFormValid;
    private string[] _detailsFormErrors = { };
    private List<ConnectedSystemHeader>? _connectedSystemHeaders;
    private List<MetaverseObjectType>? _metaverseObjectTypes;

    private bool _addMatchingRuleDialogVisible;
    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private ObjectMatchingRule? _matchingRuleMapping;
    private ObjectMatchingRuleSource? _matchingRuleMappingSource;
    private string? _matchingRuleMappingSourceType;

    private bool _syncRuleScopingFiltered;
    private bool _addScopingCriteriaGroupDialogVisible;
    private string? _criteriaGroupTypeText;
    private SyncRuleScopingCriteriaGroup? _syncRuleScopingCriteriaGroup;

    private bool _addAttributeFlowRuleDialogVisible;
    private SyncRuleMapping? _attributeFlowMapping;
    private SyncRuleMappingSource? _attributeFlowMappingSource;
    private string? _attributeFlowMappingSourceType;

    protected override async Task OnInitializedAsync()
    {
        _breadcrumbs =
        [
        new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
new BreadcrumbItem("Synchronisation Rules", href: "/admin/connected-systems/sync-rules/")
        ];

        if (Id != null)
        {
            // edit an existing sync rule
            _syncRule = await Jim.ConnectedSystems.GetSyncRuleAsync(Id.Value);
            if (_syncRule == null)
            {
                // sync rule not found, redirect to index page
                _isLoading = false;
                NavManager.NavigateTo("../");
                return;
            }

            _syncRuleNameOrCreate = _syncRule.Name;
            _breadcrumbs.Add(new BreadcrumbItem(_syncRule.Name, href: null, disabled: true));

            // initialise scoping filter state based on existing criteria
            _syncRuleScopingFiltered = _syncRule.ObjectScopingCriteriaGroups.Count > 0;
        }
        else
        {
            // create a new sync rule
            _syncRule = new SyncRule();
            _breadcrumbs.Add(new BreadcrumbItem("New", href: null, disabled: true));
            _connectedSystemHeaders = await Jim.ConnectedSystems.GetConnectedSystemHeadersAsync();
            _metaverseObjectTypes = await Jim.Metaverse.GetMetaverseObjectTypesAsync(true);
        }

        _isLoading = false;
    }

    private async Task HandleConnectedSystemSelectedAsync(string connectedSystemId)
    {
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;

        // convert to int and assign to SR
        var connectedSystemIdInt = int.Parse(connectedSystemId);
        var connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(connectedSystemIdInt);
        if (connectedSystem == null)
            return;

        _syncRule.ConnectedSystem = connectedSystem;
        Console.WriteLine($"HandleConnectedSystemSelectedAsync: Assigned ConnectedSystem: {_syncRule.ConnectedSystem}");
    }

    private void HandleSyncRuleDirectionSelection(string syncRuleDirection)
    {
        // convert to enum and assign to sr
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;

        var syncRuleDirectionEnum = (SyncRuleDirection)Enum.Parse(typeof(SyncRuleDirection), syncRuleDirection);
        _syncRule.Direction = syncRuleDirectionEnum;
        Console.WriteLine($"HandleSyncRuleDirectionSelection: Assigned SyncRuleDirection: {_syncRule.Direction}");

        // reset provision/project choices
        _syncRule.ProvisionToConnectedSystem = false;
        _syncRule.ProjectToMetaverse = false;
    }

    private void HandleOpenAddMatchingRuleMappingDialog()
    {
        if (_syncRule == null)
            return;

        if (_matchingRuleMapping == null)
        {
            _matchingRuleMapping = new ObjectMatchingRule
            {
                Order = _syncRule.ObjectMatchingRules.Count == 0 ? 0 : _syncRule.ObjectMatchingRules.Select(q => q.Order).Max() + 1
            };
            _matchingRuleMappingSource = new ObjectMatchingRuleSource();
        }
        else
        {
            if (_matchingRuleMappingSource == null)
                return;
        }

        _matchingRuleMapping.Sources.Add(_matchingRuleMappingSource);
        _addMatchingRuleDialogVisible = true;
    }

    private void HandleAddMatchingRuleMappingTypeValueChange(string mappingType)
    {
        _matchingRuleMappingSource ??= new ObjectMatchingRuleSource();
        _matchingRuleMappingSourceType = mappingType;
    }

    private bool DisableAddMappingButton()
    {
        if (_matchingRuleMapping == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping NULL");
            return true;
        }

        if (_matchingRuleMappingSource == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMappingSource NULL");
            return true;
        }

        if (_matchingRuleMapping.TargetMetaverseAttribute == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.TargetMetaverseAttribute NULL");
            return true;
        }

        // the rest depends on what type of source has been chosen by the user
        // Must have either a connected system attribute or an expression
        if (_matchingRuleMappingSource.ConnectedSystemAttribute == null &&
        string.IsNullOrWhiteSpace(_matchingRuleMappingSource.Expression))
        {
            Console.WriteLine("DisableAddMappingButton: attrib/expression missing");
            return true;
        }

        return false;
    }

    private void HandleAddMappingButtonClick()
    {
        if (_syncRule == null || _matchingRuleMapping == null)
            return;

        // add the mapping to the rule
        _syncRule.ObjectMatchingRules.Add(_matchingRuleMapping);

        // close the add mapping dialog
        _addMatchingRuleDialogVisible = false;

        // re-initialise the mapping rule and source, ready for the next use
        _matchingRuleMapping = null;
        _matchingRuleMappingSource = null;
    }

    private async Task HandleObjectMatchingRuleDeleteClickAsync(ObjectMatchingRule objectMatchingRule)
    {
        if (_syncRule == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to remove this Matching Rule?", yesText: "Remove!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            _syncRule.ObjectMatchingRules.Remove(objectMatchingRule);

            // re-order the items
            var orderedItems = _syncRule.ObjectMatchingRules.OrderBy(q => q.Order).ToList();
            for (var i = 0; i < orderedItems.Count; i++)
                orderedItems[i].Order = i;
        }
    }

    private void HandleToggleMatchingRuleCaseSensitive(ObjectMatchingRule rule, bool caseSensitive)
    {
        if (_syncRule == null)
            return;

        // Update the local value - changes will be saved when user saves the sync rule
        rule.CaseSensitive = caseSensitive;
        Snackbar.Add($"Matching rule is now {(caseSensitive ? "case-sensitive" : "case-insensitive")}. Remember to save the sync rule.", Severity.Info);
        StateHasChanged();
    }

    private void HandleObjectMatchingRuleChangeOrder(ObjectMatchingRule objectMatchingRule, string direction)
    {
        // invalid scenarios
        if (_syncRule == null || _syncRule.ObjectMatchingRules.Count == 1)
            return;

        if (direction == "up")
        {
            // cannot promote the first item
            if (objectMatchingRule.Order == 0)
                return;

            var precedingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order - 1));
            precedingItem.Order++;
            objectMatchingRule.Order--;
        }
        else
        {
            // cannot demote the last item
            if (objectMatchingRule.Order == (_syncRule.ObjectMatchingRules.Count - 1))
                return;

            var followingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order + 1));
            followingItem.Order--;
            objectMatchingRule.Order++;
        }
    }

    private bool DisableObjectMatchingMappingRuleOrderButton(ObjectMatchingRule objectMatchingRule, string direction)
    {
        if (_syncRule == null)
            return true;

        switch (direction)
        {
            case "up" when objectMatchingRule.Order == 0:
            case "down" when objectMatchingRule.Order == _syncRule.ObjectMatchingRules.Max(q => q.Order):
                return true;
            default:
                return false;
        }
    }

    private void HandleOpenAddScopingCriteriaGroupDialog()
    {
        Console.WriteLine("HandleOpenAddScopingCriteriaGroupDialog: Called");
        _syncRuleScopingCriteriaGroup = new SyncRuleScopingCriteriaGroup();
        _addScopingCriteriaGroupDialogVisible = true;
    }

    private bool DisableAddScopingCriteriaGroupFormButton()
    {
        Console.WriteLine($"DisableAddScopingCriteriaGroupFormButton: '{_criteriaGroupTypeText}'");
        return string.IsNullOrEmpty(_criteriaGroupTypeText);
    }

    private void HandleAddCriteriaGroupButtonClick()
    {
        if (_syncRule == null || _syncRuleScopingCriteriaGroup == null || _criteriaGroupTypeText == null)
            return;

        _syncRuleScopingCriteriaGroup.Type = (SearchGroupType)Enum.Parse(typeof(SearchGroupType), _criteriaGroupTypeText);

        if (_syncRuleScopingCriteriaGroup.ParentGroup == null)
        {
            // root-level criteria group
            _syncRule.ObjectScopingCriteriaGroups.Add(_syncRuleScopingCriteriaGroup);
        }
        else
        {
            // add the criteria group to the parent's children, i.e. make sure the relationship is established on both the parent
            // and the new criteria group
            _syncRuleScopingCriteriaGroup.ParentGroup.ChildGroups.Add(_syncRuleScopingCriteriaGroup);
        }

        // all done, reset
        _addScopingCriteriaGroupDialogVisible = false;
        _syncRuleScopingCriteriaGroup = null;
    }

    private void HandleStateHasChanged()
    {
        // yes, this is necessary.
        StateHasChanged();
    }

    private async Task HandleCreateOrUpdateSyncRuleAsync()
    {
        if (_syncRule == null)
            return;

        // are we transitioning from new to existing?
        var isSyncRuleNew = _syncRule.Id == 0;

        // attribute the operation to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        var wasSuccessful = await Jim.ConnectedSystems.CreateOrUpdateSyncRuleAsync(_syncRule, user);
        switch (wasSuccessful)
        {
            // send the user to the existing-sync-rule view.
            // this helps ensure links are good to be shared/bookmarked, etc.
            case true when isSyncRuleNew:
                NavManager.NavigateTo($"/admin/connected-systems/sync-rules/{_syncRule.Id}");
                break;
            case true:
                Snackbar.Add("Changes saved.", Severity.Success);
                break;
            case false:
                Snackbar.Add("There was a problem saving your changes. Please check the details and try again.", Severity.Error);
                break;
        }
    }

    private bool DisableAddAttributeFlowButton()
    {
        if (_syncRule?.MetaverseObjectType == null)
            return true;

        if (_syncRule?.ConnectedSystemObjectType == null)
            return true;

        return false;
    }

    private void HandleOpenAddAttributeFlowRuleDialog()
    {
        if (_syncRule == null)
            return;

        _attributeFlowMapping = new SyncRuleMapping();
        _attributeFlowMappingSource = new SyncRuleMappingSource();
        _attributeFlowMapping.Sources.Add(_attributeFlowMappingSource);
        _addAttributeFlowRuleDialogVisible = true;
    }

    private bool DisableAddAttributeFlowMappingButton()
    {
        if (_attributeFlowMapping == null)
            return true;

        if (_attributeFlowMappingSource == null)
            return true;

        if (_attributeFlowMappingSourceType == null)
            return true;

        return false;
    }

    // import rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(MetaverseAttribute targetMetaverseAttribute)
    {
        if (_attributeFlowMappingSource?.ConnectedSystemAttribute == null)
            return true;

        if (targetMetaverseAttribute.Type != _attributeFlowMappingSource.ConnectedSystemAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetMetaverseAttribute.AttributePlurality == AttributePlurality.SingleValued &&
        _attributeFlowMappingSource.ConnectedSystemAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;

        return false;
    }

    // export rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(ConnectedSystemObjectTypeAttribute targetConnectedSystemObjectTypeAttribute)
    {
        if (_attributeFlowMappingSource?.MetaverseAttribute == null)
            return true;

        if (targetConnectedSystemObjectTypeAttribute.Type != _attributeFlowMappingSource.MetaverseAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetConnectedSystemObjectTypeAttribute.AttributePlurality == AttributePlurality.SingleValued &&
        _attributeFlowMappingSource.MetaverseAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;

        return false;
    }

    private void HandleAddAttributeFlowMappingButtonClick()
    {
        if (_syncRule == null || _attributeFlowMapping == null)
            return;

        // add the mapping to the rule
        _syncRule.AttributeFlowRules.Add(_attributeFlowMapping);

        // close the add attribute flow dialog
        _addAttributeFlowRuleDialogVisible = false;

        // re-initialise the attribute flow rule and source, ready for the next use
        _attributeFlowMapping = null;
        _attributeFlowMappingSource = null;
    }

    private void HandleAttributeFlowRuleDeleteClick(SyncRuleMapping attributeFlowRule)
    {
        _syncRule?.AttributeFlowRules.Remove(attributeFlowRule);
    }

    private async Task HandleDeleteSyncRuleAsync()
    {
        if (_syncRule == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to delete this Synchronisation Rule?", yesText: "Delete!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            // attribute the operation to the signed-in user
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
            await Jim.ConnectedSystems.DeleteSyncRuleAsync(_syncRule, user);
            NavManager.NavigateTo("/admin/connected-systems/sync-rules");
        }
    }
}
