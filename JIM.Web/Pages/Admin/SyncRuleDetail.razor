@page "/admin/connected-systems/sync-rules/new"
@page "/admin/connected-systems/sync-rules/{Id:int}"
@attribute [Authorize(Roles = "Administrators")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Logic
@using JIM.Models.Search
@using JIM.Models.Staging
@using JIM.Models.Staging.DTOs
@using JIM.Models.Utility
@using JIM.Utilities
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<PageTitle>Synchronisation Rule: @_syncRuleNameOrCreate</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Synchronisation Rule:</span> @_syncRuleNameOrCreate</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>

@if (_syncRule != null)
{
    <MudPaper Class="pa-4 mt-5" Outlined="true">

        <div class="d-flex justify-space-between">
            <MudText Typo="Typo.h5" Class="mb-5">Details</MudText>
            @if (_syncRule.Id > 0)
            {
                <MudText Class="mud-text-secondary mud-text-small" Typo="Typo.body2">
                    Created: @_syncRule.Created.ToShortDateString() (@_syncRule.Created.ToShortTimeString())
                    @if (_syncRule.CreatedBy != null)
                    {
                        <span> - By: <MudLink Href="@Utilities.GetMetaverseObjectHref(_syncRule.CreatedBy)">@_syncRule.CreatedBy.DisplayName</MudLink></span>
                    }
                    @if (_syncRule.LastUpdated.HasValue)
                    {
                        <span> - Last Updated: @_syncRule.LastUpdated.Value.ToShortDateString() (@_syncRule.LastUpdated.Value.ToShortTimeString())</span>
                    }
                </MudText>
            }
        </div>

        <MudForm @bind-IsValid="@_isDetailsFormValid" @bind-Errors="@_detailsFormErrors">
            <MudTextField Label="Name" Required="true" RequiredError="A name is required" @bind-Value="_syncRule.Name" Variant="Variant.Outlined"/>
            @if (_syncRule.Id == 0)
            {
                @if (_connectedSystemHeaders != null)
                {
                    <MudSelect
                        T="string"
                        Label="Connected System"
                        Placeholder="Please select a Connected System..."
                        Required="true"
                        ValueChanged="HandleConnectedSystemSelectedAsync"
                        AdornmentIcon="@Icons.Material.Filled.Power"
                        Adornment="Adornment.Start"
                        Variant="Variant.Outlined"
                        Class="mt-5">
                        @foreach (var header in _connectedSystemHeaders)
                        {
                            <MudSelectItem Value="@header.Id.ToString()">@header.Name</MudSelectItem>
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null)
                {
                    <MudSelect
                        T="string"
                        Label="Direction"
                        Placeholder="Please select an attribute flow direction..."
                        Required="true"
                        ValueChanged="HandleSyncRuleDirectionSelection"
                        Variant="Variant.Outlined"
                        Class="mt-5">
                        @foreach (SyncRuleDirection direction in Enum.GetValues(typeof(SyncRuleDirection)))
                        {
                            if (direction != SyncRuleDirection.NotSet)
                            {
                                // does the connector definition support this direction?
                                var directionSupported = false;
                                if (direction == SyncRuleDirection.Export)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsExport;
                                }
                                else if (direction == SyncRuleDirection.Import)
                                {
                                    directionSupported = _syncRule.ConnectedSystem.ConnectorDefinition.SupportsDeltaImport || _syncRule.ConnectedSystem.ConnectorDefinition.SupportsFullImport;
                                }

                                <MudSelectItem Disabled="!directionSupported" Value="@direction.ToString()">@direction@(directionSupported ? "" : " (not supported by Connector)")</MudSelectItem>
                            }
                        }
                    </MudSelect>
                }

                @if (_syncRule.ConnectedSystem != null && _syncRule.Direction != SyncRuleDirection.NotSet && _metaverseObjectTypes != null && _syncRule.ConnectedSystem is { ObjectTypes: not null })
                {
                    <MudGrid>
                        <MudItem xs="5">
                            <MudSelect
                                T="MetaverseObjectType"
                                Label="Metaverse Object Type"
                                @bind-Value="@_syncRule.MetaverseObjectType"
                                Required="true"
                                Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var mvObjectType in _metaverseObjectTypes)
                                {
                                    <MudSelectItem Value="@mvObjectType">@mvObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                        <MudItem xs="2">
                            <MudPaper Outlined="false" Elevation="0" Class="d-flex flex-column align-center justify-center mud-width-full py-10">
                                <MudIcon Size="Size.Medium" Icon="@(_syncRule.Direction == SyncRuleDirection.Export ? Icons.Material.Filled.KeyboardDoubleArrowRight : Icons.Material.Filled.KeyboardDoubleArrowLeft)"></MudIcon>
                            </MudPaper>
                        </MudItem>
                        <MudItem xs="5">
                            <MudSelect
                                T="ConnectedSystemObjectType"
                                Label="Connected System Object Type"
                                @bind-Value="@_syncRule.ConnectedSystemObjectType"
                                Required="true"
                                Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var csObjectType in _syncRule.ConnectedSystem.ObjectTypes.Where(ot => ot.Selected))
                                {
                                    <MudSelectItem Value="@csObjectType">@csObjectType.Name</MudSelectItem>
                                }
                            </MudSelect>
                        </MudItem>
                    </MudGrid>
                }

                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudSwitch @bind-Value="@_syncRule.ProjectToMetaverse" Color="Color.Primary" Label="Create imported objects in the Metaverse?"/>
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, objects imported from this Connected System matched in this synchronisation rule will not result in a Metaverse object being created. Enabling this option causes the object to be projected to the Metaverse, allowing it to be managed within JIM and synchronised to other Connected Systems. You would typically enable this for a source system, i.e. a HR system.</MudAlert>
                }

                @if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    <MudSwitch @bind-Value="@_syncRule.ProvisionToConnectedSystem" Color="Color.Primary" Label="Create objects in the Connected System?"/>
                    <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">By default, Metaverse objects matched in this synchronisation rule will not be created (provisioned) in the Connected Systems. Enabling this option will cause the Metaverse object to be created in the Connected System. You would typically enable this option for a destination system, i.e. when trying to implement a HR to Active Directory flow.</MudAlert>
                }
            }
        </MudForm>
        <MudSwitch Class="mt-5" @bind-Value="@_syncRule.Enabled" Color="Color.Primary" Label="Enabled?"/>
        <MudAlert Class="mt-5" Severity="Severity.Normal" Variant="Variant.Text">Synchronisation Rules will not be evaluated when disabled, enabling you to either prepare a rule in advance of it being needed, or to temporarily stop evaluating a sync rule..</MudAlert>
        
    </MudPaper>

    @if (_syncRule.Direction == SyncRuleDirection.Import)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <MudText Typo="Typo.h5">Matching Rules</MudText>
            <MudText Class="mt-5">
                At lest one matching rule is needed to ensure JIM can associate a Connected System Object from this sync rule with a matching Metaverse object.
                It's strongly recommended that you choose an immutable attribute on both sides, i.e. one that won't change for the life of the object.
                You can define multiple rules, and order them. The first to match will be used. Common examples might include: employeeID = employeeID, or ActiveDirectoryObjectGuid = objectGUID.
                A Connected System Object is considered Joined when a matching Metaverse object is found, and Disconnected when not.
            </MudText>

            <MudButton 
                StartIcon="@Icons.Material.Filled.Add"
                Variant="Variant.Filled"
                OnClick="HandleOpenAddMatchingRuleMappingDialog"
                Color="Color.Default"
                Class="mt-5"
                DropShadow="false"
                Disabled="@(_syncRule.MetaverseObjectType == null || _syncRule.ConnectedSystemObjectType == null)">Add Matching Rule</MudButton>

            @foreach (var objectMatchingRule in _syncRule.ObjectMatchingRules.OrderBy(omr => omr.Order))
            {
                var sourceType = objectMatchingRule.GetSourceType();
                <MudPaper Class="pa-4 mt-5" Outlined="true">
                    @if (sourceType == SyncRuleMappingSourcesType.AttributeMapping && objectMatchingRule.TargetMetaverseAttribute != null)
                    {
                        var source = objectMatchingRule.Sources[0];
                        if (source.ConnectedSystemAttribute != null)
                        {
                            <MudGrid Spacing="0">
                                <MudItem xs="6">
                                    <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span> @objectMatchingRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText>
                                </MudItem>
                                <MudItem xs="6" Class="d-flex align-center justify-end">
                                    <MudText Typo="Typo.overline">POSITION: @(objectMatchingRule.Order + 1)</MudText>
                                </MudItem>
                                <MudItem xs="6">
                                    <MudChip T="string">
                                        <AvatarContent>
                                            <MudTooltip Text="Metaverse Attribute">
                                                <MudAvatar>MV</MudAvatar>
                                            </MudTooltip>
                                        </AvatarContent>
                                        <ChildContent>@objectMatchingRule.TargetMetaverseAttribute.Name</ChildContent>
                                    </MudChip>
                                    <MudChip T="string"><MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.DragHandle"></MudIcon></MudChip>
                                    <MudChip T="string">
                                        <AvatarContent>
                                            <MudTooltip Text="Connected System Attribute">
                                                <MudAvatar>CS</MudAvatar>
                                            </MudTooltip>
                                        </AvatarContent>
                                        <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                                    </MudChip>
                                </MudItem>
                                <MudItem xs="6" Class="d-flex align-center justify-end">
                                    <MudIconButton Icon="@Icons.Material.Filled.ArrowUpward" Color="Color.Default" Size="Size.Small" Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "up"))" Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "up")" />
                                    <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward" Color="Color.Default" Size="Size.Small" Class="me-3" OnClick="@(() => HandleObjectMatchingRuleChangeOrder(objectMatchingRule, "down"))" Disabled="@DisableObjectMatchingMappingRuleOrderButton(objectMatchingRule, "down")" />
                                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" Size="Size.Small" aria-label="delete" OnClick="@(() => HandleObjectMatchingRuleDeleteClickAsync(objectMatchingRule))"></MudIconButton>
                                </MudItem>
                            </MudGrid>
                        }
                    }
                </MudPaper>
            }
        </MudPaper>

        <MudDialog @bind-Visible="_addMatchingRuleDialogVisible" Options="_dialogOptions">
            <TitleContent>
                <MudText Typo="Typo.h6">
                    <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Matching Rule
                </MudText>
            </TitleContent>
            <DialogContent>

                <MudSelect 
                    T="string"
                    Label="Source Type"
                    Placeholder="Please select the type of source for this matching rule"
                    Required="true"
                    ValueChanged="HandleAddMatchingRuleMappingTypeValueChange"
                    Variant="Variant.Outlined">
                    <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                    <MudSelectItem Value="@("Function")">Function</MudSelectItem>
                    <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
                </MudSelect>

                @if (_matchingRuleMapping != null && _matchingRuleMappingSource != null)
                {
                    @switch (_matchingRuleMappingSourceType)
                    {
                        case "Attribute":
                        {
                            <MudSelect
                                T="MetaverseAttribute"
                                @bind-Value="_matchingRuleMapping.TargetMetaverseAttribute"
                                Label="Metaverse Attribute"
                                Placeholder="Please select a Metaverse attribute"
                                Required="true"
                                Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(a => a.AttributePlurality == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                {
                                    <MudSelectItem Value="@metaverseAttribute">
                                        @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type : @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                    </MudSelectItem>
                                }
                            </MudSelect>

                            if (_matchingRuleMapping.TargetMetaverseAttribute != null)
                            {
                                <MudSelect 
                                    T="ConnectedSystemObjectTypeAttribute"
                                    @bind-Value="_matchingRuleMappingSource.ConnectedSystemAttribute"
                                    Label="Connected System Attribute"
                                    Placeholder="Please select the Connected System attribute"
                                    Required="true"
                                    Class="mt-5"
                                    Variant="Variant.Outlined">
                                    @foreach (var connectedSystemObjectTypeAttribute in _syncRule.ConnectedSystemObjectType.Attributes.Where(a => a.AttributePlurality == AttributePlurality.SingleValued).OrderBy(a => a.Name))
                                    {
                                        <MudSelectItem Value="@connectedSystemObjectTypeAttribute" Disabled="@(connectedSystemObjectTypeAttribute.Type != _matchingRuleMapping.TargetMetaverseAttribute.Type)">
                                            @connectedSystemObjectTypeAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemObjectTypeAttribute.Type : @connectedSystemObjectTypeAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                        </MudSelectItem>
                                    }
                                </MudSelect>
                            }
                            break;
                        }
                        case "Function":
                            <MudText Class="mt-5">Sorry, functions are not yet supported.</MudText>
                            break;
                        case "Expression":
                            <MudText Class="mt-5">Sorry, expressions are not yet supported.</MudText>
                            break;
                    }
                }
            </DialogContent>
            <DialogActions>
                <MudButton 
                    Disabled="DisableAddMappingButton()" 
                    DropShadow="false" 
                    Variant="Variant.Filled" 
                    Color="Color.Primary" 
                    OnClick="HandleAddMappingButtonClick" 
                    Class="ma-4">Add Matching Rule</MudButton>
            </DialogActions>
        </MudDialog>
    }
    else if (_syncRule.MetaverseObjectType != null)
    {
        <MudPaper Class="pa-4 mt-5" Outlined="true">
            <MudText Typo="Typo.h5">Metaverse Object Scope</MudText>
            <MudText Class="mt-5">
                By default, all Metaverse objects of type '@_syncRule.MetaverseObjectType.Name' will be in scope of this Synchronisation Rule, though to
                have it apply to a subset of those objects, use a filter. i.e. you might only want this rule to apply to Staff, not Contractors.
            </MudText>
            <MudRadioGroup @bind-Value="_syncRuleScopingFiltered" Class="mt-5">
                <MudRadio Value="false">All Objects</MudRadio>
                <MudRadio Value="true">Filtered</MudRadio>
            </MudRadioGroup>

            @if (_syncRuleScopingFiltered)
            {
                @if (_syncRule.ObjectScopingCriteriaGroups.Count == 0)
                {
                    <MudButton StartIcon="@Icons.Material.Filled.Add"
                           Variant="Variant.Filled"
                           OnClick="HandleOpenAddScopingCriteriaGroupDialog"
                           Class="mt-5"
                           DropShadow="false">Add Criteria Group</MudButton>
                }

                <MudDialog @bind-Visible="_addScopingCriteriaGroupDialogVisible" Options="_dialogOptions">
                    <TitleContent>
                        <MudText Typo="Typo.h6">
                            <MudIcon Icon="@Icons.Material.Filled.AccountTree" Class="mr-3" /> Add Criteria Group
                        </MudText>
                    </TitleContent>
                    <DialogContent>
                        <MudSelect 
                            T="string"
                            Label="Please choose a group type"
                            Required="true"
                            Variant="Variant.Outlined"
                            @bind-Value="_criteriaGroupTypeText">
                            @foreach (var type in Enum.GetValues(typeof(SearchGroupType)))
                            {
                                <MudSelectItem Value="@type.ToString()" />
                            }
                        </MudSelect>
                    </DialogContent>
                    <DialogActions>
                        <MudButton 
                            Variant="Variant.Filled"
                            Color="Color.Primary"
                            OnClick="HandleAddCriteriaGroupButtonClick"
                            Disabled="DisableAddScopingCriteriaGroupFormButton()"
                            DropShadow="false"
                            Class="ma-4">Add Group</MudButton>
                    </DialogActions>
                </MudDialog>
            }
        </MudPaper>

        @foreach (var rootCriteriaGroup in _syncRule.ObjectScopingCriteriaGroups)
        {
            <SyncRuleDetailScopingCriteriaGroup 
                SyncRule="_syncRule" 
                SyncRuleScopingCriteriaGroup="rootCriteriaGroup" 
                SyncRuleChanged="HandleStateHasChanged" 
                SyncRuleScopingCriteriaGroupChanged="HandleStateHasChanged" />
        }
    }
    
    <MudText Typo="Typo.h5" Class="mt-5">Attribute Flow</MudText>
    <MudButton 
        StartIcon="@Icons.Material.Filled.Add"
        Variant="Variant.Filled"
        OnClick="HandleOpenAddAttributeFlowRuleDialog"
        Color="Color.Default"
        Class="mt-5 mb-5"
        Disabled="DisableAddAttributeFlowButton()"
        DropShadow="false">Add Attribute Flow</MudButton>
    
    <MudDialog @bind-Visible="_addAttributeFlowRuleDialogVisible" Options="_dialogOptions">
        <TitleContent>
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.Map" Class="mr-3" /> Add Attribute Flow
            </MudText>
        </TitleContent>
        <DialogContent>
            <MudSelect 
                T="string"
                Label="Source Type"
                Placeholder="Please select the type of source for this attribute flow"
                Required="true"
                @bind-Value="_attributeFlowMappingSourceType"
                Variant="Variant.Outlined">
                <MudSelectItem Value="@("Attribute")">Attribute</MudSelectItem>
                <MudSelectItem Value="@("Function")">Function</MudSelectItem>
                <MudSelectItem Value="@("Expression")">Expression</MudSelectItem>
            </MudSelect>

            @if (_attributeFlowMapping != null && _attributeFlowMappingSource != null && _syncRule.MetaverseObjectType != null)
            {
                @switch (_attributeFlowMappingSourceType)
                {
                    case "Attribute":
                    {
                        if (_syncRule.Direction == SyncRuleDirection.Import)
                        {
                            <MudSelect 
                                T="ConnectedSystemObjectTypeAttribute"
                                @bind-Value="_attributeFlowMappingSource.ConnectedSystemAttribute"
                                Label="Connected System Attribute"
                                Placeholder="Please select the source Connected System attribute"
                                Required="true"
                                Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType.Attributes)
                                {
                                    <MudSelectItem Value="@connectedSystemAttribute">@connectedSystemAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type : @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span></MudSelectItem>
                                }
                            </MudSelect>
                        }
                        else if (_syncRule.Direction == SyncRuleDirection.Export)
                        {
                            <MudSelect
                                T="MetaverseAttribute"
                                @bind-Value="_attributeFlowMappingSource.MetaverseAttribute"
                                Label="Metaverse Attribute"
                                Placeholder="Please select the source Metaverse attribute"
                                Required="true"
                                Class="mt-5"
                                Variant="Variant.Outlined">
                                @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes)
                                {
                                    <MudSelectItem Value="@metaverseAttribute">@metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type : @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span></MudSelectItem>
                                }
                            </MudSelect>
                        }
                        break;
                    }
                    case "Function":
                        <MudAlert Severity="Severity.Error" Class="mt-5">Sorry, functions are no yet supported.</MudAlert>
                        break;
                    case "Expression":
                        <MudAlert Severity="Severity.Error" Class="mt-5">Sorry, expressions are no yet supported.</MudAlert>
                        break;
                }

                // user must have chosen the source attribute before being shown the target attribute controls
                if (_attributeFlowMappingSource.ConnectedSystemAttribute != null || _attributeFlowMappingSource.MetaverseAttribute != null)
                {
                    <MudText Class="mt-5">Will flow to:</MudText>
                    if (_syncRule.Direction == SyncRuleDirection.Import)
                    {
                        <MudSelect
                            T="MetaverseAttribute"
                            @bind-Value="_attributeFlowMapping.TargetMetaverseAttribute"
                            Label="Metaverse Attribute"
                            Placeholder="Please select the target Metaverse attribute"
                            Required="true"
                            Class="mt-5"
                            Variant="Variant.Outlined">
                            @foreach (var metaverseAttribute in _syncRule.MetaverseObjectType.Attributes.Where(q => !_syncRule.AttributeFlowRules.Any(afr => afr.TargetMetaverseAttribute != null && afr.TargetMetaverseAttribute.Id == q.Id)))
                            {
                                <MudSelectItem
                                    Disabled="IsAttributeFlowTargetDisabled(metaverseAttribute)"
                                    Value="@metaverseAttribute">
                                    @metaverseAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@metaverseAttribute.Type : @metaverseAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                    else if (_syncRule.Direction == SyncRuleDirection.Export)
                    {
                        <MudSelect
                            T="ConnectedSystemObjectTypeAttribute"
                            @bind-Value="_attributeFlowMapping.TargetConnectedSystemAttribute"
                            Label="Connected System Attribute"
                            Placeholder="Please select the target Connected System attribute"
                            Required="true"
                            Class="mt-5"
                            Variant="Variant.Outlined">
                            @foreach (var connectedSystemAttribute in _syncRule.ConnectedSystemObjectType.Attributes)
                            {
                                <MudSelectItem
                                    Disabled="IsAttributeFlowTargetDisabled(connectedSystemAttribute)"
                                    Value="@connectedSystemAttribute">
                                    @connectedSystemAttribute.Name <span style="@($"color:{Colors.Gray.Darken1};")">(@connectedSystemAttribute.Type : @connectedSystemAttribute.AttributePlurality.ToString().SplitOnCapitalLetters())</span>
                                </MudSelectItem>
                            }
                        </MudSelect>
                    }
                }
            }
        </DialogContent>
        <DialogActions>
            <MudButton 
                Disabled="DisableAddAttributeFlowMappingButton()" 
                DropShadow="false" 
                Variant="Variant.Filled" 
                Color="Color.Primary" 
                OnClick="HandleAddAttributeFlowMappingButtonClick" 
                Class="ma-4">Add Attribute Flow</MudButton>
        </DialogActions>
    </MudDialog>
    
    <MudStack Row="true">
        @foreach (var attributeFlowRule in _syncRule.AttributeFlowRules)
        {
            <MudPaper Class="pa-3" Elevation="0" Outlined="true">
                <MudStack Row="true" Justify="Justify.SpaceBetween" Wrap="Wrap.NoWrap">
                    <MudText Typo="Typo.overline"><span class="mud-text-secondary">TYPE:</span> @attributeFlowRule.GetSourceType().ToString().SplitOnCapitalLetters().ToUpper()</MudText><br/>
                    <MudIconButton 
                        Icon="@Icons.Material.Filled.Delete" 
                        Color="Color.Error" 
                        Size="Size.Small" 
                        aria-label="delete" 
                        OnClick="@(() => HandleAttributeFlowRuleDeleteClick(attributeFlowRule))"></MudIconButton>
                </MudStack>
                
                @if (_syncRule.Direction == SyncRuleDirection.Import)
                {
                    <MudChip T="string">
                        <AvatarContent>
                            <MudTooltip Text="Metaverse Attribute">
                                <MudAvatar Color="Color.Dark">MV</MudAvatar>
                            </MudTooltip>
                        </AvatarContent>
                        <ChildContent>@attributeFlowRule.TargetMetaverseAttribute?.Name</ChildContent>
                    </MudChip>

                    <MudChip T="string"><MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.KeyboardDoubleArrowLeft"></MudIcon></MudChip>

                    foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                    {
                        if (source.ConnectedSystemAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Connected System Attribute">
                                        <MudAvatar Color="Color.Dark">CS</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.ConnectedSystemAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (source.Function != null)
                        {
                            <MudAlert Severity="Severity.Error">Functions are not yet supported in attribute flow rules.</MudAlert>
                        }

                        <!-- some thought needs to be given to how we handle specifying constant values -->
                    }
                }
                else if (_syncRule.Direction == SyncRuleDirection.Export)
                {
                    foreach (var source in attributeFlowRule.Sources.OrderBy(q => q.Order))
                    {
                        if (source.MetaverseAttribute != null)
                        {
                            <MudChip T="string">
                                <AvatarContent>
                                    <MudTooltip Text="Metaverse Attribute">
                                        <MudAvatar Color="Color.Dark">MV</MudAvatar>
                                    </MudTooltip>
                                </AvatarContent>
                                <ChildContent>@source.MetaverseAttribute.Name</ChildContent>
                            </MudChip>
                        }
                        else if (source.Function != null)
                        {
                            <MudAlert Severity="Severity.Error">Functions are not yet supported in attribute flow rules.</MudAlert>
                        }

                        <!-- some thought needs to be given to how we handle specifying constant values -->
                    }

                    <MudChip T="string"><MudIcon Size="Size.Small" Icon="@Icons.Material.Filled.KeyboardDoubleArrowRight"></MudIcon></MudChip>

                    <MudChip T="string">
                        <AvatarContent>
                            <MudTooltip Text="Connected System Attribute">
                                <MudAvatar Color="Color.Dark">CS</MudAvatar>
                            </MudTooltip>
                        </AvatarContent>
                        <ChildContent>@attributeFlowRule.TargetConnectedSystemAttribute?.Name</ChildContent>
                    </MudChip>
                }
            </MudPaper>
        }
    </MudStack>

    @if (_syncRule.Validate().Count > 0)
    {
        <MudAlert Severity="Severity.Normal" Class="mt-5">
            <MudText>There are issues:</MudText>
            <MudList T="string">
                @foreach (var item in _syncRule.Validate())
                {
                    <MudListItem T="string" IconColor="@(item.Level == ValidityStatusItemLevel.Warning ? Color.Warning : Color.Error)" Icon="@(item.Level == ValidityStatusItemLevel.Warning ? @Icons.Material.Filled.Warning : @Icons.Material.Filled.Error)">
                        @item.Message
                    </MudListItem>
                }    
            </MudList>
        </MudAlert>
    }

    <MudStack Row="true" Justify="Justify.SpaceBetween">
        <MudButton 
            Variant="Variant.Filled"
            Color="Color.Primary"
            Class="mt-5"
            OnClick="HandleCreateOrUpdateSyncRuleAsync"
            Disabled="!_syncRule.IsValid()"
            DropShadow="false">@(_syncRule.Id == 0 ? "Create" : "Update") Sync Rule</MudButton>
        <MudButton 
            Variant="Variant.Filled" 
            StartIcon="@Icons.Material.Filled.Delete" 
            OnClick="HandleDeleteSyncRuleAsync"
            Class="mt-5"
            DropShadow="false"
            Disabled="@(_syncRule.Id == 0)"
            Color="Color.Error">Delete Sync Rule</MudButton>
    </MudStack>
}

@code {
    [Parameter]
    public int? Id { get; set; }

    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }

    private string _syncRuleNameOrCreate = "New";
    private List<BreadcrumbItem> _breadcrumbs = null!;
    private SyncRule? _syncRule;
    private bool _isDetailsFormValid;
    private string[] _detailsFormErrors = { };
    private List<ConnectedSystemHeader>? _connectedSystemHeaders;
    private List<MetaverseObjectType>? _metaverseObjectTypes;

    private bool _addMatchingRuleDialogVisible;
    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private SyncRuleMapping? _matchingRuleMapping;
    private SyncRuleMappingSource? _matchingRuleMappingSource;
    private string? _matchingRuleMappingSourceType;

    private bool _syncRuleScopingFiltered;
    private bool _addScopingCriteriaGroupDialogVisible;
    private string? _criteriaGroupTypeText;
    private SyncRuleScopingCriteriaGroup? _syncRuleScopingCriteriaGroup;

    private bool _addAttributeFlowRuleDialogVisible;
    private SyncRuleMapping? _attributeFlowMapping;
    private SyncRuleMappingSource? _attributeFlowMappingSource;
    private string? _attributeFlowMappingSourceType;

    protected override async Task OnInitializedAsync()
    {
        _breadcrumbs =
        [
            new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
            new BreadcrumbItem("Synchronisation Rules", href: "/admin/connected-systems/sync-rules/")
        ];

        if (Id != null)
        {
            // edit an existing sync rule
            _syncRule = await Jim.ConnectedSystems.GetSyncRuleAsync(Id.Value);
            if (_syncRule == null)
            {
                // sync rule not found, redirect to index page
                NavManager.NavigateTo("../");
                return;
            }

            _syncRuleNameOrCreate = _syncRule.Name;
            _breadcrumbs.Add(new BreadcrumbItem(_syncRule.Name, href: null, disabled: true));
        }
        else
        {
            // create a new sync rule
            _syncRule = new SyncRule();
            _breadcrumbs.Add(new BreadcrumbItem("New", href: null, disabled: true));
            _connectedSystemHeaders = await Jim.ConnectedSystems.GetConnectedSystemHeadersAsync();
            _metaverseObjectTypes = await Jim.Metaverse.GetMetaverseObjectTypesAsync(true);
        }
    }

    private async Task HandleConnectedSystemSelectedAsync(string connectedSystemId)
    {
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;

        // convert to int and assign to SR
        var connectedSystemIdInt = int.Parse(connectedSystemId);
        var connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(connectedSystemIdInt);
        if (connectedSystem == null)
            return;

        _syncRule.ConnectedSystem = connectedSystem;
        Console.WriteLine($"HandleConnectedSystemSelectedAsync: Assigned ConnectedSystem: {_syncRule.ConnectedSystem}");
    }

    private void HandleSyncRuleDirectionSelection(string syncRuleDirection)
    {
        // convert to enum and assign to sr
        // should never happen, but performing for linting reasons
        if (_syncRule == null)
            return;
        
        var syncRuleDirectionEnum = (SyncRuleDirection)Enum.Parse(typeof(SyncRuleDirection), syncRuleDirection);
        _syncRule.Direction = syncRuleDirectionEnum;
        Console.WriteLine($"HandleSyncRuleDirectionSelection: Assigned SyncRuleDirection: {_syncRule.Direction}");

        // reset provision/project choices
        _syncRule.ProvisionToConnectedSystem = false;
        _syncRule.ProjectToMetaverse = false;
    }

    private void HandleOpenAddMatchingRuleMappingDialog()
    {
        if (_syncRule == null)
            return;

        if (_matchingRuleMapping == null)
        {
            _matchingRuleMapping = new SyncRuleMapping {
                    Type = SyncRuleMappingType.ObjectMatching,
                    Order = _syncRule.ObjectMatchingRules.Count == 0 ? 0 : _syncRule.ObjectMatchingRules.Select(q => q.Order).Max() + 1
            };
            _matchingRuleMappingSource = new SyncRuleMappingSource();
        }
        else
        {
            if (_matchingRuleMappingSource == null)
                return;
        }

        _matchingRuleMapping.Sources.Add(_matchingRuleMappingSource);
        _addMatchingRuleDialogVisible = true;
    }

    private void HandleAddMatchingRuleMappingTypeValueChange(string mappingType)
    {
        _matchingRuleMappingSource ??= new SyncRuleMappingSource();
        _matchingRuleMappingSourceType = mappingType;
    }

    private bool DisableAddMappingButton()
    {
        if (_matchingRuleMapping == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping NULL");
            return true;
        }

        if (_matchingRuleMappingSource == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMappingSource NULL");
            return true;
        }

        if (_matchingRuleMapping.TargetMetaverseAttribute == null)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.TargetMetaverseAttribute NULL");
            return true;
        }

        if (_matchingRuleMapping.Type != SyncRuleMappingType.ObjectMatching)
        {
            Console.WriteLine("DisableAddMappingButton: syncRuleMapping.Type != SyncRuleMappingType.ObjectMatching");
            return true;
        }

        // the rest depends on what type of source has been chosen by the user
        if (_matchingRuleMappingSource.ConnectedSystemAttribute == null && (_matchingRuleMappingSource.Function == null || (_matchingRuleMappingSource.Function != null && (_matchingRuleMappingSource.ParameterValues == null || _matchingRuleMappingSource.ParameterValues.Count == 0))))
        {
            Console.WriteLine("DisableAddMappingButton: attrib/function/params missing");
            return true;
        }

        return false;
    }

    private void HandleAddMappingButtonClick()
    {
        if (_syncRule == null || _matchingRuleMapping == null)
            return;

        // add the mapping to the rule
        _syncRule.ObjectMatchingRules.Add(_matchingRuleMapping);

        // close the add mapping dialog
        _addMatchingRuleDialogVisible = false;

        // re-initialise the mapping rule and source, ready for the next use
        _matchingRuleMapping = null;
        _matchingRuleMappingSource = null;
    }

    private async Task HandleObjectMatchingRuleDeleteClickAsync(SyncRuleMapping objectMatchingRule)
    {
        if (_syncRule == null)
            return;

        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to remove this Matching Rule?", yesText: "Remove!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            _syncRule.ObjectMatchingRules.Remove(objectMatchingRule);

            // re-order the items
            var orderedItems = _syncRule.ObjectMatchingRules.OrderBy(q => q.Order).ToList();
            for (var i = 0; i < orderedItems.Count; i++)
                orderedItems[i].Order = i;
        }
    }

    private void HandleObjectMatchingRuleChangeOrder(SyncRuleMapping objectMatchingRule, string direction)
    {
        // invalid scenarios
        if (_syncRule == null || _syncRule.ObjectMatchingRules.Count == 1)
            return;

        if (direction == "up")
        {
            // cannot promote the first item
            if (objectMatchingRule.Order == 0)
                return;

            var precedingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order - 1));
            precedingItem.Order++;
            objectMatchingRule.Order--;
        }
        else
        {
            // cannot demote the last item
            if (objectMatchingRule.Order == (_syncRule.ObjectMatchingRules.Count - 1))
                return;

            var followingItem = _syncRule.ObjectMatchingRules.Single(q => q.Order == (objectMatchingRule.Order + 1));
            followingItem.Order--;
            objectMatchingRule.Order++;
        }
    }

    private bool DisableObjectMatchingMappingRuleOrderButton(SyncRuleMapping objectMatchingRule, string direction)
    {
        if (_syncRule == null)
            return true;

        switch (direction)
        {
            case "up" when objectMatchingRule.Order == 0:
            case "down" when objectMatchingRule.Order == _syncRule.ObjectMatchingRules.Max(q => q.Order):
                return true;
            default:
                return false;
        }
    }

    private void HandleOpenAddScopingCriteriaGroupDialog()
    {
        Console.WriteLine("HandleOpenAddScopingCriteriaGroupDialog: Called");
        _syncRuleScopingCriteriaGroup = new SyncRuleScopingCriteriaGroup();
        _addScopingCriteriaGroupDialogVisible = true;
    }

    private bool DisableAddScopingCriteriaGroupFormButton()
    {
        Console.WriteLine($"DisableAddScopingCriteriaGroupFormButton: '{_criteriaGroupTypeText}'");
        return string.IsNullOrEmpty(_criteriaGroupTypeText);
    }

    private void HandleAddCriteriaGroupButtonClick()
    {
        if (_syncRule == null || _syncRuleScopingCriteriaGroup == null || _criteriaGroupTypeText == null)
            return;

        _syncRuleScopingCriteriaGroup.Type = (SearchGroupType)Enum.Parse(typeof(SearchGroupType), _criteriaGroupTypeText);

        if (_syncRuleScopingCriteriaGroup.ParentGroup == null)
        {
            // root-level criteria group
            _syncRule.ObjectScopingCriteriaGroups.Add(_syncRuleScopingCriteriaGroup);
        }
        else
        {
            // add the criteria group to the parent's children, i.e. mak sure the relationships is established on both the parent and the new criteria group
            _syncRuleScopingCriteriaGroup.ParentGroup.ChildGroups.Add(_syncRuleScopingCriteriaGroup);
        }

        // all done, reset
        _addScopingCriteriaGroupDialogVisible = false;
        _syncRuleScopingCriteriaGroup = null;
    }

    private void HandleStateHasChanged()
    {
        // yes, this is necessary.
        StateHasChanged();
    }

    private async Task HandleCreateOrUpdateSyncRuleAsync()
    {
        if (_syncRule == null)
            return;

        // are we transitioning from new to existing?
        var isSyncRuleNew = _syncRule.Id == 0;

        // attribute the operation to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        var wasSuccessful = await Jim.ConnectedSystems.CreateOrUpdateSyncRuleAsync(_syncRule, user);
        switch (wasSuccessful)
        {
            // send the user to the existing-sync-rule view.
            // this helps ensure links are good to be shared/bookmarked, etc.
            case true when isSyncRuleNew:
                NavManager.NavigateTo($"/admin/connected-systems/sync-rules/{_syncRule.Id}");
                break;
            case true:
                Snackbar.Add("Changes saved.", Severity.Success);
                break;
            case false:
                Snackbar.Add("There was a problem saving your changes. Please check the details and try again.", Severity.Error);
                break;
        }
    }

    private bool DisableAddAttributeFlowButton()
    {
        if (_syncRule?.MetaverseObjectType == null)
            return true;

        if (_syncRule?.ConnectedSystemObjectType == null)
            return true;

        return false;
    }

    private void HandleOpenAddAttributeFlowRuleDialog()
    {
        if (_syncRule == null)
            return;
        
        _attributeFlowMapping = new SyncRuleMapping {
            Type = SyncRuleMappingType.AttributeFlow
        };
        _attributeFlowMappingSource = new SyncRuleMappingSource();
        _attributeFlowMapping.Sources.Add(_attributeFlowMappingSource);
        _addAttributeFlowRuleDialogVisible = true;
    }

    private bool DisableAddAttributeFlowMappingButton()
    {
        if (_attributeFlowMapping == null)
            return true;

        if (_attributeFlowMappingSource == null)
            return true;

        if (_attributeFlowMappingSourceType == null)
            return true;
        
        return false;
    }
    
    // import rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(MetaverseAttribute targetMetaverseAttribute)
    {
        if (_attributeFlowMappingSource?.ConnectedSystemAttribute == null)
            return true;

        if (targetMetaverseAttribute.Type != _attributeFlowMappingSource.ConnectedSystemAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetMetaverseAttribute.AttributePlurality == AttributePlurality.SingleValued && _attributeFlowMappingSource.ConnectedSystemAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;
        
        return false;
    }
    
    // export rules: the user can choose an invalid target attribute, depending on the makeup of the source attribute
    private bool IsAttributeFlowTargetDisabled(ConnectedSystemObjectTypeAttribute targetConnectedSystemObjectTypeAttribute)
    {
        if (_attributeFlowMappingSource?.MetaverseAttribute == null)
            return true;

        if (targetConnectedSystemObjectTypeAttribute.Type != _attributeFlowMappingSource.MetaverseAttribute.Type)
            return true;

        // cannot flow an MVA to an SVA: we wouldn't know which value to assign
        if (targetConnectedSystemObjectTypeAttribute.AttributePlurality == AttributePlurality.SingleValued && _attributeFlowMappingSource.MetaverseAttribute.AttributePlurality == AttributePlurality.MultiValued)
            return true;
        
        return false;
    }
    
    private void HandleAddAttributeFlowMappingButtonClick()
    {
        if (_syncRule == null || _attributeFlowMapping == null)
            return;
        
        // add the mapping to the rule
        _syncRule.AttributeFlowRules.Add(_attributeFlowMapping);

        // close the add attribute flow dialog
        _addAttributeFlowRuleDialogVisible = false;

        // re-initialise the attribute flow rule and source, ready for the next use
        _attributeFlowMapping = null;
        _attributeFlowMappingSource = null;
    }

    private void HandleAttributeFlowRuleDeleteClick(SyncRuleMapping attributeFlowRule)
    {
        _syncRule?.AttributeFlowRules.Remove(attributeFlowRule);
    }

    private async Task HandleDeleteSyncRuleAsync()
    {
        if (_syncRule == null)
            return;
        
        var confirmationResult = await DialogService.ShowMessageBox("Warning", "Are you sure you want to delete this Synchronisation Rule?", yesText: "Delete!", cancelText: "Cancel");
        if (confirmationResult.HasValue && confirmationResult.Value)
        {
            // attribute the operation to the signed-in user
            var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
            await Jim.ConnectedSystems.DeleteSyncRuleAsync(_syncRule, user);
            NavManager.NavigateTo("/admin/connected-systems/sync-rules");
        }
    }
}
