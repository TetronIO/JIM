@page "/admin/connected-systems/{Id:int}"
@attribute [Authorize(Roles = "Administrators")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Staging;
@using JIM.Utilities;
@using Serilog
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<PageTitle>Connected System: @_connectedSystem?.Name</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Connected System:</span> @_connectedSystem?.Name</MudText>
<MudBreadcrumbs Items="_breadcrumbs" Class="ps-0"></MudBreadcrumbs>
<MudText Typo="Typo.subtitle1" Class="mud-text-secondary">Some aspects of a Connected System can only be configured once basic details and setting values have been provided.</MudText>

@if (_connectedSystem != null)
{
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="false" PanelClass="pt-5" Class="mt-5" Outlined="true">

        <MudTabPanel Text="Details">
            <MudPaper Class="pa-4" Outlined="true">
                <MudForm @bind-IsValid="@IsDetailsFormValid" @bind-Errors="@DetailsFormErrors">
                    <MudTextField T="string" Label="Connector" @bind-Value="_connectedSystem.ConnectorDefinition.Name" Disabled="true" Variant="Variant.Outlined" />
                    <MudTextField T="string" Label="Name" @bind-Value="_connectedSystem.Name" Required="true" RequiredError="A name is required" Variant="Variant.Outlined" Class="mt-5" />
                    <MudTextField T="string" Label="Description" Required="false" @bind-Value="_connectedSystem.Description" Lines="5" Variant="Variant.Outlined" Class="mt-5" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsDetailsFormValid)" Class="mt-5" OnClick="HandleValidDetailsSubmitAsync" DisableElevation="true">Save Changes</MudButton>
                </MudForm>
            </MudPaper>
        </MudTabPanel>

        <MudTabPanel Text="Settings">
            <MudText>Configure the connector for your environment by supplying values for the settings below.</MudText>
            <MudForm @bind-IsValid="@IsSettingsFormValid" @bind-Errors="@SettingsFormErrors" Class="mt-5">
                @if (_settingCategories != null)
                {
                    @for (var i = 0; i < _settingCategories.Count; i++)
                    {
                        var settingCategory = _settingCategories[i];
                        <MudText Typo="Typo.h5" Class="mt-5">@settingCategory.ToString()</MudText>
                        <MudPaper Class="pa-4 mt-5" Outlined="true">
                            @foreach (var settingValue in _connectedSystem.SettingValues.Where(sv => sv.Setting.Category == settingCategory))
                            {
                                if (settingValue.Setting.Type == ConnectedSystemSettingType.Heading)
                                {
                                    <MudText Typo="Typo.h6" Class="mb-5">@settingValue.Setting.Name</MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Divider)
                                {
                                    <hr />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.String)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.StringEncrypted)
                                {
                                    <MudTextField T="string"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.StringEncryptedValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Password"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Integer)
                                {
                                    <MudTextField T="int?"
                                                  Label="@settingValue.Setting.Name"
                                                  @bind-Value="settingValue.IntValue"
                                                  Required="@settingValue.Setting.Required"
                                                  RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                                  HelperText="@settingValue.Setting.Description"
                                                  InputType="InputType.Number"
                                                  Variant="Variant.Outlined"
                                                  Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.CheckBox)
                                {
                                    <MudSwitch @bind-Value="settingValue.CheckboxValue" Color="Color.Primary" Label="@settingValue.Setting.Name" Class="mb-5" />
                                }
                                else if (settingValue.Setting is { Type: ConnectedSystemSettingType.DropDown, DropDownValues: not null })
                                {
                                    <MudSelect @bind-Value="settingValue.StringValue"
                                               HelperText="@settingValue.Setting.Description"
                                               Label="@settingValue.Setting.Name"
                                               Variant="Variant.Outlined"
                                               Class="mb-5"
                                               Required="@settingValue.Setting.Required"
                                               RequiredError="@($"A {settingValue.Setting.Name} is required")">
                                        @foreach (var dropDownValue in settingValue.Setting.DropDownValues)
                                        {
                                            <MudSelectItem T="string" Value="@dropDownValue">@dropDownValue</MudSelectItem>
                                        }
                                    </MudSelect>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Label)
                                {
                                    <MudText Class="mb-5">
                                        @settingValue.Setting.Description
                                    </MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.File)
                                {
                                    <MudText Class="mt-b">Files not yet supported for settings.</MudText>
                                }
                                else
                                {
                                    <MudText Class="mt-b">Oops. Unknown setting type!</MudText>
                                }
                            }
                        </MudPaper>
                    }
                }

                @if (SettingsFormCustomErrors.Count > 0)
                {
                    <MudAlert Severity="Severity.Error" Class="mt-5">
                        <MudText>There are issues with the settings:</MudText>
                        <ul class="mt-5">
                            @foreach (var error in SettingsFormCustomErrors)
                            {
                                <li>@error.Key: @error.Value</li>
                            }
                        </ul>
                    </MudAlert>
                }

                <MudButton Variant="Variant.Filled" Color="@(IsSettingsFormValid || !_settingsBeingSaved ? Color.Primary : Color.Default)" Disabled="@(!IsSettingsFormValid || _settingsBeingSaved)" Class="mt-5" DisableElevation="true" OnClick="HandleValidSettingsSubmitAsync">
                    @if (_settingsBeingSaved)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Processing</MudText>
                    }
                    else
                    {
                        <MudText>Save Settings</MudText>
                    }
                </MudButton>
            </MudForm>
        </MudTabPanel>

        <MudTabPanel Text="Schema" Disabled="@AreSettingDependentTabsDisabled()">

            <MudAlert Severity="(_connectedSystem.ObjectTypes is { Count: > 0 } ? Severity.Warning : Severity.Info)">
                @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                {
                    <MudText>Retrieve the schema from the connected system, to be able to select which object types and attributes you want to manage with JIM.</MudText>
                }
                else
                {
                    <MudText>
                        <strong>Refreshing the schema can result in data-loss</strong>. If object types or attributes are discovered to have been removed at the connected system, then this will result in all references to them being removed from within JIM,
                        i.e. synchronisation rules, attribute flow, attributes values and even entire objects will be deleted if object types are removed. Refresh with caution. Ensure the Connected System identity has the right
                        permissions needed to retrieve the schema, and consider a database backup before proceeding.
                    </MudText>
                }
                <MudButton 
                    Color="(_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0 ? Color.Info : Color.Warning)"
                    Disabled="@(_schemaBeingRetrieved)"
                    Variant="Variant.Filled"
                    Size="Size.Small"
                    OnClick="HandleImportSchemaAsync"
                    Class="mt-5"
                    DisableElevation="true">
                    @if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count == 0)
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Retrieving Schema</MudText>
                        }
                        else
                        {
                            <text>Retrieve Schema</text>
                        }
                    }
                    else
                    {
                        if (_schemaBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Refreshing Schema</MudText>
                        }
                        else
                        {
                            <text>Refresh Schema</text>
                        }
                    }
                </MudButton>
            </MudAlert>

            <MudDialog @bind-IsVisible="_editSchemaAttributeDialogVisible" Options="_dialogOptions">
                <TitleContent>
                    <MudText Typo="Typo.h6">
                        <MudIcon Icon="@Icons.Material.Filled.Edit" Class="mr-3" /> Edit Schema Attribute
                    </MudText>
                </TitleContent>
                <DialogContent>
                    <MudText>Attribute: @_objectTypeAttributeBeingEdited?.Name</MudText>

                    @if (!_objectTypeAttributeBeingEditedIsEditable)
                    {
                        <MudAlert Severity="Severity.Error">
                            This Connected System attribute cannot be edited as it is being referenced by either a synchronisation rule, or has values already populated.
                        </MudAlert>
                    }
                    else
                    {
                        <MudAlert Severity="Severity.Info">
                            This Connector supports you changing the data type of a Connected System attribute. This might be because the data type
                            was detected automatically, and might need adjusting if not right.
                        </MudAlert>
                    }
                    
                    <MudSelect
                        T="string"
                        Label="Please choose a data type"
                        Required="true"
                        Variant="Variant.Outlined"
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable"
                        @bind-Value="_objectTypeAttributeBeingEditedText">
                        @foreach (AttributeDataType type in Enum.GetValues(typeof(AttributeDataType)))
                        {
                            if (type != AttributeDataType.NotSet)
                            {
                                <MudSelectItem Value="@type.ToString()"/>
                            }
                        }
                    </MudSelect>

                </DialogContent>
                <DialogActions>
                    <MudButton 
                        Disabled="!_objectTypeAttributeBeingEditedIsEditable" 
                        DisableElevation="true" 
                        Variant="Variant.Filled" 
                        Color="Color.Primary" 
                        OnClick="HandleEditAttributeDataTypeButtonClick" 
                        Class="ma-4">Confirm Change</MudButton>
                </DialogActions>
            </MudDialog>

            @if (_connectedSystem.ObjectTypes is { Count: > 0 })
            {
                if (_connectedSystem.ObjectTypes.Count > 1 || (_connectedSystem.ObjectTypes.Count == 1 && !_connectedSystem.ObjectTypes[0].Selected))
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText Class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            Select which object types you would like to manage with JIM.
                        </MudText>
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            @foreach (var objectType in _connectedSystem.ObjectTypes)
                            {
                                <MudCheckBox T="bool" Value="@objectType.Selected" Color="Color.Primary" Label="@objectType.Name" ValueChanged="((e) => HandleSelectedObjectTypeClick(objectType, e))" />
                            }
                        </div>
                    </MudPaper>
                }

                @if (_connectedSystem.ObjectTypes.Count(q => q.Selected) > 1)
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                            <MudButtonGroup Color="Color.Default" Class="mb-5" DisableElevation="true" Variant="Variant.Outlined">
                                @foreach (var objectType in _connectedSystem.ObjectTypes.Where(q => q.Selected))
                                {
                                    <MudButton 
                                        OnClick="@((e) => HandleActiveObjectTypeClick(objectType))"
                                        Disabled="DisableSelectedSchemaObjectType(objectType)"
                                        DisableElevation="true">@objectType.Name</MudButton>
                                }
                            </MudButtonGroup>
                        </div>
                    </MudPaper>
                }

                @if (_selectedObjectType != null)
                {
                    <MudText Typo="Typo.h6" Class="mt-5">@_selectedObjectType.Name</MudText>
                    @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedExternalId)
                    {
                        <MudPaper Outlined="true" Class="pa-4 mt-5">
                            <MudText>This connector requires you to select the attribute that is used as the External ID. Please select one below.</MudText>
                            <MudSelect 
                                T="ConnectedSystemObjectTypeAttribute" 
                                Label="External ID Attribute"
                                Variant="Variant.Outlined"
                                Class="mt-5"
                                Required="true"
                                RequiredError="You must select an attribute as the External ID."
                                Value="_selectedObjectType.Attributes.SingleOrDefault(q => q.IsExternalId)"
                                ValueChanged="HandleMakeExternalId">
                                @foreach (var objectTypeAttribute in _selectedObjectType.Attributes.Where(q => q.AttributePlurality == AttributePlurality.SingleValued))
                                {
                                    <MudSelectItem Value="@objectTypeAttribute">@(objectTypeAttribute.Name)</MudSelectItem>
                                }
                            </MudSelect>
                        </MudPaper>
                    }

                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        <MudText>
                            Select which attributes you would like to manage for this object type. To maximise performance, only select those you need.
                        </MudText>

                        <MudGrid Class="mt-3 mb-3">
                            <MudItem xs="@(_selectedObjectTypeHasClasses ? 6 : 12)">
                                <MudTextField 
                                    T="string"
                                    @bind-Value="_schemaSearchString"
                                    Label="Filter by name"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Search"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined"
                                    HelperText="Show only attributes where the name containers a specific value"
                                    autocomplete="schema_search_string" />
                            </MudItem>

                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudItem xs="6">
                                    <MudSelect 
                                        T="string"
                                        Label="Filter by class"
                                        MultiSelection="true"
                                        @bind-SelectedValues="AttributeClassFilterSelectedValues"
                                        Variant="Variant.Outlined"
                                        HelperText="Show only attributes with a particular class"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.FilterAlt"
                                        IconSize="Size.Small">
                                        @foreach (var className in _selectedObjectType.Attributes.Select(a => a.ClassName).Distinct().OrderBy(a => a))
                                        {
                                            <MudSelectItem T="string" Value="@className">@className</MudSelectItem>
                                        }
                                    </MudSelect>
                                </MudItem>
                            }

                            <MudItem xs="10">
                                <MudTextField 
                                    T="string"
                                    Label="Select attributes via CSV"
                                    @bind-Value="_attributeSelectionCsv"
                                    HelperText="You can also quick-select attributes by entering them in a comma-separated list, i.e. DisplayName,sAMAccountName"
                                    InputType="InputType.Text"
                                    Adornment="Adornment.Start"
                                    AdornmentIcon="@Icons.Material.Filled.Input"
                                    IconSize="Size.Small"
                                    Variant="Variant.Outlined" />
                            </MudItem>
                            <MudItem xs="2">
                                <MudButton 
                                    Variant="Variant.Filled"
                                    DisableElevation="true"
                                    Class="mt-4"
                                    Color="Color.Default"
                                    OnClick="HandleAttributeCsvSubmit">Select Attributes</MudButton>
                            </MudItem>

                            <MudItem xs="12" Class="pb-0">
                                <MudCheckBox @bind-Value="_attributeSelectedFilter" Color="Color.Primary">Show only selected?</MudCheckBox>
                            </MudItem>
                        </MudGrid>
                    </MudPaper>
                
                    <MudTable 
                        Items="@_selectedObjectType.Attributes"
                        Virtualize="true"
                        Hover="true"
                        Dense="true"
                        Breakpoint="Breakpoint.Sm"
                        SortLabel="Sort By"
                        Filter="new Func<ConnectedSystemObjectTypeAttribute,bool>(SchemaFilterFuncHandler)"
                        Class="mt-5"
                        Outlined="true"
                        Elevation="0">
                        <HeaderContent>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Selected)">Selected</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.IsExternalId)">External ID</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.ClassName!)">Class</MudTableSortLabel></MudTh>
                            }
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Type)">Type</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.AttributePlurality)">Plurality</MudTableSortLabel></MudTh>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Description!)">Description</MudTableSortLabel></MudTh>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTh></MudTh>
                            }
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Selected">
                                <MudSwitch @bind-Value="@context.Selected" Color="@Color.Primary"></MudSwitch>
                            </MudTd>
                            <MudTd DataLabel="External ID">
                                @(context.IsExternalId ? "Yes" : "-")
                            </MudTd>
                            <MudTd DataLabel="Name">@context.Name</MudTd>
                            @if (_selectedObjectTypeHasClasses)
                            {
                                <MudTd DataLabel="Class">
                                    @context.ClassName
                                </MudTd>
                            }
                            <MudTd DataLabel="Type">
                                @context.Type
                            </MudTd>
                            <MudTd DataLabel="Plurality" Class="jim-no-wrap">
                                @context.AttributePlurality.ToString().SplitOnCapitalLetters()
                            </MudTd>
                            @if (_selectedObjectTypeHasDescriptions)
                            {
                                <MudTd DataLabel="Description">
                                    @context.Description
                                </MudTd>
                            }
                            @if (_connectedSystem.ConnectorDefinition.SupportsUserSelectedAttributeTypes)
                            {
                                <MudTd>
                                    <MudButton 
                                        DisableElevation="true" 
                                        Size="Size.Small" 
                                        Variant="Variant.Filled"
                                        OnClick="(() => HandleShowEditAttributeDialogAsync(context))"
                                        StartIcon="@Icons.Material.Filled.Edit">
                                        Edit
                                    </MudButton>
                                </MudTd>
                            }
                        </RowTemplate>
                        <NoRecordsContent>
                            @if (_attributeSelectedFilter) {
                                <MudText>There are no selected attributes for this object type.</MudText>
                            } else {
                                <MudText>There are no attributes to show.</MudText>
                            }
                        </NoRecordsContent>
                    </MudTable>
                }

                <MudButton 
                    Color="Color.Primary" 
                    Variant="Variant.Filled" 
                    OnClick="HandleObjectTypesAndAttributeSelectionSubmitAsync" 
                    Class="mt-5" 
                    DisableElevation="true"
                    Disabled="DisableSaveSchemaButton()">Save Changes</MudButton>
            }

        </MudTabPanel>

        @if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            <MudTabPanel Text="Partitions & Containers" Disabled="@AreSettingDependentTabsDisabled()">

                <MudAlert Severity="(_connectedSystem.Partitions is { Count: > 0 } ? Severity.Warning : Severity.Info)">
                    @if (_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0)
                    {
                        <MudText>Retrieve the hierarchy @_partitionAndHierarchyText hierarchy from the connected system, to be able to select which ones you want to manage with JIM.</MudText>
                    }
                    else
                    {
                        <MudText>
                            <strong>Refreshing the @_partitionAndHierarchyText hierarchy can result in data-loss</strong>. If partitions and/or containers are removed, then this will result in all objects in them being deleted
                            from the Connected System, which depending on your configuration, could result in those objects being deprovisioned from the Metaverse and any downstream Connected Systems. Refresh with caution.
                            Ensure the Connected System identity has the right permissions needed to retrieve the hierarchy, and consider a database backup before proceeding.
                        </MudText>
                    }
                    <MudButton 
                            Disabled="@_hierarchyBeingRetrieved"
                            Color="(_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0 ? Color.Primary : Color.Warning)"
                            Size="Size.Small"
                            OnClick="HandleImportHierarchyAsync"
                            Variant="Variant.Filled"
                            Class="mt-5"
                            DisableElevation="true">
                        @if (_connectedSystem.Partitions?.Count == 0)
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Retrieving Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Retrieve Hierarchy</text>
                            }
                        }
                        else
                        {
                            if (_hierarchyBeingRetrieved)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                <MudText Class="ms-2">Refreshing Hierarchy</MudText>
                            }
                            else
                            {
                                <text>Refresh Hierarchy</text>
                            }
                        }
                    </MudButton>
                </MudAlert>

                @if (_connectedSystem.Partitions is { Count: > 0 })
                {
                    <MudText Class="mt-5">Select which @_partitionsAndHierarchiesText are to be managed by JIM here. To maximise performance, only select those that need managing.</MudText>
                    @foreach (var partition in _connectedSystem.Partitions)
                    {
                        <MudPaper Class="mt-5" Outlined="true">
                            <div class="pa-4">
                                <MudText Typo="Typo.h5" Class="mb-5">@partition.Name</MudText>
                                <MudSwitch @bind-Value="@partition.Selected" Color="Color.Primary" Label="Manage this partition?" />
                            </div>
                            <MudDivider />

                            <div class="pa-4">
                                <MudText>Select the containers you want to manage in this partition.</MudText>
                                <MudButtonGroup Color="Color.Default" Size="Size.Small" Variant="Variant.Outlined" Class="mt-5 mb-5">
                                    <MudButton>Select All</MudButton>
                                    <MudButton>Clear All</MudButton>
                                </MudButtonGroup>

                                <MudTreeView Items="@partition.Containers">
                                    <ItemTemplate>
                                        <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.ChildContainers">
                                            <Content>
                                                <MudTreeViewItemToggleButton @bind-Expanded="@context.Expanded" Visible="@(context.ChildContainers.Count > 0)" />
                                                @if (context.Included)
                                                {
                                                    <MudCheckBox T="bool?"
                                                                 Value="@(context.AreAnyChildContainersSelected() ? null : context.Selected)"
                                                                 ValueChanged="@((e) => ConnectedSystemContainerSelectedChanged(context))"
                                                                 UncheckedIcon="@Icons.Material.Outlined.FilterCenterFocus"
                                                                 Disabled="true"
                                                                 title="Included" />
                                                }
                                                else
                                                {
                                                    <MudCheckBox T="bool?"
                                                                 Value="@(context.AreAnyChildContainersSelected() ? null : context.Selected)"
                                                                 ValueChanged="@((e) => ConnectedSystemContainerSelectedChanged(context))"
                                                                 title="@(context.Selected ? "Selected" : "")" />
                                                }
                                                <MudText>@context.Name</MudText>
                                            </Content>
                                        </MudTreeViewItem>
                                    </ItemTemplate>
                                </MudTreeView>
                                
                            </div>
                        </MudPaper>
                    }

                    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleHierarchySelectionSubmitAsync" Class="mt-5" DisableElevation="true">Save Changes</MudButton>
                }
            </MudTabPanel>
        }

        <MudTabPanel Text="Run Profiles" Disabled="@IsRunProfilesTabDisabled()">
            <MudAlert Severity="Severity.Info">Run profiles define what operations can be performed on a Connector, i.e. import, export and synchronisation, with any required settings.</MudAlert>

            <MudPaper Outlined="true" Class="pa-4 mt-5">
                <MudText Typo="Typo.h6">Create a New Run Profile</MudText>

                <MudForm @bind-IsValid="@IsNewRunProfileFormValid">
                    <MudTextField T="string" @bind-Value="_newRunProfile.Name" Label="Name" Variant="Variant.Outlined" Class="mt-3" Required="true" RequiredError="A name for the run profile is required" />

                    <!-- would like to make this conditional, but the connector definition needs to state if it's file-based or not. this can be determined for custom connectors, but not built-in as there are no files for those. -->
                    <MudTextField T="string" @bind-Value="_newRunProfile.FilePath" Label="File Path" Variant="Variant.Outlined" Class="mt-3" HelperText="File-based connectors need the in-container path specifying, i.e. /var/connector-files/Users.csv" />

                    <MudSelect T="ConnectedSystemRunType" @bind-Value="_newRunProfile.RunType" Label="Run Type" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomCenter" Class="mt-5" Required="true" RequiredError="A run profile type is required">
                        @foreach (ConnectedSystemRunType runType in Enum.GetValues(typeof(ConnectedSystemRunType)))
                        {
                            <MudSelectItem Value="@runType">@runType.ToString().SplitOnCapitalLetters()</MudSelectItem>
                        }
                    </MudSelect>
                    @if (_connectedSystem.ConnectorDefinition.SupportsPartitions && _connectedSystem.Partitions != null)
                    {
                        <MudSelect T="ConnectedSystemPartition" @bind-Value="_newRunProfile.Partition" Label="Partition" Variant="Variant.Outlined" Class="mt-5" AnchorOrigin="Origin.BottomCenter" Required="@_connectedSystem.ConnectorDefinition.SupportsPartitions" RequiredError="A run profile partition is required">
                            @foreach (var partition in _connectedSystem.Partitions.Where(p => p.Selected))
                            {
                                <MudSelectItem Value="@partition" />
                            }
                        </MudSelect>
                    }
                    <MudNumericField @bind-Value="_newRunProfile.PageSize" Label="Page Size" Variant="Variant.Outlined" Class="mt-3" Min="0" Step="100" Required="true" RequiredError="How many items to process in one go when importing/exporting" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsNewRunProfileFormValid)" OnClick="HandleNewRunProfileFormSubmitAsync" Class="mt-5" DisableElevation="true">Create Run Profile</MudButton>
                </MudForm>
            </MudPaper>

            <MudTable Items="@_connectedSystem.RunProfiles" Hover="true" Breakpoint="Breakpoint.Sm" Class="mt-5" SortLabel="Sort By" Outlined="true" Elevation="0">
                <HeaderContent>
                    <MudTh>Actions</MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.RunType)">Run Type</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Partition.Name)">Partition</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.PageSize)">Page Size</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.FilePath)">File Path</MudTableSortLabel></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true">
                            <MudMenuItem Icon="@Icons.Material.Filled.Delete" IconSize="Size.Small" OnClick="((e) => HandleRunProfileDeleteAsync(context))">Delete</MudMenuItem>
                        </MudMenu>
                    </MudTd>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudTd DataLabel="Run Type">@context.RunType.ToString().SplitOnCapitalLetters()</MudTd>
                    <MudTd DataLabel="Partition">@(context.Partition != null ? context.Partition.Name : "-")</MudTd>
                    <MudTd DataLabel="Page Size">@context.PageSize</MudTd>
                    <MudTd DataLabel="File Path">@(context.FilePath ?? "-")</MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    There are no run profiles. Create your first.
                </NoRecordsContent>
            </MudTable>

        </MudTabPanel>

    </MudTabs>
}

@code {
    [Parameter]
    public int Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }
    private bool IsDetailsFormValid { get; set; }
    private string[] DetailsFormErrors { get; set; } = { };
    private bool IsSettingsFormValid { get; set; }
    private string[] SettingsFormErrors { get; set; } = { };
    private Dictionary<string, string> SettingsFormCustomErrors { get; } = new();
    private bool IsNewRunProfileFormValid { get; set; }
    private ConnectedSystem? _connectedSystem;
    private bool _settingsBeingSaved;
    private List<ConnectedSystemSettingCategory>? _settingCategories;
    private string? _partitionsAndHierarchiesText;
    private string? _partitionAndHierarchyText;
    private bool _schemaBeingRetrieved;
    private ConnectedSystemObjectType? _selectedObjectType;
    private bool _selectedObjectTypeHasClasses;
    private bool _selectedObjectTypeHasDescriptions;
    private bool _hierarchyBeingRetrieved;
    private string _schemaSearchString = "";
    private ConnectedSystemRunProfile _newRunProfile = new() { PageSize = 500 };
    private IEnumerable<string> AttributeClassFilterSelectedValues { get; set; } = new HashSet<string>();
    private bool _attributeSelectedFilter;
    private string? _attributeSelectionCsv;
    private List<BreadcrumbItem> _breadcrumbs = null!;
    
    private readonly DialogOptions _dialogOptions = new() { FullWidth = true };
    private bool _editSchemaAttributeDialogVisible;
    private ConnectedSystemObjectTypeAttribute? _objectTypeAttributeBeingEdited;
    private string? _objectTypeAttributeBeingEditedText;
    private bool _objectTypeAttributeBeingEditedIsEditable;

    protected override async Task OnInitializedAsync()
    {
        _connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(Id);
        if (_connectedSystem == null)
        {
            // connected system not found, redirect to index page
            NavManager.NavigateTo("../");
            return;
        }

        _breadcrumbs = new List<BreadcrumbItem>
        {
            new("Home", href: "/", icon: Icons.Material.Filled.Home),
            new("Connected Systems", href: "/admin/connected-systems/"),
            new(_connectedSystem.Name, href: null, disabled: true)
        };

        // get a list of the distinct setting categories in use, so we can render them in category blocks
        _settingCategories = _connectedSystem.SettingValues.Select(q => q.Setting.Category).Distinct().ToList();

        // to save us having to perform this comparison all over the view
        if (_connectedSystem.ConnectorDefinition is { SupportsPartitions: true, SupportsPartitionContainers: true })
        {
            _partitionsAndHierarchiesText = "partitions and containers";
            _partitionAndHierarchyText = "partition and container";
        }
        else if (_connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            _partitionsAndHierarchiesText = "partitions";
            _partitionAndHierarchyText = "partition";
        }

        // show the first selected object type attribute table
        if (_connectedSystem.ObjectTypes != null)
            _selectedObjectType = _connectedSystem.ObjectTypes.FirstOrDefault(q => q.Selected);

        ApplyContainerIncludedToPartitions(_connectedSystem);
    }

    private bool AreSettingDependentTabsDisabled()
    {
        if (_connectedSystem == null)
            return true;
        
        return !_connectedSystem.SettingValuesValid;
    }

    private async Task HandleValidDetailsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidDetailsSubmitAsync)}: connectedSystem was null");
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your details changes have been saved.", Severity.Success);
    }

    private async Task HandleValidSettingsSubmitAsync()
    {
        if (_connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidSettingsSubmitAsync)}: connectedSystem was null");
            return;
        }

        _settingsBeingSaved = true;
        SettingsFormCustomErrors.Clear();

        StateHasChanged();
        await Task.Delay(1);

        // validate the form
        var results = Jim.ConnectedSystems.ValidateConnectedSystemSettings(_connectedSystem);
        for (var i = 0; i < results.Count; i++)
        {
            var result = results[i];
            if (result.IsValid)
                continue;

            switch (result.SettingValue)
            {
                case { Setting.Name: not null } when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add(result.SettingValue.Setting.Name, result.ErrorMessage);
                    break;
                case null when !string.IsNullOrEmpty(result.ErrorMessage):
                    SettingsFormCustomErrors.Add($"General issue {i + 1}", result.ErrorMessage);
                    break;
            }
        }

        if (SettingsFormCustomErrors.Any())
        {
            _settingsBeingSaved = false;
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your setting changes have been saved.", Severity.Success);
        _settingsBeingSaved = false;

        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task HandleImportSchemaAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _schemaBeingRetrieved = true;
        StateHasChanged();
        await Task.Delay(1);

        await Jim.ConnectedSystems.ImportConnectedSystemSchemaAsync(_connectedSystem, user);

        // if there's just a single object type in the schema, auto-select it
        if (_connectedSystem.ObjectTypes is { Count: 1 })
            HandleSelectedObjectTypeClick(_connectedSystem.ObjectTypes[0], true);

        _schemaBeingRetrieved = false;
        StateHasChanged();
        await Task.Delay(1);
    }

    private void HandleSelectedObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType, bool isObjectTypeChecked)
    {
        if (_connectedSystem == null)
            return;

        // actuate the state change
        connectedSystemObjectType.Selected = isObjectTypeChecked;

        // now cascade
        // if only one type is selected, make that the selected object type
        // if none are selected, clear selected object type
        // if the selected type is being de-selected, null the selected type
        if (_connectedSystem.ObjectTypes != null && _connectedSystem.ObjectTypes.Count(q => q.Selected) == 1)
            _selectedObjectType = _connectedSystem.ObjectTypes.Single(q => q.Selected);
        else if (_connectedSystem.ObjectTypes == null || _connectedSystem.ObjectTypes.Count(q => q.Selected) == 0)
            _selectedObjectType = null;
        else if (_selectedObjectType != null && _selectedObjectType.Id == connectedSystemObjectType.Id && !isObjectTypeChecked)
            _selectedObjectType = null;

        // some parts of the UI only make sense if the attributes have classes
        _selectedObjectTypeHasClasses = connectedSystemObjectType.Attributes.Any(q => q.ClassName != null);
        _selectedObjectTypeHasDescriptions = connectedSystemObjectType.Attributes.Any(q => q.Description != null);
    }

    private void HandleActiveObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType)
    {
        _selectedObjectType = connectedSystemObjectType;
    }

    private void HandleMakeExternalId(ConnectedSystemObjectTypeAttribute selectedAttribute)
    {
        if (_selectedObjectType == null)
        {
            Log.Error($"CS Detail > HandleMakeExternalId: {nameof(_selectedObjectType)} is null!");
            return;
        }

        // make sure there's not already an attribute marked as the external id
        foreach (var attribute in _selectedObjectType.Attributes.Where(a => a.IsExternalId))
            attribute.IsExternalId = false;

        // mark the intended attribute as the external id, and select it
        selectedAttribute.IsExternalId = true;
        selectedAttribute.Selected = true;
        Log.Verbose($"CS Detail > HandleMakeExternalId: Set attribute id {selectedAttribute} as the external id.");
    }

    private async Task HandleObjectTypesAndAttributeSelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your attribute changes have been saved.", Severity.Success);
    }

    private async Task HandleImportHierarchyAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);

        _hierarchyBeingRetrieved = true;
        StateHasChanged();
        await Task.Delay(1);

        await Jim.ConnectedSystems.ImportConnectedSystemHierarchyAsync(_connectedSystem, user);
        _hierarchyBeingRetrieved = false;
        StateHasChanged();
        await Task.Delay(1);
    }

    private async Task HandleHierarchySelectionSubmitAsync()
    {
        if (_connectedSystem == null)
            return;

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(_connectedSystem, user);
        Snackbar.Add("Your hierarchy changes have been saved.", Severity.Success);
    }

    private bool SchemaFilterFuncHandler(ConnectedSystemObjectTypeAttribute element) => SchemaFilterFunc(element, _schemaSearchString, AttributeClassFilterSelectedValues, _attributeSelectedFilter);

    private static bool SchemaFilterFunc(ConnectedSystemObjectTypeAttribute element, string searchString, IEnumerable<string> attributeClassFilterSelectedValues, bool attributeSelectedFilter)
    {
        // what type of search is this? name, class or csv?
        var classHashset = (HashSet<string>)attributeClassFilterSelectedValues;

        if (!string.IsNullOrEmpty(searchString))
            return element.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase);

        if (classHashset.Count > 0)
            return classHashset.Any(q => q == element.ClassName);
        
        return !attributeSelectedFilter || element.Selected;
    }

    private static void ConnectedSystemContainerSelectedChanged(ConnectedSystemContainer container)
    {
        // if included and clicked, change to not included, not selected
        if (container.Included)
        {
            container.Selected = false;
            container.Included = false;
        }
        else
        {
            // toggle the current setting
            container.Selected = !container.Selected;
            container.Included = false;
        }

        // set the right selected/included values for all children
        if (container.Selected)
        {
            // all children should be included and not selected
            foreach (var child in container.ChildContainers)
            {
                child.Included = true;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, true);
            }
        }
        else
        {
            // all children should be not selected and not included
            foreach (var child in container.ChildContainers)
            {
                child.Included = false;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, false);
            }
        }

        // set the parent(s) if necessary
        if (container.ParentContainer != null)
        {
            // go up a level. if all children are selected, then make parent selected and all children (resursively) included.
            CorrectUpwardContainerStatus(container.ParentContainer);
        }
    }

    private static void ApplyContainerStatusDownBranch(ConnectedSystemContainer container, bool selected, bool included)
    {
        foreach (var child in container.ChildContainers)
        {
            child.Included = included;
            child.Selected = selected;
            ApplyContainerStatusDownBranch(child, selected, included);
        }
    }

    private static void ApplyContainerIncludedToPartitions(ConnectedSystem connectedSystemInQuestion)
    {
        if (connectedSystemInQuestion.Partitions == null)
            return;

        foreach (var partition in connectedSystemInQuestion.Partitions)
            if (partition.Containers != null)
                foreach (var container in partition.Containers)
                    ApplyContainerIncludedRecursively(container, container.Selected);
    }

    private static void ApplyContainerIncludedRecursively(ConnectedSystemContainer connectedSystemContainer, bool aParentWasSelected)
    {
        foreach (var childContainer in connectedSystemContainer.ChildContainers)
        {
            var shouldChildBeIncluded = aParentWasSelected;

            // parent was selected, so this child container should be marked as included
            if (aParentWasSelected)
                childContainer.Included = true;

            // if this child container is selected, then it's children should be marked as included
            if (childContainer.Selected)
                shouldChildBeIncluded = true;

            ApplyContainerIncludedRecursively(childContainer, shouldChildBeIncluded);
        }
    }

    private static void CorrectUpwardContainerStatus(ConnectedSystemContainer parentContainer)
    {
        if (parentContainer.ChildContainers.All(q => q.Selected))
        {
            parentContainer.Selected = true;
            parentContainer.Included = false;

            foreach (var childContainer in parentContainer.ChildContainers)
            {
                childContainer.Selected = false;
                childContainer.Included = true;
                ApplyContainerStatusDownBranch(childContainer, false, true);
            }
        }

        if (parentContainer.ParentContainer != null)
            CorrectUpwardContainerStatus(parentContainer.ParentContainer);
    }

    private bool IsRunProfilesTabDisabled()
    {
        if (_connectedSystem == null)
            return true;

        return _connectedSystem.ConnectorDefinition.SupportsPartitions && (_connectedSystem.Partitions == null || _connectedSystem.Partitions.Count == 0);
    }

    private async Task HandleNewRunProfileFormSubmitAsync()
    {
        if (_connectedSystem?.RunProfiles == null)
            return;

        // copy the form bound object to a new one we can persist separately from the form bind
        var runProfile = new ConnectedSystemRunProfile {
            ConnectedSystemId = _connectedSystem.Id,
            Name = _newRunProfile.Name,
            RunType = _newRunProfile.RunType,
            Partition = _newRunProfile.Partition,
            PageSize = _newRunProfile.PageSize,
            FilePath = _newRunProfile.FilePath
        };

        // attribute the action to the user and create the run profile
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.CreateConnectedSystemRunProfileAsync(runProfile, user);

        Snackbar.Add("New run profile added.", Severity.Success);

        // reset the object we've bound to the form so a new run profile can be created if the user chooses
        _newRunProfile = new ConnectedSystemRunProfile();
    }

    private async Task HandleRunProfileDeleteAsync(ConnectedSystemRunProfile connectedSystemRunProfile)
    {
        if (_connectedSystem == null || _connectedSystem.RunProfiles == null)
            return;

        _connectedSystem.RunProfiles.Remove(connectedSystemRunProfile);

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, AuthenticationStateTask);
        await Jim.ConnectedSystems.DeleteConnectedSystemRunProfileAsync(connectedSystemRunProfile, user);

        Snackbar.Add("Run profile removed.", Severity.Success);
    }

    private void HandleAttributeCsvSubmit()
    {
        if (_selectedObjectType == null)
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: connectedSystem was null");
            return;
        }

        if (string.IsNullOrEmpty(_attributeSelectionCsv))
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: attributeSelectionCsv is null or empty");
            return;
        }

        // clear the other search boxes
        _schemaSearchString = string.Empty;
        ((HashSet<string>)AttributeClassFilterSelectedValues).Clear();

        // convert the csv to a list and trim the entries
        // go through each attribute on the object type and select it
        foreach (var attributeName in _attributeSelectionCsv.Split(','))
        {
            var attribute = _selectedObjectType.Attributes.SingleOrDefault(a => a.Name.Equals(attributeName.Trim(), StringComparison.OrdinalIgnoreCase));
            if (attribute == null)
                continue;

            attribute.Selected = true;
        }

        // filter by selected
        _attributeSelectedFilter = true;

        // clear the attribute csv text box
        _attributeSelectionCsv = null;

        // all done, let the user know
        Snackbar.Add("Attributes selected.", Severity.Success);
    }

    private bool DisableSelectedSchemaObjectType(ConnectedSystemObjectType connectedSystemObjectType)
    {
        if (_selectedObjectType == null)
            return false;

        if (connectedSystemObjectType.Id.Equals(_selectedObjectType.Id))
            return true; // BOTH IDS ARE 0 WHEN THEY'RE DIFFERENT TYPES! HOW?! - BECAUSE THEY HAVEN'T BEEN PERSISTED YET!

        return false;
    }

    /// <summary>
    /// Determines whether the Save Schema changes button should be disabled or not.
    /// </summary>
    private bool DisableSaveSchemaButton()
    {
        // must select at least one object type
        // all selected object types must have an external id selected

        if (_connectedSystem?.ObjectTypes == null)
            return true;

        var objectTypesSelected = _connectedSystem.ObjectTypes.Any(ot => ot.Selected);
        var externalIdsSet = _connectedSystem.ObjectTypes.Where(ot => ot.Selected).All(ot => ot.Attributes.Any(a => a.IsExternalId));

        return !objectTypesSelected || !externalIdsSet;
    }

    private async Task HandleShowEditAttributeDialogAsync(ConnectedSystemObjectTypeAttribute connectedSystemObjectTypeAttribute)
    {
        // can the connected system attribute be edited? are there any references to it?
        _objectTypeAttributeBeingEditedIsEditable = !await Jim.ConnectedSystems.IsObjectTypeAttributeBeingReferencedAsync(connectedSystemObjectTypeAttribute);
        _objectTypeAttributeBeingEdited = connectedSystemObjectTypeAttribute;
        _editSchemaAttributeDialogVisible = true;
    }
    
    private void HandleEditAttributeDataTypeButtonClick()
    {
        _editSchemaAttributeDialogVisible = false;
    }
}