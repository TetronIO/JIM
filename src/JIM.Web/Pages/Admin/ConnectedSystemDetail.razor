@page "/admin/connected-systems/{Id:int}"
@attribute [Authorize(Roles = "Administrators")]
@using JIM.Application
@using JIM.Models.Core
@using JIM.Models.Core.DTOs
@using JIM.Models.Staging.DTOs
@using JIM.Models.Staging;
@using JIM.Models.Transactional;
@using JIM.Web.Models;
@using JIM.Utilities;
@inject JimApplication Jim
@inject NavigationManager NavManager
@inject ISnackbar Snackbar

<PageTitle>Connected System: @connectedSystem?.Name</PageTitle>
<MudText Typo="Typo.h4"><span class="mud-secondary-text">Connected System:</span> @connectedSystem?.Name</MudText>
<MudBreadcrumbs Items="breadcrumbs" Class="ps-0"></MudBreadcrumbs>
<MudText Typo="Typo.subtitle1" Class="mud-text-secondary">Some aspects of a Connected System can only be configured once basic details and setting values have been provided.</MudText>

@if (connectedSystem != null)
{
    <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="false" PanelClass="pt-5" Class="mt-5" Outlined="true">

        <MudTabPanel Text="Details">
            <MudPaper Class="pa-4" Outlined="true">
                <MudForm @bind-IsValid="@IsDetailsFormValid" @bind-Errors="@DetailsFormErrors">
                    <MudTextField T="string" Label="Connector" @bind-Value="connectedSystem.ConnectorDefinition.Name" Disabled="true" Variant="Variant.Outlined" />
                    <MudTextField T="string" Label="Name" @bind-Value="connectedSystem.Name" Required="true" RequiredError="A name is required" Variant="Variant.Outlined" Class="mt-5" />
                    <MudTextField T="string" Label="Description" Required="false" @bind-Value="connectedSystem.Description" Lines="5" Variant="Variant.Outlined" Class="mt-5" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsDetailsFormValid)" Class="mt-5" OnClick="HandleValidDetailsSubmitAsync" DisableElevation="true">Save Changes</MudButton>
                </MudForm>
            </MudPaper>
        </MudTabPanel>

        <MudTabPanel Text="Settings">
            <MudText>Configure the connector for your environment by supplying values for the settings below.</MudText>
            <MudForm @bind-IsValid="@IsSettingsFormValid" @bind-Errors="@SettingsFormErrors" Class="mt-5">
                @if (settingCategories != null)
                {
                    @for (var i = 0; i < settingCategories.Count; i++)
                    {
                        var formElementName = "something-" + i;
                        var settingCategory = @settingCategories[i];
                        <MudText Typo="Typo.h5" Class="mt-5">@settingCategory.ToString()</MudText>
                        <MudPaper Class="pa-4 mt-5" Outlined="true">
                            @foreach (var settingValue in connectedSystem.SettingValues.Where(sv => sv.Setting.Category == settingCategory))
                            {
                                if (settingValue.Setting.Type == ConnectedSystemSettingType.Heading)
                                {
                                    <MudText Typo="Typo.h6" Class="mb-5">@settingValue.Setting.Name</MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Divider)
                                {
                                    <hr />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.String)
                                {
                                    <MudTextField T="string"
                                        Label="@settingValue.Setting.Name"
                                        @bind-Value="settingValue.StringValue"
                                        Required="@settingValue.Setting.Required"
                                        RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                        HelperText="@settingValue.Setting.Description"
                                        Variant="Variant.Outlined"
                                        Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.StringEncrypted)
                                {
                                    <MudTextField T="string"
                                        Label="@settingValue.Setting.Name"
                                        @bind-Value="settingValue.StringEncryptedValue"
                                        Required="@settingValue.Setting.Required"
                                        RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                        HelperText="@settingValue.Setting.Description"
                                        InputType="InputType.Password"
                                        Variant="Variant.Outlined"
                                        Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Integer)
                                {
                                    <MudTextField T="int?"
                                        Label="@settingValue.Setting.Name"
                                        @bind-Value="settingValue.IntValue"
                                        Required="@settingValue.Setting.Required"
                                        RequiredError="@($"A {settingValue.Setting.Name} is required")"
                                        HelperText="@settingValue.Setting.Description"
                                        InputType="InputType.Number"
                                        Variant="Variant.Outlined"
                                        Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.CheckBox)
                                {
                                    <MudSwitch @bind-Checked="settingValue.CheckboxValue" Color="Color.Primary" Label="@settingValue.Setting.Name" Class="mb-5" />
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.DropDown && settingValue.Setting.DropDownValues != null)
                                {
                                    <MudSelect @bind-Value="settingValue.StringValue" HelperText="@settingValue.Setting.Description" Label="@settingValue.Setting.Name" Variant="Variant.Outlined" Class="mb-5">
                                        @foreach (var dropDownValue in settingValue.Setting.DropDownValues)
                                        {
                                            <option value="@dropDownValue">@dropDownValue</option>
                                        }
                                    </MudSelect>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.Label)
                                {
                                    <MudText Class="mb-5">
                                        @settingValue.Setting.Description
                                    </MudText>
                                }
                                else if (settingValue.Setting.Type == ConnectedSystemSettingType.File)
                                {
                                    <MudText Class="mt-b">Files not yet supported for settings.</MudText>
                                }
                                else
                                {
                                    <MudText Class="mt-b">Oops. Unknown setting type!</MudText>
                                }
                            }
                        </MudPaper>
                    }
                }

                @if (SettingsFormCustomErrors.Any())
                {
                    <MudAlert Severity="Severity.Error" Class="mt-5">
                        <MudText>There are issues with the settings:</MudText>
                        <ul class="mt-5">
                            @foreach (var error in SettingsFormCustomErrors)
                            {
                                <li>@error.Key: @error.Value</li>
                            }
                        </ul>
                    </MudAlert>
                }

                <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsSettingsFormValid || settingsBeingSaved)" Class="mt-5" OnClick="HandleValidSettingsSubmitAsync" DisableElevation="true">
                    @if (settingsBeingSaved)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Processing</MudText>
                    }
                    else
                    {
                        <MudText>Save Settings</MudText>
                    }
                </MudButton>
            </MudForm>
        </MudTabPanel>

        <MudTabPanel Text="Schema" Disabled="@AreSettingDependentTabsDisabled()">

            <MudAlert Severity="(connectedSystem.ObjectTypes != null && connectedSystem.ObjectTypes.Count > 0 ? Severity.Warning : Severity.Info)">
                @if (connectedSystem.ObjectTypes == null || connectedSystem.ObjectTypes.Count == 0)
                {
                    <MudText>Retrieve the schema from the connected system, to be able to select which object types and attributes you want to manage with JIM.</MudText>
                }
                else
                {
                    <MudText>
                        <strong>Refreshing the schema can result in data-loss</strong>. If object types or attributes are discovered to have been removed at the connected system, then this will result in all references to them being removed from within JIM,
                        i.e. synchronisation rules, attribute flow, attributes values and even entire objects will be deleted if object types are removed. Refresh with caution. Ensure the Connected System identity has the right
                        permissions needed to retrieve the schema, and consider a database backup before proceeeding.
                    </MudText>
                }
                <MudButton Color="(connectedSystem.ObjectTypes == null || connectedSystem.ObjectTypes.Count == 0 ? Color.Info : Color.Warning)" Variant="Variant.Filled" Size="Size.Small" OnClick="HandleImportSchemaAsync" Class="mt-5" DisableElevation="true">
                    @if (connectedSystem.ObjectTypes == null || connectedSystem.ObjectTypes.Count == 0)
                    {
                        <text>Retrieve Schema</text>
                    }
                    else
                    {
                        <text>Refresh Schema</text>
                    }
                </MudButton>
            </MudAlert>

            @if (connectedSystem.ObjectTypes != null && connectedSystem.ObjectTypes.Count > 0)
            {
                <MudPaper Outlined="true" Class="pa-4 mt-5">
                    <MudText Class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                        Select which object types you would like to manage with JIM.
                    </MudText>
                    <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                        @foreach (var objectType in connectedSystem.ObjectTypes)
                        {
                            <MudCheckBox T="Boolean" Checked="@objectType.Selected" Color="Color.Primary" Label="@objectType.Name" CheckedChanged="((e) => HandleSelectedObjectTypeClick(objectType, e))" />
                        }
                    </div>
                </MudPaper>

                @if (connectedSystem.ObjectTypes.Count(q => q.Selected) > 0)
                {
                    <MudPaper Outlined="true" Class="pa-4 mt-5">
                        @if (connectedSystem.ObjectTypes.Count(q => q.Selected) > 1)
                        {
                            <div class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                                <MudButtonGroup Color="Color.Default" Class="mb-5" DisableElevation="true" Variant="Variant.Outlined">
                                    @foreach (var objectType in connectedSystem.ObjectTypes.Where(q => q.Selected))
                                    {
                                        <MudButton 
                                            OnClick="@((e) => HandleActiveObjectTypeClick(objectType))" 
                                            Disabled="@(selectedObjectType != null && selectedObjectType.Id == objectType.Id)" 
                                            DisableElevation="true">@objectType.Name</MudButton>
                                    }
                                </MudButtonGroup>
                            </div>
                        }

                        @if (selectedObjectType != null)
                        {
                            <MudText Class="d-flex flex-grow-1 flex-wrap justify-center align-center">
                                Select which attributes you would like to manage for this object type. To maximise performance, only select those you need.
                            </MudText>
                            <MudText Typo="Typo.h6">@selectedObjectType.Name</MudText>

                            <MudGrid Class="mt-3 mb-3">
                                <MudItem xs="6" >
                                    <MudTextField T="string"
                                        @bind-Value="schemaSearchString"
                                        Label="Filter by name"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.Search"
                                        IconSize="Size.Small"
                                        Variant="Variant.Outlined"
                                        HelperText="Show only attributes where the name containers a specific value"
                                        autocomplete="schema_search_string" />
                                </MudItem>
                                <MudItem xs="6">
                                    <MudSelect T="string"
                                        Label="Filter by class"
                                        MultiSelection="true"
                                        @bind-SelectedValues="attributeClassFilterSelectedValues"
                                        Variant="Variant.Outlined"
                                        HelperText="Show only attributes with a particular class"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.FilterAlt"
                                        IconSize="Size.Small">
                                        @foreach (var className in selectedObjectType.Attributes.Select(a => a.ClassName).Distinct().OrderBy(a => a))
                                        {
                                            <MudSelectItem T="string" Value="@className">@className</MudSelectItem>
                                        }
                                    </MudSelect>
                                </MudItem>
                                <MudItem xs="12">
                                    <MudCheckBox 
                                        @bind-Checked="attributeSelectedFilter" 
                                        Color="Color.Primary">Show only selected?</MudCheckBox>
                                </MudItem>
                                <MudItem xs="10">
                                    <MudTextField T="string"
                                        Label="Select attributes via CSV"
                                        @bind-Value="attributeSelectionCsv"
                                        HelperText="You can also quick-select attributes by entering them in a comma-separated list, i.e. DisplayName,sAMAccountName"
                                        InputType="InputType.Text"
                                        Adornment="Adornment.Start"
                                        AdornmentIcon="@Icons.Material.Filled.Input"
                                        IconSize="Size.Small"
                                        Variant="Variant.Outlined" />
                                    </MudItem>
                                    <MudItem xs="2">
                                        <MudButton Variant="Variant.Filled" DisableElevation="true" Color="Color.Default" OnClick="HandleAttributeCsvSubmit">Select Attributes</MudButton>
                                    </MudItem>
                            </MudGrid>
                        }
                    </MudPaper>
                }

                @if (selectedObjectType != null)
                {
                    <MudTable 
                        Items="@selectedObjectType.Attributes" 
                        Virtualize="true" 
                        Hover="true" 
                        Dense="true" 
                        Breakpoint="Breakpoint.Sm" 
                        SortLabel="Sort By" 
                        Filter="new Func<ConnectedSystemObjectTypeAttribute,bool>(SchemaFilterFuncHandler)"
                        Class="mt-5"
                        Outlined="true"
                        Elevation="0">
                        <HeaderContent>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Selected)">Selected</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.ClassName)">Class</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Type)">Type</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.AttributePlurality)">Plurality</MudTableSortLabel></MudTh>
                            <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemObjectTypeAttribute, object>(x => x.Description)">Description</MudTableSortLabel></MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Selected">
                                <MudSwitch @bind-Checked="@context.Selected" Color="@Color.Primary"></MudSwitch>
                            </MudTd>
                            <MudTd DataLabel="Name">@context.Name</MudTd>
                            <MudTd DataLabel="Class">@context.ClassName</MudTd>
                            <MudTd DataLabel="Type">@context.Type</MudTd>
                            <MudTd DataLabel="Plurality" Class="jim-no-wrap">@context.AttributePlurality.ToString().SplitOnCapitalLetters()</MudTd>
                            <MudTd DataLabel="Description">@context.Description</MudTd>
                        </RowTemplate>
                        <NoRecordsContent>
                            @if (attributeSelectedFilter) {
                                <MudText>There are no selected attributes for this object type.</MudText>
                            } else {
                                <MudText>There are no attributes to show.</MudText>
                            }
                        </NoRecordsContent>
                    </MudTable>
                }               

                <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleObjectTypesAndAttributeSelectionSubmitAsync" Class="mt-5" DisableElevation="true">Save Changes</MudButton>
            }

        </MudTabPanel>

        @if (connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            <MudTabPanel Text="Partitions & Containers" Disabled="@AreSettingDependentTabsDisabled()">

                <MudAlert Severity="(connectedSystem.Partitions != null && connectedSystem.Partitions.Count > 0 ? Severity.Warning : Severity.Info)">
                    @if (connectedSystem.Partitions == null || connectedSystem.Partitions.Count == 0)
                    {
                        <MudText>Retrieve the hierarchy @partitionAndHierarchyText hierarchy from the connected system, to be able to select which ones you want to manage with JIM.</MudText>
                    }
                    else
                    {
                        <MudText>
                            <strong>Refreshing the @partitionAndHierarchyText heirarchy can result in data-loss</strong>. If partitions and/or containers are removed, then this will result in all objects in them being deleted
                            from the Connected System, which depending on your configuration, could result in those objects being deprovisioned from the Metaverse and any downstream Connected Systems. Refresh with caution.
                            Ensure the Connected System identity has the right permissions needed to retrieve the heirarchy, and consider a database backup before proceeeding.
                        </MudText>
                    }
                    <MudButton Disabled="@hierarchyBeingRetrieved"
                       Color="(connectedSystem.Partitions == null || connectedSystem.Partitions.Count == 0 ? Color.Primary : Color.Warning)"
                       Size="Size.Small"
                       OnClick="HandleImportHierarchyAsync"
                       Variant="Variant.Filled"
                       Class="mt-5"
                       DisableElevation="true">
                        @if (hierarchyBeingRetrieved)
                        {
                            <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                            <MudText Class="ms-2">Processing</MudText>
                        }
                        else
                        {
                            if (connectedSystem.Partitions?.Count == 0)
                            {
                                <text>Retrieve Hierarchy</text>
                            }
                            else
                            {
                                <text>Refresh Hierarchy</text>
                            }
                        }
                    </MudButton>
                </MudAlert>

                @if (connectedSystem.Partitions != null && connectedSystem.Partitions.Count > 0)
                {
                    <MudText Class="mt-5">Select which @partitionsAndHierarchiesText are to be managed by JIM here. To maximise performance, only select those that need managing.</MudText>

                    @for (var i = 0; i < connectedSystem.Partitions.Count; i++)
                    {
                        var partition = connectedSystem.Partitions[i];

                        <MudPaper Class="mt-5" Outlined="true">
                            <div class="pa-4">
                                <MudText Typo="Typo.h5" Class="mb-5">@partition.Name</MudText>
                                <MudSwitch @bind-Checked="@partition.Selected" Color="Color.Primary" Label="Manage this partition?" />
                            </div>
                            <MudDivider />

                            <div class="pa-4">
                                <MudText>Select the containers you want to manage in this partition.</MudText>
                                <MudButtonGroup Color="Color.Default" Size="Size.Small" Variant="Variant.Outlined" Class="mt-5 mb-5">
                                    <MudButton>Select All</MudButton>
                                    <MudButton>Clear All</MudButton>
                                </MudButtonGroup>

                                <MudTreeView Items="@partition.Containers">
                                    <ItemTemplate>
                                        <MudTreeViewItem @bind-Expanded="@context.Expanded" Items="@context.ChildContainers">
                                            <Content>
                                                <MudTreeViewItemToggleButton @bind-Expanded="@context.Expanded" Visible="@(context.ChildContainers.Count > 0)" />

                                                @if (context.Included)
                                                {
                                                    <MudCheckBox T="bool?"
                                                        Checked="@(context.AreAnyChildContainersSelected() ? null : context.Selected)"
                                                        CheckedChanged="@((e) => ConnectedSystemContainerSelectedChanged(context, e))"
                                                        UncheckedIcon="@Icons.Material.Outlined.FilterCenterFocus"
                                                        Disabled="true"
                                                        title="Included" />
                                                }
                                                else
                                                {
                                                    <MudCheckBox T="bool?"
                                                        Checked="@(context.AreAnyChildContainersSelected() ? null : context.Selected)"
                                                        CheckedChanged="@((e) => ConnectedSystemContainerSelectedChanged(context, e))"
                                                        title="@(context.Selected ? "Selected" : "")" />
                                                }

                                                <MudText>@context.Name</MudText>
                                            </Content>
                                        </MudTreeViewItem>
                                    </ItemTemplate>
                                </MudTreeView>

                            </div>

                        </MudPaper>
                    }

                    <MudButton Color="Color.Primary" Variant="Variant.Filled" OnClick="HandleHierarchySelectionSubmitAsync" Class="mt-5" DisableElevation="true">Save Changes</MudButton>
                }
            </MudTabPanel>
        }

        <MudTabPanel Text="Run Profiles" Disabled="@IsRunProfilesTabDisabled()">
            <MudAlert Severity="Severity.Info">Run profiles define what operations can be performed on a Connector, i.e. import, export and synchronisation, with any required settings.</MudAlert>

            <MudPaper Outlined="true" Class="pa-4 mt-5">
                <MudText Typo="Typo.h6">Create a New Run Profile</MudText>

                <MudForm @bind-IsValid="@IsNewRunProfileFormValid">
                    <MudTextField T="string" @bind-Value="newRunProfile.Name" Label="Name" Variant="Variant.Outlined" Class="mt-3" Required="true" RequiredError="A name for the run profile is required" />
                    <MudSelect T="ConnectedSystemRunType" @bind-Value="newRunProfile.RunType" Label="Run Type" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomCenter" Class="mt-5" Required="true" RequiredError="A run profile type is required">
                        @foreach (ConnectedSystemRunType runType in Enum.GetValues(typeof(ConnectedSystemRunType)))
                        {
                            <MudSelectItem Value="@runType">@runType.ToString().SplitOnCapitalLetters()</MudSelectItem>
                        }
                    </MudSelect>
                    @if (connectedSystem.ConnectorDefinition.SupportsPartitions && connectedSystem.Partitions != null)
                    {
                        <MudSelect T="ConnectedSystemPartition" @bind-Value="newRunProfile.Partition" Label="Partition" Variant="Variant.Outlined" Class="mt-5" AnchorOrigin="Origin.BottomCenter" Required="@connectedSystem.ConnectorDefinition.SupportsPartitions" RequiredError="A run profile partition is required">
                            @foreach (ConnectedSystemPartition partition in connectedSystem.Partitions)
                            {
                                <MudSelectItem Value="@partition" />
                            }
                        </MudSelect>
                    }
                    <MudNumericField @bind-Value="newRunProfile.PageSize" Label="Page Size" Variant="Variant.Outlined" Class="mt-3" Min="0" Step="100" Required="true" RequiredError="How many items to process in one go when importing/exporting" />
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" Disabled="@(!IsNewRunProfileFormValid)" OnClick="HandleNewRunProfileFormSubmitAsync" Class="mt-5" DisableElevation="true">Create Run Profile</MudButton>
                </MudForm>
            </MudPaper>

            <MudTable Items="@connectedSystem.RunProfiles" Hover="true" Breakpoint="Breakpoint.Sm" Class="mt-5" SortLabel="Sort By" Outlined="true" Elevation="0">
                <HeaderContent>
                    <MudTh>Actions</MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Name)">Name</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.RunType)">Run Type</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.Partition.Name)">Partition</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortBy="new Func<ConnectedSystemRunProfile, object>(x => x.PageSize)">Page Size</MudTableSortLabel></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>
                        <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true">
                            <MudMenuItem Icon="@Icons.Material.Filled.Delete" IconSize="Size.Small" OnClick="((e) => HandleRunProfileDeleteAsync(context))">Delete</MudMenuItem>
                        </MudMenu>
                    </MudTd>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudTd DataLabel="Run Type">@context.RunType.ToString().SplitOnCapitalLetters()</MudTd>
                    <MudTd DataLabel="Partition">@(context.Partition != null ? context.Partition.Name : "-")</MudTd>
                    <MudTd DataLabel="Page Size">@context.PageSize</MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    There are no run profiles. Create your first.
                </NoRecordsContent>
            </MudTable>

        </MudTabPanel>

    </MudTabs>
}

@code {
    [Parameter]
    public int Id { get; set; }
    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }
    private bool IsDetailsFormValid { get; set; }
    private string[] DetailsFormErrors { get; set; } = { };
    private bool IsSettingsFormValid { get; set; }
    private string[] SettingsFormErrors { get; set; } = { };
    private Dictionary<string, string> SettingsFormCustomErrors { get; set; } = new Dictionary<string, string>();
    private bool IsNewRunProfileFormValid { get; set; }    

    private ConnectedSystem? connectedSystem;
    private bool settingsBeingSaved = false;
    private List<ConnectedSystemSettingCategory>? settingCategories;
    private string? partitionsAndHierarchiesText;
    private string? partitionAndHierarchyText;
    private bool schemaBeingRetrieved;
    private ConnectedSystemObjectType? selectedObjectType;
    private bool hierarchyBeingRetrieved;
    private string schemaSearchString = "";
    private ConnectedSystemRunProfile newRunProfile = new ConnectedSystemRunProfile { PageSize = 500 };
    private IEnumerable<string> attributeClassFilterSelectedValues { get; set; } = new HashSet<string>();
    private bool attributeSelectedFilter;
    private string? attributeSelectionCsv;
    private List<BreadcrumbItem> breadcrumbs = null!;

    protected override async Task OnInitializedAsync()
    {
        connectedSystem = await Jim.ConnectedSystems.GetConnectedSystemAsync(Id);
        if (connectedSystem == null)
        {
            // connected system not found, redirect to index page
            NavManager.NavigateTo("../");
            return;
        }

        breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
            new BreadcrumbItem("Connected Systems", href: "/admin/connected-systems/"),
            new BreadcrumbItem(connectedSystem.Name, href: null, disabled: true)
        };

        // get a list of the distinct setting categories in use, so we can render them in category blocks
        settingCategories = connectedSystem.SettingValues.Select(q => q.Setting.Category).Distinct().ToList();

        // to save us having to perform this comparison all over the view
        if (connectedSystem.ConnectorDefinition.SupportsPartitions && connectedSystem.ConnectorDefinition.SupportsPartitionContainers)
        {
            partitionsAndHierarchiesText = "partitions and containers";
            partitionAndHierarchyText = "partition and container";
        }
        else if (connectedSystem.ConnectorDefinition.SupportsPartitions)
        {
            partitionsAndHierarchiesText = "partitions";
            partitionAndHierarchyText = "partition";
        }

        // show the first selected object type attribute table
        if (connectedSystem.ObjectTypes != null)
            selectedObjectType = connectedSystem.ObjectTypes.FirstOrDefault(q => q.Selected);

        ApplyContainerIncludedToPartitions(connectedSystem);
    }

    private bool AreSettingDependentTabsDisabled()
    {
        if (connectedSystem == null)
            return true;
        else if (connectedSystem.SettingValuesValid)
            return false;
        else
            return true;
    }

    private async Task HandleValidDetailsSubmitAsync()
    {
        if (connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidDetailsSubmitAsync)}: connectedSystem was null");
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(connectedSystem, user);
        Snackbar.Add("Your details changes have been saved.", Severity.Success);
    }

    private async Task HandleValidSettingsSubmitAsync()
    {
        if (connectedSystem == null)
        {
            Console.WriteLine($"{nameof(HandleValidSettingsSubmitAsync)}: connectedSystem was null");
            return;
        }

        settingsBeingSaved = true;

        // validate the form
        SettingsFormCustomErrors.Clear();
        var results = Jim.ConnectedSystems.ValidateConnectedSystemSettings(connectedSystem);
        for (var i = 0; i < results.Count; i++)
        {
            var result = results[i];
            if (result.IsValid)
                continue;

            if (result.SettingValue != null && result.SettingValue.Setting != null && result.SettingValue.Setting.Name != null && !string.IsNullOrEmpty(result.ErrorMessage))
                SettingsFormCustomErrors.Add(result.SettingValue.Setting.Name, result.ErrorMessage);
            else if (result.SettingValue == null && !string.IsNullOrEmpty(result.ErrorMessage))
                SettingsFormCustomErrors.Add($"General issue {i + 1}", result.ErrorMessage);
        }

        if (SettingsFormCustomErrors.Any())
        {
            settingsBeingSaved = false;
            return;
        }

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(connectedSystem, user);
        Snackbar.Add("Your setting changes have been saved.", Severity.Success);
        settingsBeingSaved = false;
    }

    private async Task HandleImportSchemaAsync()
    {
        if (connectedSystem == null)
            return;

        schemaBeingRetrieved = true;
        await Jim.ConnectedSystems.ImportConnectedSystemSchemaAsync(connectedSystem);
        schemaBeingRetrieved = false;
    }

    private void HandleSelectedObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType, bool isObjectTypeChecked)
    {
        if (connectedSystem == null)
            return;

        // actuate the state change
        connectedSystemObjectType.Selected = isObjectTypeChecked;

        // now cascacde
        // if only one type is selected, make that the selected object type
        // if none are selected, clear selected object type
        // if the selected type is being de-selected, null the selected type
        if (connectedSystem.ObjectTypes != null && connectedSystem.ObjectTypes.Count(q => q.Selected) == 1)
            selectedObjectType = connectedSystem.ObjectTypes.Single(q => q.Selected);
        else if (connectedSystem.ObjectTypes == null || connectedSystem.ObjectTypes.Count(q => q.Selected) == 0)
            selectedObjectType = null;
        else if (selectedObjectType != null && selectedObjectType.Id == connectedSystemObjectType.Id && !isObjectTypeChecked)
            selectedObjectType = null;
    }

    private void HandleActiveObjectTypeClick(ConnectedSystemObjectType connectedSystemObjectType)
    {
        selectedObjectType = connectedSystemObjectType;
    }

    private async Task HandleObjectTypesAndAttributeSelectionSubmitAsync()
    {
        if (connectedSystem == null)
            return;

        // attribute the update to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(connectedSystem, user);
        Snackbar.Add("Your attribute changes have been saved.", Severity.Success);
    }

    private async Task HandleImportHierarchyAsync()
    {
        if (connectedSystem == null)
            return;

        // attribute the import to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);

        hierarchyBeingRetrieved = true;
        await Jim.ConnectedSystems.ImportConnectedSystemHierarchyAsync(connectedSystem, user);
        hierarchyBeingRetrieved = false;
    }

    private async Task HandleHierarchySelectionSubmitAsync()
    {
        if (connectedSystem == null)
            return;

        // attribute the actiont to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.UpdateConnectedSystemAsync(connectedSystem, user);
        Snackbar.Add("Your hierarchy changes have been saved.", Severity.Success);
    }

    private bool SchemaFilterFuncHandler(ConnectedSystemObjectTypeAttribute element) => SchemaFilterFunc(element, schemaSearchString, attributeClassFilterSelectedValues, attributeSelectionCsv, attributeSelectedFilter);

    private bool SchemaFilterFunc(ConnectedSystemObjectTypeAttribute element, string searchString, IEnumerable<string> attributeClassFilterSelectedValues, string attributeSelectionCsv, bool attributeSelectedFilter)
    {
        // what type of search is this? name, class or csv?
        var classHashset = (HashSet<string>)attributeClassFilterSelectedValues;

        if (!string.IsNullOrEmpty(searchString))
        {
            if (element.Name.Contains(searchString, StringComparison.OrdinalIgnoreCase))
                return true;
            else
                return false;
        }
        else if (classHashset.Count > 0)
        {
            if (classHashset.Any(q => q == element.ClassName))
                return true;
            else
                return false;
        }
        else if (attributeSelectedFilter)
        {
            if (element.Selected)
                return true;
            else 
                return false;
        }

        return true;
    }

    private void ConnectedSystemContainerSelectedChanged(ConnectedSystemContainer container, bool? newCheckboxValue)
    {
        // if included and clicked, change to not included, not selected
        if (container.Included)
        {
            container.Selected = false;
            container.Included = false;
        }
        else
        {
            // toggle the current setting
            container.Selected = !container.Selected;
            container.Included = false;
        }

        // set the right selected/included values for all children
        if (container.Selected)
        {
            // all children should be included and not selected
            foreach (ConnectedSystemContainer child in container.ChildContainers)
            {
                child.Included = true;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, true);
            }
        }
        else
        {
            // all children should be not selected and not included
            foreach (ConnectedSystemContainer child in container.ChildContainers)
            {
                child.Included = false;
                child.Selected = false;
                ApplyContainerStatusDownBranch(child, false, false);
            }
        }

        // set the parent(s) if necessary
        if (container.ParentContainer != null)
        {
            // go up a level. if all children are selected, then make parent selected and all children (resursively) included.
            CorrectUpwardContainerStatus(container.ParentContainer);
        }
    }

    private void ApplyContainerStatusDownBranch(ConnectedSystemContainer container, bool selected, bool included)
    {
        foreach (ConnectedSystemContainer child in container.ChildContainers)
        {
            child.Included = included;
            child.Selected = selected;
            ApplyContainerStatusDownBranch(child, selected, included);
        }
    }

    private void ApplyContainerIncludedToPartitions(ConnectedSystem connectedSystem)
    {
        if (connectedSystem.Partitions == null)
            return;

        foreach (var partition in connectedSystem.Partitions)
            if (partition.Containers != null)
                foreach (var container in partition.Containers)
                    ApplyContainerIncludedRecursively(container, container.Selected);
    }

    private void ApplyContainerIncludedRecursively(ConnectedSystemContainer connectedSystemContainer, bool aParentWasSelected)
    {
        foreach (var childContainer in connectedSystemContainer.ChildContainers)
        {
            var shouldChildBeIncluded = aParentWasSelected;

            // parent was selected, so this child container should be marked as included
            if (aParentWasSelected)
                childContainer.Included = true;

            // if this child container is selected, then it's children should be marked as included
            if (childContainer.Selected)
                shouldChildBeIncluded = true;

            ApplyContainerIncludedRecursively(childContainer, shouldChildBeIncluded);
        }
    }

    private void CorrectUpwardContainerStatus(ConnectedSystemContainer parentContainer)
    {
        if (parentContainer.ChildContainers.All(q => q.Selected))
        {
            parentContainer.Selected = true;
            parentContainer.Included = false;

            foreach (var childContainer in parentContainer.ChildContainers)
            {
                childContainer.Selected = false;
                childContainer.Included = true;
                ApplyContainerStatusDownBranch(childContainer, false, true);
            }
        }

        if (parentContainer.ParentContainer != null)
            CorrectUpwardContainerStatus(parentContainer.ParentContainer);
    }

    private bool IsRunProfilesTabDisabled()
    {
        if (connectedSystem == null)
            return true;

        if (connectedSystem.ConnectorDefinition.SupportsPartitions && (connectedSystem.Partitions == null || connectedSystem.Partitions.Count == 0))
            return true;

        return false;
    }

    private async Task HandleNewRunProfileFormSubmitAsync()
    {
        if (connectedSystem == null || connectedSystem.RunProfiles == null)
            return;

        // copy the form bound object to a new one we can persist separately from the form bind
        var runProfile = new ConnectedSystemRunProfile { 
            ConnectedSystemId = connectedSystem.Id,
            Name = newRunProfile.Name,
            RunType = newRunProfile.RunType,
            Partition = newRunProfile.Partition,
            PageSize = newRunProfile.PageSize
        };

        // attribute the action to the user and create the run profile
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.CreateConnectedSystemRunProfileAsync(runProfile, user);
        
        Snackbar.Add("New run profile added.", Severity.Success);

        // reset the object we've bound to the form so a new run profile can be created if the user chooses
        newRunProfile = new ConnectedSystemRunProfile();
    }

    private async Task HandleRunProfileDeleteAsync(ConnectedSystemRunProfile connectedSystemRunProfile)
    {
        if (connectedSystem == null || connectedSystem.RunProfiles == null)
            return;

        connectedSystem.RunProfiles.Remove(connectedSystemRunProfile);

        // attribute the action to the user
        var user = await Helpers.GetUserAsync(Jim, authenticationStateTask);
        await Jim.ConnectedSystems.DeleteConnectedSystemRunProfileAsync(connectedSystemRunProfile, user);

        Snackbar.Add("Run profile removed.", Severity.Success);
    }

    private void HandleAttributeCsvSubmit()
    {
        if (selectedObjectType == null)
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: connectedSystem was null");
            return;
        }

        if (string.IsNullOrEmpty(attributeSelectionCsv))
        {
            Console.WriteLine($"{nameof(HandleAttributeCsvSubmit)}: attributeSelectionCsv is null or empty");
            return;
        }

        // clear the other search boxes
        schemaSearchString = string.Empty;
        ((HashSet<string>)attributeClassFilterSelectedValues).Clear();

        // convert the csv to a list and trim the entries
        // go through each attribute on the object type and select it
        foreach (var attributeName in attributeSelectionCsv.Split(','))
        {
            var attribute = selectedObjectType.Attributes.SingleOrDefault(a => a.Name.Equals(attributeName.Trim(), StringComparison.OrdinalIgnoreCase));
            if (attribute == null)
                continue;

            attribute.Selected = true;
        }

        // filter by selected
        attributeSelectedFilter = true;

        // clear the attribute csv textbox
        attributeSelectionCsv = null;

        // all done, let the user know
        Snackbar.Add("Attributes selected.", Severity.Success);
    }
}